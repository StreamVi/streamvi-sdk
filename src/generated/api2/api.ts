/* tslint:disable */
/* eslint-disable */
/**
 * StreamVi Backend
 * API
 *
 * The version of the OpenAPI document: 3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AmountItem
 */
export interface AmountItem {
    /**
     * Amount of money
     * @type {number}
     * @memberof AmountItem
     */
    'amount': number;
    /**
     * Currency
     * @type {string}
     * @memberof AmountItem
     */
    'currency': AmountItemCurrencyEnum;
}

export const AmountItemCurrencyEnum = {
    Rub: 'rub',
    Usd: 'usd'
} as const;

export type AmountItemCurrencyEnum = typeof AmountItemCurrencyEnum[keyof typeof AmountItemCurrencyEnum];

/**
 * 
 * @export
 * @interface BalanceForPayResponse
 */
export interface BalanceForPayResponse {
    /**
     * Balance
     * @type {number}
     * @memberof BalanceForPayResponse
     */
    'balance': number;
    /**
     * Currency
     * @type {string}
     * @memberof BalanceForPayResponse
     */
    'currency': BalanceForPayResponseCurrencyEnum;
    /**
     * Allowed balances
     * @type {Array<string>}
     * @memberof BalanceForPayResponse
     */
    'balances_allow': Array<BalanceForPayResponseBalancesAllowEnum>;
    /**
     * Balances values
     * @type {MoneyFlowBalanceTypeValuesResponse}
     * @memberof BalanceForPayResponse
     */
    'balances_values': MoneyFlowBalanceTypeValuesResponse;
}

export const BalanceForPayResponseCurrencyEnum = {
    Rub: 'rub',
    Usd: 'usd'
} as const;

export type BalanceForPayResponseCurrencyEnum = typeof BalanceForPayResponseCurrencyEnum[keyof typeof BalanceForPayResponseCurrencyEnum];
export const BalanceForPayResponseBalancesAllowEnum = {
    Bonus: 'bonus',
    Payment: 'payment',
    Profit: 'profit'
} as const;

export type BalanceForPayResponseBalancesAllowEnum = typeof BalanceForPayResponseBalancesAllowEnum[keyof typeof BalanceForPayResponseBalancesAllowEnum];

/**
 * 
 * @export
 * @interface BlogPageSiteResponse
 */
export interface BlogPageSiteResponse {
    /**
     * 
     * @type {BlogPageSiteResponseId}
     * @memberof BlogPageSiteResponse
     */
    '_id': BlogPageSiteResponseId;
    /**
     * Url of page
     * @type {string}
     * @memberof BlogPageSiteResponse
     */
    'url': string;
    /**
     * Page status
     * @type {string}
     * @memberof BlogPageSiteResponse
     */
    'status': BlogPageSiteResponseStatusEnum;
    /**
     * Date of last update
     * @type {string}
     * @memberof BlogPageSiteResponse
     */
    'date_update': string;
    /**
     * Date of publish for sort
     * @type {string}
     * @memberof BlogPageSiteResponse
     */
    'date_publish': string;
    /**
     * Tags
     * @type {Array<object>}
     * @memberof BlogPageSiteResponse
     */
    'tags': Array<object>;
    /**
     * Language for indexing
     * @type {string}
     * @memberof BlogPageSiteResponse
     */
    'language': BlogPageSiteResponseLanguageEnum;
    /**
     * Language ISO
     * @type {string}
     * @memberof BlogPageSiteResponse
     */
    'language_iso': BlogPageSiteResponseLanguageIsoEnum;
    /**
     * Subject
     * @type {string}
     * @memberof BlogPageSiteResponse
     */
    'title': string;
    /**
     * Url of main image
     * @type {string}
     * @memberof BlogPageSiteResponse
     */
    'image': string;
    /**
     * Short text
     * @type {string}
     * @memberof BlogPageSiteResponse
     */
    'short_text': string;
    /**
     * Text
     * @type {string}
     * @memberof BlogPageSiteResponse
     */
    'text': string;
    /**
     * Alternative language (Array of Language ISO)
     * @type {Array<string>}
     * @memberof BlogPageSiteResponse
     */
    'alt_languages': Array<BlogPageSiteResponseAltLanguagesEnum>;
}

export const BlogPageSiteResponseStatusEnum = {
    None: 'None',
    Backlog: 'Backlog',
    Drafting: 'Drafting',
    Reviewing: 'Reviewing',
    Done: 'Done',
    Published: 'Published'
} as const;

export type BlogPageSiteResponseStatusEnum = typeof BlogPageSiteResponseStatusEnum[keyof typeof BlogPageSiteResponseStatusEnum];
export const BlogPageSiteResponseLanguageEnum = {
    Russian: 'russian',
    English: 'english',
    None: 'none'
} as const;

export type BlogPageSiteResponseLanguageEnum = typeof BlogPageSiteResponseLanguageEnum[keyof typeof BlogPageSiteResponseLanguageEnum];
export const BlogPageSiteResponseLanguageIsoEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type BlogPageSiteResponseLanguageIsoEnum = typeof BlogPageSiteResponseLanguageIsoEnum[keyof typeof BlogPageSiteResponseLanguageIsoEnum];
export const BlogPageSiteResponseAltLanguagesEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type BlogPageSiteResponseAltLanguagesEnum = typeof BlogPageSiteResponseAltLanguagesEnum[keyof typeof BlogPageSiteResponseAltLanguagesEnum];

/**
 * 
 * @export
 * @interface BlogPageSiteResponseId
 */
export interface BlogPageSiteResponseId {
    /**
     * 
     * @type {object}
     * @memberof BlogPageSiteResponseId
     */
    'type': object;
}
/**
 * 
 * @export
 * @interface CategoryItemResponse
 */
export interface CategoryItemResponse {
    /**
     * id
     * @type {string}
     * @memberof CategoryItemResponse
     */
    'id': string;
    /**
     * name
     * @type {string}
     * @memberof CategoryItemResponse
     */
    'name': string;
    /**
     * image
     * @type {string}
     * @memberof CategoryItemResponse
     */
    'image'?: string;
    /**
     * sublist
     * @type {Array<CategorySubListItemResponse>}
     * @memberof CategoryItemResponse
     */
    'subList'?: Array<CategorySubListItemResponse>;
}
/**
 * 
 * @export
 * @interface CategorySubListItemResponse
 */
export interface CategorySubListItemResponse {
    /**
     * id
     * @type {string}
     * @memberof CategorySubListItemResponse
     */
    'id': string;
    /**
     * name
     * @type {string}
     * @memberof CategorySubListItemResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ChannelCategoryInfoDto
 */
export interface ChannelCategoryInfoDto {
    /**
     * 
     * @type {string}
     * @memberof ChannelCategoryInfoDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ChannelCategoryInfoDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ChannelDefaultInfoDto
 */
export interface ChannelDefaultInfoDto {
    /**
     * Title of the channel
     * @type {string}
     * @memberof ChannelDefaultInfoDto
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface ChannelOkInfoDto
 */
export interface ChannelOkInfoDto {
    /**
     * Title of the channel
     * @type {string}
     * @memberof ChannelOkInfoDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ChannelOkInfoDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface ChannelPlayListInfoDto
 */
export interface ChannelPlayListInfoDto {
    /**
     * 
     * @type {string}
     * @memberof ChannelPlayListInfoDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ChannelTrovoInfoDto
 */
export interface ChannelTrovoInfoDto {
    /**
     * Title of the channel
     * @type {string}
     * @memberof ChannelTrovoInfoDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ChannelTrovoInfoDto
     */
    'lang'?: ChannelTrovoInfoDtoLangEnum;
    /**
     * 
     * @type {string}
     * @memberof ChannelTrovoInfoDto
     */
    'audience'?: ChannelTrovoInfoDtoAudienceEnum;
    /**
     * 
     * @type {ChannelCategoryInfoDto}
     * @memberof ChannelTrovoInfoDto
     */
    'category'?: ChannelCategoryInfoDto;
}

export const ChannelTrovoInfoDtoLangEnum = {
    Ru: 'ru',
    En: 'en'
} as const;

export type ChannelTrovoInfoDtoLangEnum = typeof ChannelTrovoInfoDtoLangEnum[keyof typeof ChannelTrovoInfoDtoLangEnum];
export const ChannelTrovoInfoDtoAudienceEnum = {
    ChannelAudienceTypeFamilyfriendly: 'CHANNEL_AUDIENCE_TYPE_FAMILYFRIENDLY',
    ChannelAudienceTypeTeen: 'CHANNEL_AUDIENCE_TYPE_TEEN',
    ChannelAudienceTypeEighteenplus: 'CHANNEL_AUDIENCE_TYPE_EIGHTEENPLUS'
} as const;

export type ChannelTrovoInfoDtoAudienceEnum = typeof ChannelTrovoInfoDtoAudienceEnum[keyof typeof ChannelTrovoInfoDtoAudienceEnum];

/**
 * 
 * @export
 * @interface ChannelTwitchInfoDto
 */
export interface ChannelTwitchInfoDto {
    /**
     * Title of the channel
     * @type {string}
     * @memberof ChannelTwitchInfoDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ChannelTwitchInfoDto
     */
    'lang'?: ChannelTwitchInfoDtoLangEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChannelTwitchInfoDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {ChannelCategoryInfoDto}
     * @memberof ChannelTwitchInfoDto
     */
    'category'?: ChannelCategoryInfoDto;
    /**
     * 
     * @type {string}
     * @memberof ChannelTwitchInfoDto
     */
    'domain'?: string;
}

export const ChannelTwitchInfoDtoLangEnum = {
    Ru: 'ru',
    En: 'en'
} as const;

export type ChannelTwitchInfoDtoLangEnum = typeof ChannelTwitchInfoDtoLangEnum[keyof typeof ChannelTwitchInfoDtoLangEnum];

/**
 * 
 * @export
 * @interface ChannelVkCategoryInfoDto
 */
export interface ChannelVkCategoryInfoDto {
    /**
     * 
     * @type {string}
     * @memberof ChannelVkCategoryInfoDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ChannelVkCategoryInfoDto
     */
    'name': string;
    /**
     * 
     * @type {ChannelCategoryInfoDto}
     * @memberof ChannelVkCategoryInfoDto
     */
    'secondary'?: ChannelCategoryInfoDto;
}
/**
 * 
 * @export
 * @interface ChannelVkInfoDto
 */
export interface ChannelVkInfoDto {
    /**
     * Title of the channel
     * @type {string}
     * @memberof ChannelVkInfoDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ChannelVkInfoDto
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelVkInfoDto
     */
    'wall'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChannelVkInfoDto
     */
    'privacyVideo'?: ChannelVkInfoDtoPrivacyVideoEnum;
    /**
     * 
     * @type {string}
     * @memberof ChannelVkInfoDto
     */
    'privacyComments'?: ChannelVkInfoDtoPrivacyCommentsEnum;
    /**
     * 
     * @type {ChannelPlayListInfoDto}
     * @memberof ChannelVkInfoDto
     */
    'playlist'?: ChannelPlayListInfoDto;
    /**
     * 
     * @type {ChannelVkCategoryInfoDto}
     * @memberof ChannelVkInfoDto
     */
    'category'?: ChannelVkCategoryInfoDto;
}

export const ChannelVkInfoDtoPrivacyVideoEnum = {
    All: 'all',
    Members: 'members',
    Editors: 'editors',
    ByLink: 'by_link',
    Donut: 'donut'
} as const;

export type ChannelVkInfoDtoPrivacyVideoEnum = typeof ChannelVkInfoDtoPrivacyVideoEnum[keyof typeof ChannelVkInfoDtoPrivacyVideoEnum];
export const ChannelVkInfoDtoPrivacyCommentsEnum = {
    All: 'all',
    Members: 'members',
    Editors: 'editors',
    Nobody: 'nobody'
} as const;

export type ChannelVkInfoDtoPrivacyCommentsEnum = typeof ChannelVkInfoDtoPrivacyCommentsEnum[keyof typeof ChannelVkInfoDtoPrivacyCommentsEnum];

/**
 * 
 * @export
 * @interface ChannelYoutubeInfoDto
 */
export interface ChannelYoutubeInfoDto {
    /**
     * Title of the channel
     * @type {string}
     * @memberof ChannelYoutubeInfoDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ChannelYoutubeInfoDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ChannelYoutubeInfoDto
     */
    'lang'?: ChannelYoutubeInfoDtoLangEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChannelYoutubeInfoDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {ChannelCategoryInfoDto}
     * @memberof ChannelYoutubeInfoDto
     */
    'category'?: ChannelCategoryInfoDto;
    /**
     * 
     * @type {ChannelPlayListInfoDto}
     * @memberof ChannelYoutubeInfoDto
     */
    'playlist'?: ChannelPlayListInfoDto;
    /**
     * 
     * @type {string}
     * @memberof ChannelYoutubeInfoDto
     */
    'privacyVideo'?: ChannelYoutubeInfoDtoPrivacyVideoEnum;
    /**
     * 
     * @type {string}
     * @memberof ChannelYoutubeInfoDto
     */
    'latency'?: ChannelYoutubeInfoDtoLatencyEnum;
    /**
     * 
     * @type {string}
     * @memberof ChannelYoutubeInfoDto
     */
    'audience'?: ChannelYoutubeInfoDtoAudienceEnum;
    /**
     * 
     * @type {string}
     * @memberof ChannelYoutubeInfoDto
     */
    'image'?: string;
}

export const ChannelYoutubeInfoDtoLangEnum = {
    Ru: 'ru',
    En: 'en'
} as const;

export type ChannelYoutubeInfoDtoLangEnum = typeof ChannelYoutubeInfoDtoLangEnum[keyof typeof ChannelYoutubeInfoDtoLangEnum];
export const ChannelYoutubeInfoDtoPrivacyVideoEnum = {
    Private: 'private',
    Public: 'public',
    Unlisted: 'unlisted'
} as const;

export type ChannelYoutubeInfoDtoPrivacyVideoEnum = typeof ChannelYoutubeInfoDtoPrivacyVideoEnum[keyof typeof ChannelYoutubeInfoDtoPrivacyVideoEnum];
export const ChannelYoutubeInfoDtoLatencyEnum = {
    Normal: 'normal',
    Low: 'low',
    UltraLow: 'ultraLow'
} as const;

export type ChannelYoutubeInfoDtoLatencyEnum = typeof ChannelYoutubeInfoDtoLatencyEnum[keyof typeof ChannelYoutubeInfoDtoLatencyEnum];
export const ChannelYoutubeInfoDtoAudienceEnum = {
    MarkForKids: 'mark_for_kids',
    MarkForNokids: 'mark_for_nokids'
} as const;

export type ChannelYoutubeInfoDtoAudienceEnum = typeof ChannelYoutubeInfoDtoAudienceEnum[keyof typeof ChannelYoutubeInfoDtoAudienceEnum];

/**
 * 
 * @export
 * @interface CheckPullKeyResponse
 */
export interface CheckPullKeyResponse {
    /**
     * Transport
     * @type {string}
     * @memberof CheckPullKeyResponse
     */
    'transport': CheckPullKeyResponseTransportEnum;
    /**
     * Pull status
     * @type {string}
     * @memberof CheckPullKeyResponse
     */
    'status': CheckPullKeyResponseStatusEnum;
    /**
     * Key
     * @type {string}
     * @memberof CheckPullKeyResponse
     */
    'key': string;
}

export const CheckPullKeyResponseTransportEnum = {
    Rtmp: 'rtmp',
    Srt: 'srt',
    Hls: 'hls'
} as const;

export type CheckPullKeyResponseTransportEnum = typeof CheckPullKeyResponseTransportEnum[keyof typeof CheckPullKeyResponseTransportEnum];
export const CheckPullKeyResponseStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    Error: 'error'
} as const;

export type CheckPullKeyResponseStatusEnum = typeof CheckPullKeyResponseStatusEnum[keyof typeof CheckPullKeyResponseStatusEnum];

/**
 * 
 * @export
 * @interface CodeAppAuthResponse
 */
export interface CodeAppAuthResponse {
    /**
     * Code for auth in app
     * @type {string}
     * @memberof CodeAppAuthResponse
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface CountryItem
 */
export interface CountryItem {
    /**
     * Country name
     * @type {string}
     * @memberof CountryItem
     */
    'name': string;
    /**
     * Country code
     * @type {string}
     * @memberof CountryItem
     */
    'code': string;
    /**
     * Id of the country
     * @type {number}
     * @memberof CountryItem
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface CreatePullKeyRequest
 */
export interface CreatePullKeyRequest {
    /**
     * Version
     * @type {string}
     * @memberof CreatePullKeyRequest
     */
    'v': CreatePullKeyRequestVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof CreatePullKeyRequest
     */
    'language': CreatePullKeyRequestLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof CreatePullKeyRequest
     */
    'project_id': number;
    /**
     * Provider oauth
     * @type {string}
     * @memberof CreatePullKeyRequest
     */
    'transport': CreatePullKeyRequestTransportEnum;
    /**
     * Name
     * @type {string}
     * @memberof CreatePullKeyRequest
     */
    'name'?: string;
}

export const CreatePullKeyRequestVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type CreatePullKeyRequestVEnum = typeof CreatePullKeyRequestVEnum[keyof typeof CreatePullKeyRequestVEnum];
export const CreatePullKeyRequestLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type CreatePullKeyRequestLanguageEnum = typeof CreatePullKeyRequestLanguageEnum[keyof typeof CreatePullKeyRequestLanguageEnum];
export const CreatePullKeyRequestTransportEnum = {
    Rtmp: 'rtmp',
    Srt: 'srt',
    Hls: 'hls'
} as const;

export type CreatePullKeyRequestTransportEnum = typeof CreatePullKeyRequestTransportEnum[keyof typeof CreatePullKeyRequestTransportEnum];

/**
 * 
 * @export
 * @interface CreatePullKeyResponse
 */
export interface CreatePullKeyResponse {
    /**
     * Key ID
     * @type {number}
     * @memberof CreatePullKeyResponse
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface ErrorData
 */
export interface ErrorData {
    /**
     * Error name
     * @type {string}
     * @memberof ErrorData
     */
    'name': string;
    /**
     * Error message
     * @type {string}
     * @memberof ErrorData
     */
    'msg': string;
    /**
     * Validator error array if name=\"I18nValidationException\"
     * @type {Array<ValidationErrorDto>}
     * @memberof ErrorData
     */
    'validator_error'?: Array<ValidationErrorDto>;
    /**
     * Options
     * @type {object}
     * @memberof ErrorData
     */
    'options': object;
    /**
     * Custom object for error
     * @type {object}
     * @memberof ErrorData
     */
    'data': object;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Object with description of error
     * @type {ErrorData}
     * @memberof ErrorResponse
     */
    'error': ErrorData;
}
/**
 * 
 * @export
 * @interface GetHelpPageResponse
 */
export interface GetHelpPageResponse {
    /**
     * Response execution success
     * @type {boolean}
     * @memberof GetHelpPageResponse
     */
    'success': boolean;
    /**
     * Page data
     * @type {HelpPageResponse}
     * @memberof GetHelpPageResponse
     */
    'result': HelpPageResponse;
}
/**
 * 
 * @export
 * @interface GetPaySettingResponseV3
 */
export interface GetPaySettingResponseV3 {
    /**
     * Pay settings data data
     * @type {PaySettingResponseV3}
     * @memberof GetPaySettingResponseV3
     */
    'result': PaySettingResponseV3 | null;
}
/**
 * 
 * @export
 * @interface GetStreamKeyResponse
 */
export interface GetStreamKeyResponse {
    /**
     * Seconds the stream guard
     * @type {number}
     * @memberof GetStreamKeyResponse
     */
    'wait': number;
    /**
     * Is recordable stream
     * @type {boolean}
     * @memberof GetStreamKeyResponse
     */
    'record': boolean;
    /**
     * Key
     * @type {string}
     * @memberof GetStreamKeyResponse
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface GetVersionAppResponse
 */
export interface GetVersionAppResponse {
    /**
     * release name
     * @type {string}
     * @memberof GetVersionAppResponse
     */
    'name': string;
    /**
     * release version
     * @type {string}
     * @memberof GetVersionAppResponse
     */
    'version': string;
    /**
     * date
     * @type {string}
     * @memberof GetVersionAppResponse
     */
    'date': string;
}
/**
 * 
 * @export
 * @interface HelpPageResponse
 */
export interface HelpPageResponse {
    /**
     * 
     * @type {BlogPageSiteResponseId}
     * @memberof HelpPageResponse
     */
    '_id': BlogPageSiteResponseId;
    /**
     * url
     * @type {string}
     * @memberof HelpPageResponse
     */
    'url': string;
    /**
     * Generated url from root path
     * @type {string}
     * @memberof HelpPageResponse
     */
    'url_inherit': string;
    /**
     * Notion parent id
     * @type {string}
     * @memberof HelpPageResponse
     */
    'notion_parent_id': string;
    /**
     * Page status
     * @type {string}
     * @memberof HelpPageResponse
     */
    'status': HelpPageResponseStatusEnum;
    /**
     * Date last update
     * @type {string}
     * @memberof HelpPageResponse
     */
    'date_update': string;
    /**
     * Date create
     * @type {string}
     * @memberof HelpPageResponse
     */
    'date_create': string;
    /**
     * Page icon
     * @type {object}
     * @memberof HelpPageResponse
     */
    'icon': object | null;
    /**
     * Subject
     * @type {string}
     * @memberof HelpPageResponse
     */
    'title': string;
    /**
     * Language for indexing
     * @type {string}
     * @memberof HelpPageResponse
     */
    'language': HelpPageResponseLanguageEnum;
    /**
     * Language ISO
     * @type {string}
     * @memberof HelpPageResponse
     */
    'language_iso': HelpPageResponseLanguageIsoEnum;
    /**
     * Text
     * @type {string}
     * @memberof HelpPageResponse
     */
    'text': string;
    /**
     * Alternative language (Array of Language ISO)
     * @type {Array<string>}
     * @memberof HelpPageResponse
     */
    'alt_languages': Array<HelpPageResponseAltLanguagesEnum>;
}

export const HelpPageResponseStatusEnum = {
    None: 'None',
    Backlog: 'Backlog',
    Drafting: 'Drafting',
    Reviewing: 'Reviewing',
    Done: 'Done',
    Published: 'Published'
} as const;

export type HelpPageResponseStatusEnum = typeof HelpPageResponseStatusEnum[keyof typeof HelpPageResponseStatusEnum];
export const HelpPageResponseLanguageEnum = {
    Russian: 'russian',
    English: 'english',
    None: 'none'
} as const;

export type HelpPageResponseLanguageEnum = typeof HelpPageResponseLanguageEnum[keyof typeof HelpPageResponseLanguageEnum];
export const HelpPageResponseLanguageIsoEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type HelpPageResponseLanguageIsoEnum = typeof HelpPageResponseLanguageIsoEnum[keyof typeof HelpPageResponseLanguageIsoEnum];
export const HelpPageResponseAltLanguagesEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type HelpPageResponseAltLanguagesEnum = typeof HelpPageResponseAltLanguagesEnum[keyof typeof HelpPageResponseAltLanguagesEnum];

/**
 * 
 * @export
 * @interface InternalNotifyTypeAction
 */
export interface InternalNotifyTypeAction {
    /**
     * Action name
     * @type {string}
     * @memberof InternalNotifyTypeAction
     */
    'name': InternalNotifyTypeActionNameEnum;
    /**
     * Action value
     * @type {string}
     * @memberof InternalNotifyTypeAction
     */
    'value': string;
    /**
     * Type
     * @type {string}
     * @memberof InternalNotifyTypeAction
     */
    'type': InternalNotifyTypeActionTypeEnum;
    /**
     * text
     * @type {Array<InternalNotifyTypeActionText>}
     * @memberof InternalNotifyTypeAction
     */
    'text': Array<InternalNotifyTypeActionText>;
    /**
     * Icon (special symbol)
     * @type {string}
     * @memberof InternalNotifyTypeAction
     */
    'icon': string;
    /**
     * Action group id
     * @type {string}
     * @memberof InternalNotifyTypeAction
     */
    'group_id': string;
    /**
     * Group actions
     * @type {string}
     * @memberof InternalNotifyTypeAction
     */
    'group_type': InternalNotifyTypeActionGroupTypeEnum;
}

export const InternalNotifyTypeActionNameEnum = {
    ExternalLink: 'external_link',
    CabinetLink: 'cabinet_link',
    LandingLink: 'landing_link',
    Link: 'link',
    Accept: 'accept',
    Decline: 'decline',
    Accept1: 'accept_1',
    Accept2: 'accept_2',
    Accept3: 'accept_3'
} as const;

export type InternalNotifyTypeActionNameEnum = typeof InternalNotifyTypeActionNameEnum[keyof typeof InternalNotifyTypeActionNameEnum];
export const InternalNotifyTypeActionTypeEnum = {
    Primary: 'primary',
    Secondary: 'secondary',
    Link: 'link'
} as const;

export type InternalNotifyTypeActionTypeEnum = typeof InternalNotifyTypeActionTypeEnum[keyof typeof InternalNotifyTypeActionTypeEnum];
export const InternalNotifyTypeActionGroupTypeEnum = {
    Toggle: 'toggle',
    Select: 'select',
    Default: 'default'
} as const;

export type InternalNotifyTypeActionGroupTypeEnum = typeof InternalNotifyTypeActionGroupTypeEnum[keyof typeof InternalNotifyTypeActionGroupTypeEnum];

/**
 * 
 * @export
 * @interface InternalNotifyTypeActionText
 */
export interface InternalNotifyTypeActionText {
    /**
     * Language for indexing
     * @type {string}
     * @memberof InternalNotifyTypeActionText
     */
    'language': InternalNotifyTypeActionTextLanguageEnum;
    /**
     * Language ISO
     * @type {string}
     * @memberof InternalNotifyTypeActionText
     */
    'language_iso': InternalNotifyTypeActionTextLanguageIsoEnum;
    /**
     * Title value
     * @type {string}
     * @memberof InternalNotifyTypeActionText
     */
    'title': string;
    /**
     * Title of complited value
     * @type {string}
     * @memberof InternalNotifyTypeActionText
     */
    'complited_title': string;
}

export const InternalNotifyTypeActionTextLanguageEnum = {
    Russian: 'russian',
    English: 'english',
    None: 'none'
} as const;

export type InternalNotifyTypeActionTextLanguageEnum = typeof InternalNotifyTypeActionTextLanguageEnum[keyof typeof InternalNotifyTypeActionTextLanguageEnum];
export const InternalNotifyTypeActionTextLanguageIsoEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type InternalNotifyTypeActionTextLanguageIsoEnum = typeof InternalNotifyTypeActionTextLanguageIsoEnum[keyof typeof InternalNotifyTypeActionTextLanguageIsoEnum];

/**
 * 
 * @export
 * @interface InternalNotifyTypeText
 */
export interface InternalNotifyTypeText {
    /**
     * Language for indexing
     * @type {string}
     * @memberof InternalNotifyTypeText
     */
    'language': InternalNotifyTypeTextLanguageEnum;
    /**
     * Language ISO
     * @type {string}
     * @memberof InternalNotifyTypeText
     */
    'language_iso': InternalNotifyTypeTextLanguageIsoEnum;
    /**
     * Title value
     * @type {string}
     * @memberof InternalNotifyTypeText
     */
    'title': string;
    /**
     * Text value
     * @type {string}
     * @memberof InternalNotifyTypeText
     */
    'text': string;
}

export const InternalNotifyTypeTextLanguageEnum = {
    Russian: 'russian',
    English: 'english',
    None: 'none'
} as const;

export type InternalNotifyTypeTextLanguageEnum = typeof InternalNotifyTypeTextLanguageEnum[keyof typeof InternalNotifyTypeTextLanguageEnum];
export const InternalNotifyTypeTextLanguageIsoEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type InternalNotifyTypeTextLanguageIsoEnum = typeof InternalNotifyTypeTextLanguageIsoEnum[keyof typeof InternalNotifyTypeTextLanguageIsoEnum];

/**
 * 
 * @export
 * @interface ListOfCategoryItemResponse
 */
export interface ListOfCategoryItemResponse {
    /**
     * 
     * @type {Array<CategoryItemResponse>}
     * @memberof ListOfCategoryItemResponse
     */
    'results': Array<CategoryItemResponse>;
}
/**
 * 
 * @export
 * @interface ListOfPaySystemListResponse
 */
export interface ListOfPaySystemListResponse {
    /**
     * 
     * @type {Array<PaySystemListResponse>}
     * @memberof ListOfPaySystemListResponse
     */
    'results': Array<PaySystemListResponse>;
}
/**
 * 
 * @export
 * @interface ListOfPayoutSystemAccountListItemResponse
 */
export interface ListOfPayoutSystemAccountListItemResponse {
    /**
     * 
     * @type {Array<PayoutSystemAccountListItemResponse>}
     * @memberof ListOfPayoutSystemAccountListItemResponse
     */
    'results': Array<PayoutSystemAccountListItemResponse>;
}
/**
 * 
 * @export
 * @interface ListOfPlaylistItemResponse
 */
export interface ListOfPlaylistItemResponse {
    /**
     * 
     * @type {Array<PlaylistItemResponse>}
     * @memberof ListOfPlaylistItemResponse
     */
    'results': Array<PlaylistItemResponse>;
}
/**
 * 
 * @export
 * @interface ListOfProjectChannelInviteResponse
 */
export interface ListOfProjectChannelInviteResponse {
    /**
     * 
     * @type {Array<ProjectChannelInviteResponse>}
     * @memberof ListOfProjectChannelInviteResponse
     */
    'results': Array<ProjectChannelInviteResponse>;
}
/**
 * 
 * @export
 * @interface ListOfProjectChannelResponse
 */
export interface ListOfProjectChannelResponse {
    /**
     * 
     * @type {Array<ProjectChannelResponse>}
     * @memberof ListOfProjectChannelResponse
     */
    'results': Array<ProjectChannelResponse>;
}
/**
 * 
 * @export
 * @interface ListOfRtmpServerLocationResponse
 */
export interface ListOfRtmpServerLocationResponse {
    /**
     * 
     * @type {Array<RtmpServerLocationResponse>}
     * @memberof ListOfRtmpServerLocationResponse
     */
    'results': Array<RtmpServerLocationResponse>;
}
/**
 * 
 * @export
 * @interface ListOfSitePlannedResponse
 */
export interface ListOfSitePlannedResponse {
    /**
     * 
     * @type {Array<SitePlannedResponse>}
     * @memberof ListOfSitePlannedResponse
     */
    'results': Array<SitePlannedResponse>;
}
/**
 * 
 * @export
 * @interface ListOfUserProject2ProjectResponse
 */
export interface ListOfUserProject2ProjectResponse {
    /**
     * 
     * @type {Array<UserProject2ProjectResponse>}
     * @memberof ListOfUserProject2ProjectResponse
     */
    'results': Array<UserProject2ProjectResponse>;
}
/**
 * 
 * @export
 * @interface ListResponse
 */
export interface ListResponse {
    /**
     * Array of items
     * @type {Array<string>}
     * @memberof ListResponse
     */
    'results': Array<string>;
}
/**
 * 
 * @export
 * @interface MessageResponseDto
 */
export interface MessageResponseDto {
    /**
     * 
     * @type {string}
     * @memberof MessageResponseDto
     */
    'event_id': string;
    /**
     * 
     * @type {Array<MessageRestreamResponseDto>}
     * @memberof MessageResponseDto
     */
    'restreams': Array<MessageRestreamResponseDto>;
    /**
     * 
     * @type {Array<object>}
     * @memberof MessageResponseDto
     */
    'entities': Array<object>;
    /**
     * 
     * @type {string}
     * @memberof MessageResponseDto
     */
    'text': string;
    /**
     * 
     * @type {object}
     * @memberof MessageResponseDto
     */
    'sender': object;
    /**
     * 
     * @type {string}
     * @memberof MessageResponseDto
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof MessageResponseDto
     */
    'broadcast_id': number;
    /**
     * 
     * @type {boolean}
     * @memberof MessageResponseDto
     */
    'is_outgoing': boolean;
}
/**
 * 
 * @export
 * @interface MessageRestreamResponseDto
 */
export interface MessageRestreamResponseDto {
    /**
     * 
     * @type {string}
     * @memberof MessageRestreamResponseDto
     */
    'id': string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageRestreamResponseDto
     */
    'event_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof MessageRestreamResponseDto
     */
    'restream_id': number;
    /**
     * 
     * @type {string}
     * @memberof MessageRestreamResponseDto
     */
    'platform': string;
    /**
     * 
     * @type {string}
     * @memberof MessageRestreamResponseDto
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof MessageRestreamResponseDto
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface MethodBroadcastRestreamItemResponse
 */
export interface MethodBroadcastRestreamItemResponse {
    /**
     * Restream Id
     * @type {number}
     * @memberof MethodBroadcastRestreamItemResponse
     */
    'restream_id': number;
    /**
     * Channel Id
     * @type {number}
     * @memberof MethodBroadcastRestreamItemResponse
     */
    'channel_id': number;
    /**
     * Platform name
     * @type {string}
     * @memberof MethodBroadcastRestreamItemResponse
     */
    'name': string;
    /**
     * Platform image
     * @type {string}
     * @memberof MethodBroadcastRestreamItemResponse
     */
    'image': string;
    /**
     * Platform type
     * @type {string}
     * @memberof MethodBroadcastRestreamItemResponse
     */
    'platform': string;
    /**
     * Viewer count
     * @type {number}
     * @memberof MethodBroadcastRestreamItemResponse
     */
    'viewers': number | null;
}
/**
 * 
 * @export
 * @interface MethodBroadcastRestreamsResponse
 */
export interface MethodBroadcastRestreamsResponse {
    /**
     * Array of items
     * @type {Array<MethodBroadcastRestreamItemResponse>}
     * @memberof MethodBroadcastRestreamsResponse
     */
    'results': Array<MethodBroadcastRestreamItemResponse>;
}
/**
 * 
 * @export
 * @interface MethodChatHistoryResponse
 */
export interface MethodChatHistoryResponse {
    /**
     * 
     * @type {number}
     * @memberof MethodChatHistoryResponse
     */
    'total': number;
    /**
     * 
     * @type {Array<MessageResponseDto>}
     * @memberof MethodChatHistoryResponse
     */
    'items': Array<MessageResponseDto>;
}
/**
 * 
 * @export
 * @interface MethodChatSendMessageRequestDto
 */
export interface MethodChatSendMessageRequestDto {
    /**
     * 
     * @type {string}
     * @memberof MethodChatSendMessageRequestDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MethodChatSendMessageRequestDto
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface MethodCurrentBroadcastResponse
 */
export interface MethodCurrentBroadcastResponse {
    /**
     * Access token
     * @type {string}
     * @memberof MethodCurrentBroadcastResponse
     */
    'access_token': string;
    /**
     * Broadcast Id
     * @type {number}
     * @memberof MethodCurrentBroadcastResponse
     */
    'broadcast_id': number;
}
/**
 * 
 * @export
 * @interface MethodProjectLiveStatusInfo
 */
export interface MethodProjectLiveStatusInfo {
    /**
     * Restream data
     * @type {Array<MethodProjectLiveStatusInfoRestreamData>}
     * @memberof MethodProjectLiveStatusInfo
     */
    'restream_data'?: Array<MethodProjectLiveStatusInfoRestreamData>;
    /**
     * 
     * @type {number}
     * @memberof MethodProjectLiveStatusInfo
     */
    'connect_id': number;
    /**
     * 
     * @type {string}
     * @memberof MethodProjectLiveStatusInfo
     */
    'connect_id_v2': string;
    /**
     * 
     * @type {number}
     * @memberof MethodProjectLiveStatusInfo
     */
    'fps': number;
    /**
     * 
     * @type {number}
     * @memberof MethodProjectLiveStatusInfo
     */
    'key_frame': number;
    /**
     * 
     * @type {number}
     * @memberof MethodProjectLiveStatusInfo
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof MethodProjectLiveStatusInfo
     */
    'speed': number;
    /**
     * 
     * @type {number}
     * @memberof MethodProjectLiveStatusInfo
     */
    'quality': number;
    /**
     * 
     * @type {number}
     * @memberof MethodProjectLiveStatusInfo
     */
    'bitrate': number;
    /**
     * 
     * @type {number}
     * @memberof MethodProjectLiveStatusInfo
     */
    'full_bitrate': number;
    /**
     * 
     * @type {string}
     * @memberof MethodProjectLiveStatusInfo
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof MethodProjectLiveStatusInfo
     */
    'restrims': number;
}
/**
 * 
 * @export
 * @interface MethodProjectLiveStatusInfoRestreamData
 */
export interface MethodProjectLiveStatusInfoRestreamData {
    /**
     * 
     * @type {number}
     * @memberof MethodProjectLiveStatusInfoRestreamData
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof MethodProjectLiveStatusInfoRestreamData
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface MethodProjectLiveStatusResponse
 */
export interface MethodProjectLiveStatusResponse {
    /**
     * Live group count
     * @type {number}
     * @memberof MethodProjectLiveStatusResponse
     */
    'live_groups_count': number;
    /**
     * Stream id
     * @type {number}
     * @memberof MethodProjectLiveStatusResponse
     */
    'stream_id'?: number;
    /**
     * Url live stream
     * @type {string}
     * @memberof MethodProjectLiveStatusResponse
     */
    'url'?: string;
    /**
     * App name
     * @type {string}
     * @memberof MethodProjectLiveStatusResponse
     */
    'app'?: string;
    /**
     * Date
     * @type {string}
     * @memberof MethodProjectLiveStatusResponse
     */
    'date'?: string;
    /**
     * Stream status
     * @type {string}
     * @memberof MethodProjectLiveStatusResponse
     */
    'status'?: string;
    /**
     * Stream resolution
     * @type {string}
     * @memberof MethodProjectLiveStatusResponse
     */
    'resolution'?: string;
    /**
     * Broadcast id
     * @type {number}
     * @memberof MethodProjectLiveStatusResponse
     */
    'broadcast_id'?: number;
    /**
     * Action
     * @type {string}
     * @memberof MethodProjectLiveStatusResponse
     */
    'action'?: string;
    /**
     * Stream info
     * @type {MethodProjectLiveStatusInfo}
     * @memberof MethodProjectLiveStatusResponse
     */
    'info'?: MethodProjectLiveStatusInfo;
    /**
     * Video info
     * @type {MethodProjectLiveStatusVideo}
     * @memberof MethodProjectLiveStatusResponse
     */
    'video'?: MethodProjectLiveStatusVideo;
}
/**
 * 
 * @export
 * @interface MethodProjectLiveStatusVideo
 */
export interface MethodProjectLiveStatusVideo {
    /**
     * 
     * @type {number}
     * @memberof MethodProjectLiveStatusVideo
     */
    'task_id': number;
    /**
     * 
     * @type {number}
     * @memberof MethodProjectLiveStatusVideo
     */
    'video_id': number;
    /**
     * 
     * @type {string}
     * @memberof MethodProjectLiveStatusVideo
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof MethodProjectLiveStatusVideo
     */
    'duration': number;
}
/**
 * 
 * @export
 * @interface MethodSetStatusChannelRequest
 */
export interface MethodSetStatusChannelRequest {
    /**
     * Version
     * @type {string}
     * @memberof MethodSetStatusChannelRequest
     */
    'v': MethodSetStatusChannelRequestVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof MethodSetStatusChannelRequest
     */
    'language'?: MethodSetStatusChannelRequestLanguageEnum;
    /**
     * Channel id
     * @type {number}
     * @memberof MethodSetStatusChannelRequest
     */
    'channel_id': number;
    /**
     * Status channel status
     * @type {boolean}
     * @memberof MethodSetStatusChannelRequest
     */
    'status': boolean;
}

export const MethodSetStatusChannelRequestVEnum = {
    _1: '1'
} as const;

export type MethodSetStatusChannelRequestVEnum = typeof MethodSetStatusChannelRequestVEnum[keyof typeof MethodSetStatusChannelRequestVEnum];
export const MethodSetStatusChannelRequestLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type MethodSetStatusChannelRequestLanguageEnum = typeof MethodSetStatusChannelRequestLanguageEnum[keyof typeof MethodSetStatusChannelRequestLanguageEnum];

/**
 * 
 * @export
 * @interface MoneyFlowBalanceTypeValuesResponse
 */
export interface MoneyFlowBalanceTypeValuesResponse {
    /**
     * Bonus balance
     * @type {number}
     * @memberof MoneyFlowBalanceTypeValuesResponse
     */
    'bonus': number;
    /**
     * Payment balance
     * @type {number}
     * @memberof MoneyFlowBalanceTypeValuesResponse
     */
    'payment': number;
    /**
     * Profit balance
     * @type {number}
     * @memberof MoneyFlowBalanceTypeValuesResponse
     */
    'profit': number;
}
/**
 * 
 * @export
 * @interface MoneyFlowDetails
 */
export interface MoneyFlowDetails {
    /**
     * Title
     * @type {string}
     * @memberof MoneyFlowDetails
     */
    'title': string;
    /**
     * Date
     * @type {string}
     * @memberof MoneyFlowDetails
     */
    'date_end': string;
}
/**
 * 
 * @export
 * @interface MoneyFlowResponse
 */
export interface MoneyFlowResponse {
    /**
     * id
     * @type {number}
     * @memberof MoneyFlowResponse
     */
    'money_flow_id': number;
    /**
     * Amount
     * @type {number}
     * @memberof MoneyFlowResponse
     */
    'amount': number;
    /**
     * Currency
     * @type {string}
     * @memberof MoneyFlowResponse
     */
    'currency': MoneyFlowResponseCurrencyEnum | null;
    /**
     * Date
     * @type {string}
     * @memberof MoneyFlowResponse
     */
    'date': string;
    /**
     * Type
     * @type {string}
     * @memberof MoneyFlowResponse
     */
    'type': MoneyFlowResponseTypeEnum;
    /**
     * Current balance before transaction
     * @type {number}
     * @memberof MoneyFlowResponse
     */
    'balance': number;
    /**
     * Details
     * @type {MoneyFlowDetails}
     * @memberof MoneyFlowResponse
     */
    'details': MoneyFlowDetails | null;
}

export const MoneyFlowResponseCurrencyEnum = {
    Rub: 'rub',
    Usd: 'usd'
} as const;

export type MoneyFlowResponseCurrencyEnum = typeof MoneyFlowResponseCurrencyEnum[keyof typeof MoneyFlowResponseCurrencyEnum];
export const MoneyFlowResponseTypeEnum = {
    RegistrationBonus: 'registration_bonus',
    PlanRestreamBuy: 'plan_restream_buy',
    PlanTranscodingBuy: 'plan_transcoding_buy',
    PlanStorageBuy: 'plan_storage_buy',
    ChannelStoryBuy: 'channel_story_buy',
    ChannelShopSell: 'channel_shop_sell',
    ReferralProfit: 'referral_profit',
    Payment: 'payment',
    PaymentCancel: 'payment_cancel',
    Payout: 'payout',
    PayoutCancel: 'payout_cancel',
    Refund: 'refund',
    Conversion: 'conversion',
    Withdrawal: 'withdrawal',
    TransferredOfOldSite: 'transferred_of_old_site',
    AccruedAdmin: 'accrued_admin',
    ReducedAdmin: 'reduced_admin',
    PromoTopup1: 'promo_topup_1',
    PromoTopup2: 'promo_topup_2',
    PromoCreatePlanRestream1: 'promo_create_plan_restream_1',
    PromoCreatePlanRestream2: 'promo_create_plan_restream_2'
} as const;

export type MoneyFlowResponseTypeEnum = typeof MoneyFlowResponseTypeEnum[keyof typeof MoneyFlowResponseTypeEnum];

/**
 * 
 * @export
 * @interface NotifyHistorySiteResponse
 */
export interface NotifyHistorySiteResponse {
    /**
     * Id of page in mongodb
     * @type {string}
     * @memberof NotifyHistorySiteResponse
     */
    'id': string;
    /**
     * Project id
     * @type {number}
     * @memberof NotifyHistorySiteResponse
     */
    'project_id': number;
    /**
     * Date create
     * @type {string}
     * @memberof NotifyHistorySiteResponse
     */
    'date_create': string;
    /**
     * Actions
     * @type {object}
     * @memberof NotifyHistorySiteResponse
     */
    'actions': object;
    /**
     * Channel
     * @type {string}
     * @memberof NotifyHistorySiteResponse
     */
    'channel': NotifyHistorySiteResponseChannelEnum;
    /**
     * Array of texts
     * @type {Array<InternalNotifyTypeText>}
     * @memberof NotifyHistorySiteResponse
     */
    'text': Array<InternalNotifyTypeText>;
    /**
     * Status read
     * @type {boolean}
     * @memberof NotifyHistorySiteResponse
     */
    'status_read': boolean;
    /**
     * Category of user notify
     * @type {string}
     * @memberof NotifyHistorySiteResponse
     */
    'category': NotifyHistorySiteResponseCategoryEnum;
}

export const NotifyHistorySiteResponseChannelEnum = {
    Telegram: 'telegram',
    Cabinet: 'cabinet',
    Mobile: 'mobile'
} as const;

export type NotifyHistorySiteResponseChannelEnum = typeof NotifyHistorySiteResponseChannelEnum[keyof typeof NotifyHistorySiteResponseChannelEnum];
export const NotifyHistorySiteResponseCategoryEnum = {
    Important: 'important',
    Stream: 'stream'
} as const;

export type NotifyHistorySiteResponseCategoryEnum = typeof NotifyHistorySiteResponseCategoryEnum[keyof typeof NotifyHistorySiteResponseCategoryEnum];

/**
 * 
 * @export
 * @interface NotifyHistoryStatusUserResponse
 */
export interface NotifyHistoryStatusUserResponse {
    /**
     * Count unread
     * @type {number}
     * @memberof NotifyHistoryStatusUserResponse
     */
    'count_unread': number;
}
/**
 * 
 * @export
 * @interface NotifyUserChannels
 */
export interface NotifyUserChannels {
    /**
     * Active cabinet
     * @type {boolean}
     * @memberof NotifyUserChannels
     */
    'cabinet': boolean;
    /**
     * Active telegram
     * @type {boolean}
     * @memberof NotifyUserChannels
     */
    'telegram': boolean;
    /**
     * Active mobile
     * @type {boolean}
     * @memberof NotifyUserChannels
     */
    'mobile': boolean;
}
/**
 * 
 * @export
 * @interface NotifyUserRelation
 */
export interface NotifyUserRelation {
    /**
     * Category of user notify in cabinet
     * @type {Array<string>}
     * @memberof NotifyUserRelation
     */
    'cabinet': Array<NotifyUserRelationCabinetEnum>;
    /**
     * Category of user notify in telegram
     * @type {Array<string>}
     * @memberof NotifyUserRelation
     */
    'telegram': Array<NotifyUserRelationTelegramEnum>;
    /**
     * Category of user notify in mobile
     * @type {Array<string>}
     * @memberof NotifyUserRelation
     */
    'mobile': Array<NotifyUserRelationMobileEnum>;
    /**
     * Project
     * @type {number}
     * @memberof NotifyUserRelation
     */
    'project_id': number;
}

export const NotifyUserRelationCabinetEnum = {
    Important: 'important',
    Stream: 'stream'
} as const;

export type NotifyUserRelationCabinetEnum = typeof NotifyUserRelationCabinetEnum[keyof typeof NotifyUserRelationCabinetEnum];
export const NotifyUserRelationTelegramEnum = {
    Important: 'important',
    Stream: 'stream'
} as const;

export type NotifyUserRelationTelegramEnum = typeof NotifyUserRelationTelegramEnum[keyof typeof NotifyUserRelationTelegramEnum];
export const NotifyUserRelationMobileEnum = {
    Important: 'important',
    Stream: 'stream'
} as const;

export type NotifyUserRelationMobileEnum = typeof NotifyUserRelationMobileEnum[keyof typeof NotifyUserRelationMobileEnum];

/**
 * 
 * @export
 * @interface PaginatedResponse
 */
export interface PaginatedResponse {
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponse
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponse
     */
    'offset': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof PaginatedResponse
     */
    'results': Array<string>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseOfBlogPageSiteResponse
 */
export interface PaginatedResponseOfBlogPageSiteResponse {
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfBlogPageSiteResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfBlogPageSiteResponse
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfBlogPageSiteResponse
     */
    'offset': number;
    /**
     * 
     * @type {Array<BlogPageSiteResponse>}
     * @memberof PaginatedResponseOfBlogPageSiteResponse
     */
    'results': Array<BlogPageSiteResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseOfHelpPageResponse
 */
export interface PaginatedResponseOfHelpPageResponse {
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfHelpPageResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfHelpPageResponse
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfHelpPageResponse
     */
    'offset': number;
    /**
     * 
     * @type {Array<HelpPageResponse>}
     * @memberof PaginatedResponseOfHelpPageResponse
     */
    'results': Array<HelpPageResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseOfMoneyFlowResponse
 */
export interface PaginatedResponseOfMoneyFlowResponse {
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfMoneyFlowResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfMoneyFlowResponse
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfMoneyFlowResponse
     */
    'offset': number;
    /**
     * 
     * @type {Array<MoneyFlowResponse>}
     * @memberof PaginatedResponseOfMoneyFlowResponse
     */
    'results': Array<MoneyFlowResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseOfNotifyHistorySiteResponse
 */
export interface PaginatedResponseOfNotifyHistorySiteResponse {
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfNotifyHistorySiteResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfNotifyHistorySiteResponse
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfNotifyHistorySiteResponse
     */
    'offset': number;
    /**
     * 
     * @type {Array<NotifyHistorySiteResponse>}
     * @memberof PaginatedResponseOfNotifyHistorySiteResponse
     */
    'results': Array<NotifyHistorySiteResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseOfProjectHistoryResponse
 */
export interface PaginatedResponseOfProjectHistoryResponse {
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfProjectHistoryResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfProjectHistoryResponse
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfProjectHistoryResponse
     */
    'offset': number;
    /**
     * 
     * @type {Array<ProjectHistoryResponse>}
     * @memberof PaginatedResponseOfProjectHistoryResponse
     */
    'results': Array<ProjectHistoryResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseOfSiteBlogPageTagResponse
 */
export interface PaginatedResponseOfSiteBlogPageTagResponse {
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfSiteBlogPageTagResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfSiteBlogPageTagResponse
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfSiteBlogPageTagResponse
     */
    'offset': number;
    /**
     * 
     * @type {Array<SiteBlogPageTagResponse>}
     * @memberof PaginatedResponseOfSiteBlogPageTagResponse
     */
    'results': Array<SiteBlogPageTagResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseOfTransactionResponse
 */
export interface PaginatedResponseOfTransactionResponse {
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfTransactionResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfTransactionResponse
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfTransactionResponse
     */
    'offset': number;
    /**
     * 
     * @type {Array<TransactionResponse>}
     * @memberof PaginatedResponseOfTransactionResponse
     */
    'results': Array<TransactionResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseOfUserProjectResponse
 */
export interface PaginatedResponseOfUserProjectResponse {
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfUserProjectResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfUserProjectResponse
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfUserProjectResponse
     */
    'offset': number;
    /**
     * 
     * @type {Array<UserProjectResponse>}
     * @memberof PaginatedResponseOfUserProjectResponse
     */
    'results': Array<UserProjectResponse>;
}
/**
 * 
 * @export
 * @interface PayCheckCountryResponse
 */
export interface PayCheckCountryResponse {
    /**
     * Is show modal confirmation
     * @type {boolean}
     * @memberof PayCheckCountryResponse
     */
    'confirm': boolean;
    /**
     * Exchange rate
     * @type {number}
     * @memberof PayCheckCountryResponse
     */
    'exchange': number;
    /**
     * Currency
     * @type {string}
     * @memberof PayCheckCountryResponse
     */
    'currency': PayCheckCountryResponseCurrencyEnum;
    /**
     * Country
     * @type {object}
     * @memberof PayCheckCountryResponse
     */
    'country': object;
    /**
     * Balance
     * @type {object}
     * @memberof PayCheckCountryResponse
     */
    'balance': object;
}

export const PayCheckCountryResponseCurrencyEnum = {
    Rub: 'rub',
    Usd: 'usd'
} as const;

export type PayCheckCountryResponseCurrencyEnum = typeof PayCheckCountryResponseCurrencyEnum[keyof typeof PayCheckCountryResponseCurrencyEnum];

/**
 * 
 * @export
 * @interface PaySettingBodyDto
 */
export interface PaySettingBodyDto {
    /**
     * Version
     * @type {string}
     * @memberof PaySettingBodyDto
     */
    'v': PaySettingBodyDtoVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof PaySettingBodyDto
     */
    'language': PaySettingBodyDtoLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof PaySettingBodyDto
     */
    'project_id': number;
    /**
     * Countrie id
     * @type {number}
     * @memberof PaySettingBodyDto
     */
    'countrie_id': number;
    /**
     * Organization
     * @type {number}
     * @memberof PaySettingBodyDto
     */
    'organization_id'?: number | null;
    /**
     * Pay system id
     * @type {number}
     * @memberof PaySettingBodyDto
     */
    'pay_system_id': number;
    /**
     * E-mail
     * @type {string}
     * @memberof PaySettingBodyDto
     */
    'email': string;
    /**
     * Additional information about the payment
     * @type {string}
     * @memberof PaySettingBodyDto
     */
    'description'?: string | null;
}

export const PaySettingBodyDtoVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type PaySettingBodyDtoVEnum = typeof PaySettingBodyDtoVEnum[keyof typeof PaySettingBodyDtoVEnum];
export const PaySettingBodyDtoLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type PaySettingBodyDtoLanguageEnum = typeof PaySettingBodyDtoLanguageEnum[keyof typeof PaySettingBodyDtoLanguageEnum];

/**
 * 
 * @export
 * @interface PaySettingResponseV3
 */
export interface PaySettingResponseV3 {
    /**
     * Project id
     * @type {number}
     * @memberof PaySettingResponseV3
     */
    'project_id': number;
    /**
     * Currency
     * @type {string}
     * @memberof PaySettingResponseV3
     */
    'currency': PaySettingResponseV3CurrencyEnum;
    /**
     * Country
     * @type {number}
     * @memberof PaySettingResponseV3
     */
    'countrie_id': number;
    /**
     * Organiztion
     * @type {number}
     * @memberof PaySettingResponseV3
     */
    'organization_id': number | null;
    /**
     * Pay system id
     * @type {number}
     * @memberof PaySettingResponseV3
     */
    'pay_system_id': number;
    /**
     * E-mail
     * @type {string}
     * @memberof PaySettingResponseV3
     */
    'email': string;
    /**
     * Street
     * @type {string}
     * @memberof PaySettingResponseV3
     */
    'street'?: string | null;
    /**
     * House number
     * @type {string}
     * @memberof PaySettingResponseV3
     */
    'house_number'?: string | null;
    /**
     * Postal code
     * @type {string}
     * @memberof PaySettingResponseV3
     */
    'zip'?: string | null;
    /**
     * City
     * @type {string}
     * @memberof PaySettingResponseV3
     */
    'city'?: string | null;
    /**
     * State ot region
     * @type {string}
     * @memberof PaySettingResponseV3
     */
    'state'?: string | null;
    /**
     * Company name
     * @type {string}
     * @memberof PaySettingResponseV3
     */
    'company_name'?: string | null;
    /**
     * Additional information about the payment
     * @type {string}
     * @memberof PaySettingResponseV3
     */
    'description'?: string | null;
}

export const PaySettingResponseV3CurrencyEnum = {
    Rub: 'rub',
    Usd: 'usd'
} as const;

export type PaySettingResponseV3CurrencyEnum = typeof PaySettingResponseV3CurrencyEnum[keyof typeof PaySettingResponseV3CurrencyEnum];

/**
 * 
 * @export
 * @interface PaySystemListResponse
 */
export interface PaySystemListResponse {
    /**
     * Id
     * @type {number}
     * @memberof PaySystemListResponse
     */
    'pay_system_id': number;
    /**
     * Name
     * @type {string}
     * @memberof PaySystemListResponse
     */
    'name': string;
    /**
     * Min amount
     * @type {number}
     * @memberof PaySystemListResponse
     */
    'min_amount': number;
    /**
     * Max amount
     * @type {number}
     * @memberof PaySystemListResponse
     */
    'max_amount': number;
    /**
     * Currency
     * @type {string}
     * @memberof PaySystemListResponse
     */
    'currency': PaySystemListResponseCurrencyEnum;
    /**
     * The possibility of annual replenishment
     * @type {number}
     * @memberof PaySystemListResponse
     */
    'annual': number;
    /**
     * The ability to replenish the balance
     * @type {number}
     * @memberof PaySystemListResponse
     */
    'topup': number;
    /**
     * The possibility of recurrent payment
     * @type {number}
     * @memberof PaySystemListResponse
     */
    'recurrent': number;
    /**
     * Description
     * @type {string}
     * @memberof PaySystemListResponse
     */
    'description': string;
}

export const PaySystemListResponseCurrencyEnum = {
    Rub: 'rub',
    Usd: 'usd'
} as const;

export type PaySystemListResponseCurrencyEnum = typeof PaySystemListResponseCurrencyEnum[keyof typeof PaySystemListResponseCurrencyEnum];

/**
 * @type PaymentControllerCreate1Request
 * @export
 */
export type PaymentControllerCreate1Request = PaymentCreateRequestRestreamBodyDto | PaymentCreateRequestStorageBodyDto | PaymentCreateRequestTopUpBodyDto | PaymentCreateRequestTranscoderBodyDto;

/**
 * 
 * @export
 * @interface PaymentCreateRequestRestreamBodyDto
 */
export interface PaymentCreateRequestRestreamBodyDto {
    /**
     * Version
     * @type {string}
     * @memberof PaymentCreateRequestRestreamBodyDto
     */
    'v': PaymentCreateRequestRestreamBodyDtoVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof PaymentCreateRequestRestreamBodyDto
     */
    'language': PaymentCreateRequestRestreamBodyDtoLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof PaymentCreateRequestRestreamBodyDto
     */
    'project_id': number;
    /**
     * Code
     * @type {string}
     * @memberof PaymentCreateRequestRestreamBodyDto
     */
    'type': PaymentCreateRequestRestreamBodyDtoTypeEnum;
    /**
     * Amount
     * @type {number}
     * @memberof PaymentCreateRequestRestreamBodyDto
     */
    'amount': number;
    /**
     * Period
     * @type {string}
     * @memberof PaymentCreateRequestRestreamBodyDto
     */
    'plan_period': PaymentCreateRequestRestreamBodyDtoPlanPeriodEnum;
    /**
     * Restream plan id
     * @type {number}
     * @memberof PaymentCreateRequestRestreamBodyDto
     */
    'plan_restream_id': number;
    /**
     * Channels count
     * @type {number}
     * @memberof PaymentCreateRequestRestreamBodyDto
     */
    'plan_restream_count_channel': number;
    /**
     * Bitrate
     * @type {number}
     * @memberof PaymentCreateRequestRestreamBodyDto
     */
    'plan_restream_bitrate': number;
}

export const PaymentCreateRequestRestreamBodyDtoVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type PaymentCreateRequestRestreamBodyDtoVEnum = typeof PaymentCreateRequestRestreamBodyDtoVEnum[keyof typeof PaymentCreateRequestRestreamBodyDtoVEnum];
export const PaymentCreateRequestRestreamBodyDtoLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type PaymentCreateRequestRestreamBodyDtoLanguageEnum = typeof PaymentCreateRequestRestreamBodyDtoLanguageEnum[keyof typeof PaymentCreateRequestRestreamBodyDtoLanguageEnum];
export const PaymentCreateRequestRestreamBodyDtoTypeEnum = {
    Restream: 'restream',
    Transcoding: 'transcoding',
    Storage: 'storage',
    Topup: 'topup'
} as const;

export type PaymentCreateRequestRestreamBodyDtoTypeEnum = typeof PaymentCreateRequestRestreamBodyDtoTypeEnum[keyof typeof PaymentCreateRequestRestreamBodyDtoTypeEnum];
export const PaymentCreateRequestRestreamBodyDtoPlanPeriodEnum = {
    Month: 'month',
    Year: 'year'
} as const;

export type PaymentCreateRequestRestreamBodyDtoPlanPeriodEnum = typeof PaymentCreateRequestRestreamBodyDtoPlanPeriodEnum[keyof typeof PaymentCreateRequestRestreamBodyDtoPlanPeriodEnum];

/**
 * 
 * @export
 * @interface PaymentCreateRequestStorageBodyDto
 */
export interface PaymentCreateRequestStorageBodyDto {
    /**
     * Version
     * @type {string}
     * @memberof PaymentCreateRequestStorageBodyDto
     */
    'v': PaymentCreateRequestStorageBodyDtoVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof PaymentCreateRequestStorageBodyDto
     */
    'language': PaymentCreateRequestStorageBodyDtoLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof PaymentCreateRequestStorageBodyDto
     */
    'project_id': number;
    /**
     * Code
     * @type {string}
     * @memberof PaymentCreateRequestStorageBodyDto
     */
    'type': PaymentCreateRequestStorageBodyDtoTypeEnum;
    /**
     * Amount
     * @type {number}
     * @memberof PaymentCreateRequestStorageBodyDto
     */
    'amount': number;
    /**
     * Period
     * @type {string}
     * @memberof PaymentCreateRequestStorageBodyDto
     */
    'plan_period': PaymentCreateRequestStorageBodyDtoPlanPeriodEnum;
    /**
     * Storage plan id
     * @type {number}
     * @memberof PaymentCreateRequestStorageBodyDto
     */
    'plan_storage_id': number;
    /**
     * Space GB
     * @type {number}
     * @memberof PaymentCreateRequestStorageBodyDto
     */
    'plan_storage_value': number;
}

export const PaymentCreateRequestStorageBodyDtoVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type PaymentCreateRequestStorageBodyDtoVEnum = typeof PaymentCreateRequestStorageBodyDtoVEnum[keyof typeof PaymentCreateRequestStorageBodyDtoVEnum];
export const PaymentCreateRequestStorageBodyDtoLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type PaymentCreateRequestStorageBodyDtoLanguageEnum = typeof PaymentCreateRequestStorageBodyDtoLanguageEnum[keyof typeof PaymentCreateRequestStorageBodyDtoLanguageEnum];
export const PaymentCreateRequestStorageBodyDtoTypeEnum = {
    Restream: 'restream',
    Transcoding: 'transcoding',
    Storage: 'storage',
    Topup: 'topup'
} as const;

export type PaymentCreateRequestStorageBodyDtoTypeEnum = typeof PaymentCreateRequestStorageBodyDtoTypeEnum[keyof typeof PaymentCreateRequestStorageBodyDtoTypeEnum];
export const PaymentCreateRequestStorageBodyDtoPlanPeriodEnum = {
    Month: 'month',
    Year: 'year'
} as const;

export type PaymentCreateRequestStorageBodyDtoPlanPeriodEnum = typeof PaymentCreateRequestStorageBodyDtoPlanPeriodEnum[keyof typeof PaymentCreateRequestStorageBodyDtoPlanPeriodEnum];

/**
 * 
 * @export
 * @interface PaymentCreateRequestTopUpBodyDto
 */
export interface PaymentCreateRequestTopUpBodyDto {
    /**
     * Version
     * @type {string}
     * @memberof PaymentCreateRequestTopUpBodyDto
     */
    'v': PaymentCreateRequestTopUpBodyDtoVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof PaymentCreateRequestTopUpBodyDto
     */
    'language': PaymentCreateRequestTopUpBodyDtoLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof PaymentCreateRequestTopUpBodyDto
     */
    'project_id': number;
    /**
     * Code
     * @type {string}
     * @memberof PaymentCreateRequestTopUpBodyDto
     */
    'type': PaymentCreateRequestTopUpBodyDtoTypeEnum;
    /**
     * Amount
     * @type {number}
     * @memberof PaymentCreateRequestTopUpBodyDto
     */
    'amount': number;
}

export const PaymentCreateRequestTopUpBodyDtoVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type PaymentCreateRequestTopUpBodyDtoVEnum = typeof PaymentCreateRequestTopUpBodyDtoVEnum[keyof typeof PaymentCreateRequestTopUpBodyDtoVEnum];
export const PaymentCreateRequestTopUpBodyDtoLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type PaymentCreateRequestTopUpBodyDtoLanguageEnum = typeof PaymentCreateRequestTopUpBodyDtoLanguageEnum[keyof typeof PaymentCreateRequestTopUpBodyDtoLanguageEnum];
export const PaymentCreateRequestTopUpBodyDtoTypeEnum = {
    Restream: 'restream',
    Transcoding: 'transcoding',
    Storage: 'storage',
    Topup: 'topup'
} as const;

export type PaymentCreateRequestTopUpBodyDtoTypeEnum = typeof PaymentCreateRequestTopUpBodyDtoTypeEnum[keyof typeof PaymentCreateRequestTopUpBodyDtoTypeEnum];

/**
 * 
 * @export
 * @interface PaymentCreateRequestTranscoderBodyDto
 */
export interface PaymentCreateRequestTranscoderBodyDto {
    /**
     * Version
     * @type {string}
     * @memberof PaymentCreateRequestTranscoderBodyDto
     */
    'v': PaymentCreateRequestTranscoderBodyDtoVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof PaymentCreateRequestTranscoderBodyDto
     */
    'language': PaymentCreateRequestTranscoderBodyDtoLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof PaymentCreateRequestTranscoderBodyDto
     */
    'project_id': number;
    /**
     * Code
     * @type {string}
     * @memberof PaymentCreateRequestTranscoderBodyDto
     */
    'type': PaymentCreateRequestTranscoderBodyDtoTypeEnum;
    /**
     * Amount
     * @type {number}
     * @memberof PaymentCreateRequestTranscoderBodyDto
     */
    'amount': number;
    /**
     * Period
     * @type {string}
     * @memberof PaymentCreateRequestTranscoderBodyDto
     */
    'plan_period': PaymentCreateRequestTranscoderBodyDtoPlanPeriodEnum;
    /**
     * Transcoding plan id
     * @type {number}
     * @memberof PaymentCreateRequestTranscoderBodyDto
     */
    'plan_transcoding_id': number;
    /**
     * Count flow
     * @type {number}
     * @memberof PaymentCreateRequestTranscoderBodyDto
     */
    'plan_transcoding_count_flow': number;
}

export const PaymentCreateRequestTranscoderBodyDtoVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type PaymentCreateRequestTranscoderBodyDtoVEnum = typeof PaymentCreateRequestTranscoderBodyDtoVEnum[keyof typeof PaymentCreateRequestTranscoderBodyDtoVEnum];
export const PaymentCreateRequestTranscoderBodyDtoLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type PaymentCreateRequestTranscoderBodyDtoLanguageEnum = typeof PaymentCreateRequestTranscoderBodyDtoLanguageEnum[keyof typeof PaymentCreateRequestTranscoderBodyDtoLanguageEnum];
export const PaymentCreateRequestTranscoderBodyDtoTypeEnum = {
    Restream: 'restream',
    Transcoding: 'transcoding',
    Storage: 'storage',
    Topup: 'topup'
} as const;

export type PaymentCreateRequestTranscoderBodyDtoTypeEnum = typeof PaymentCreateRequestTranscoderBodyDtoTypeEnum[keyof typeof PaymentCreateRequestTranscoderBodyDtoTypeEnum];
export const PaymentCreateRequestTranscoderBodyDtoPlanPeriodEnum = {
    Month: 'month',
    Year: 'year'
} as const;

export type PaymentCreateRequestTranscoderBodyDtoPlanPeriodEnum = typeof PaymentCreateRequestTranscoderBodyDtoPlanPeriodEnum[keyof typeof PaymentCreateRequestTranscoderBodyDtoPlanPeriodEnum];

/**
 * 
 * @export
 * @interface PaymentCreateResponse
 */
export interface PaymentCreateResponse {
    /**
     * Payment Id
     * @type {number}
     * @memberof PaymentCreateResponse
     */
    'payment_id': number;
    /**
     * Pay system name
     * @type {string}
     * @memberof PaymentCreateResponse
     */
    'pay_name': string;
    /**
     * Pay system id
     * @type {string}
     * @memberof PaymentCreateResponse
     */
    'pay_id'?: string;
    /**
     * Pay system key
     * @type {string}
     * @memberof PaymentCreateResponse
     */
    'pay_key'?: string;
}
/**
 * 
 * @export
 * @interface PaymentStatusResponse
 */
export interface PaymentStatusResponse {
    /**
     * Payment Id
     * @type {number}
     * @memberof PaymentStatusResponse
     */
    'payment_id': number;
    /**
     * Amount
     * @type {number}
     * @memberof PaymentStatusResponse
     */
    'amount': number;
    /**
     * Currency
     * @type {string}
     * @memberof PaymentStatusResponse
     */
    'currency': PaymentStatusResponseCurrencyEnum;
    /**
     * Period
     * @type {string}
     * @memberof PaymentStatusResponse
     */
    'plan_period': PaymentStatusResponsePlanPeriodEnum;
    /**
     * Status
     * @type {string}
     * @memberof PaymentStatusResponse
     */
    'status': string;
    /**
     * Tariff type
     * @type {string}
     * @memberof PaymentStatusResponse
     */
    'type': string;
    /**
     * Tariff title
     * @type {string}
     * @memberof PaymentStatusResponse
     */
    'title'?: string;
}

export const PaymentStatusResponseCurrencyEnum = {
    Rub: 'rub',
    Usd: 'usd'
} as const;

export type PaymentStatusResponseCurrencyEnum = typeof PaymentStatusResponseCurrencyEnum[keyof typeof PaymentStatusResponseCurrencyEnum];
export const PaymentStatusResponsePlanPeriodEnum = {
    Month: 'month',
    Year: 'year'
} as const;

export type PaymentStatusResponsePlanPeriodEnum = typeof PaymentStatusResponsePlanPeriodEnum[keyof typeof PaymentStatusResponsePlanPeriodEnum];

/**
 * 
 * @export
 * @interface PayoutCreateRequestBodyDto
 */
export interface PayoutCreateRequestBodyDto {
    /**
     * Version
     * @type {string}
     * @memberof PayoutCreateRequestBodyDto
     */
    'v': PayoutCreateRequestBodyDtoVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof PayoutCreateRequestBodyDto
     */
    'language': PayoutCreateRequestBodyDtoLanguageEnum;
    /**
     * Payout system account
     * @type {number}
     * @memberof PayoutCreateRequestBodyDto
     */
    'payout_system_account_id': number;
    /**
     * Project id
     * @type {number}
     * @memberof PayoutCreateRequestBodyDto
     */
    'project_id': number;
    /**
     * Amount
     * @type {number}
     * @memberof PayoutCreateRequestBodyDto
     */
    'amount': number;
    /**
     * Wallet value
     * @type {string}
     * @memberof PayoutCreateRequestBodyDto
     */
    'wallet_value': string;
}

export const PayoutCreateRequestBodyDtoVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type PayoutCreateRequestBodyDtoVEnum = typeof PayoutCreateRequestBodyDtoVEnum[keyof typeof PayoutCreateRequestBodyDtoVEnum];
export const PayoutCreateRequestBodyDtoLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type PayoutCreateRequestBodyDtoLanguageEnum = typeof PayoutCreateRequestBodyDtoLanguageEnum[keyof typeof PayoutCreateRequestBodyDtoLanguageEnum];

/**
 * 
 * @export
 * @interface PayoutSystemAccountListItemResponse
 */
export interface PayoutSystemAccountListItemResponse {
    /**
     * Payout system account id
     * @type {number}
     * @memberof PayoutSystemAccountListItemResponse
     */
    'payout_system_account_id': number;
    /**
     * Payout system id
     * @type {number}
     * @memberof PayoutSystemAccountListItemResponse
     */
    'payout_system_id': number;
    /**
     * Description
     * @type {string}
     * @memberof PayoutSystemAccountListItemResponse
     */
    'description': string;
    /**
     * Payout system id
     * @type {number}
     * @memberof PayoutSystemAccountListItemResponse
     */
    'commission': number;
    /**
     * Payout system account unique id
     * @type {string}
     * @memberof PayoutSystemAccountListItemResponse
     */
    'commission_type': PayoutSystemAccountListItemResponseCommissionTypeEnum;
    /**
     * Title
     * @type {string}
     * @memberof PayoutSystemAccountListItemResponse
     */
    'title': string;
    /**
     * Active
     * @type {boolean}
     * @memberof PayoutSystemAccountListItemResponse
     */
    'active': boolean;
    /**
     * Currency
     * @type {string}
     * @memberof PayoutSystemAccountListItemResponse
     */
    'currency': PayoutSystemAccountListItemResponseCurrencyEnum;
    /**
     * Minimum amount
     * @type {number}
     * @memberof PayoutSystemAccountListItemResponse
     */
    'min_amount': number;
    /**
     * Maximum amount
     * @type {number}
     * @memberof PayoutSystemAccountListItemResponse
     */
    'max_amount': number;
}

export const PayoutSystemAccountListItemResponseCommissionTypeEnum = {
    Percent: 'percent',
    Fix: 'fix'
} as const;

export type PayoutSystemAccountListItemResponseCommissionTypeEnum = typeof PayoutSystemAccountListItemResponseCommissionTypeEnum[keyof typeof PayoutSystemAccountListItemResponseCommissionTypeEnum];
export const PayoutSystemAccountListItemResponseCurrencyEnum = {
    Rub: 'rub',
    Usd: 'usd'
} as const;

export type PayoutSystemAccountListItemResponseCurrencyEnum = typeof PayoutSystemAccountListItemResponseCurrencyEnum[keyof typeof PayoutSystemAccountListItemResponseCurrencyEnum];

/**
 * 
 * @export
 * @interface PlanRefund
 */
export interface PlanRefund {
    /**
     * Refund for the current rate
     * @type {number}
     * @memberof PlanRefund
     */
    'current': number;
    /**
     * Refund for the next rate
     * @type {number}
     * @memberof PlanRefund
     */
    'after': number;
}
/**
 * 
 * @export
 * @interface PlanRestream2UserItemResponse
 */
export interface PlanRestream2UserItemResponse {
    /**
     * Plan restream id
     * @type {number}
     * @memberof PlanRestream2UserItemResponse
     */
    'plan_restream2user_id': number;
    /**
     * Plan restream id
     * @type {number}
     * @memberof PlanRestream2UserItemResponse
     */
    'plan_restream_id': number;
    /**
     * Date end tariff
     * @type {string}
     * @memberof PlanRestream2UserItemResponse
     */
    'date_end': string | null;
    /**
     * Date start
     * @type {string}
     * @memberof PlanRestream2UserItemResponse
     */
    'date_start': string | null;
    /**
     * Date create
     * @type {string}
     * @memberof PlanRestream2UserItemResponse
     */
    'date_create': string | null;
    /**
     * Plan period
     * @type {string}
     * @memberof PlanRestream2UserItemResponse
     */
    'period': PlanRestream2UserItemResponsePeriodEnum | null;
    /**
     * Money flow uuid
     * @type {string}
     * @memberof PlanRestream2UserItemResponse
     */
    'money_flow_uuid': string;
    /**
     * Period uuid
     * @type {string}
     * @memberof PlanRestream2UserItemResponse
     */
    'period_uuid': string;
    /**
     * Status
     * @type {string}
     * @memberof PlanRestream2UserItemResponse
     */
    'status': string;
    /**
     * Prolongation
     * @type {number}
     * @memberof PlanRestream2UserItemResponse
     */
    'prolongation': number;
}

export const PlanRestream2UserItemResponsePeriodEnum = {
    Month: 'month',
    Year: 'year'
} as const;

export type PlanRestream2UserItemResponsePeriodEnum = typeof PlanRestream2UserItemResponsePeriodEnum[keyof typeof PlanRestream2UserItemResponsePeriodEnum];

/**
 * 
 * @export
 * @interface PlanRestreamBeforeItem
 */
export interface PlanRestreamBeforeItem {
    /**
     * Plan restream id
     * @type {number}
     * @memberof PlanRestreamBeforeItem
     */
    'id': number;
    /**
     * Max channels
     * @type {number}
     * @memberof PlanRestreamBeforeItem
     */
    'channel_max'?: number;
    /**
     * Max bitrate
     * @type {number}
     * @memberof PlanRestreamBeforeItem
     */
    'bitrate_max'?: number;
    /**
     * Date end tariff
     * @type {string}
     * @memberof PlanRestreamBeforeItem
     */
    'date_end': string;
}
/**
 * 
 * @export
 * @interface PlanRestreamCheckV2Response
 */
export interface PlanRestreamCheckV2Response {
    /**
     * Tariff price
     * @type {number}
     * @memberof PlanRestreamCheckV2Response
     */
    'tariff_price_month': number;
    /**
     * Tariff price
     * @type {number}
     * @memberof PlanRestreamCheckV2Response
     */
    'tariff_price_year': number;
    /**
     * Balance for pay
     * @type {number}
     * @memberof PlanRestreamCheckV2Response
     */
    'balance': number;
    /**
     * Sum for pay
     * @type {number}
     * @memberof PlanRestreamCheckV2Response
     */
    'sum'?: number;
    /**
     * Refund current
     * @type {number}
     * @memberof PlanRestreamCheckV2Response
     */
    'refund_current'?: number;
    /**
     * Refund after
     * @type {number}
     * @memberof PlanRestreamCheckV2Response
     */
    'refund_after'?: number;
    /**
     * Refund balance
     * @type {number}
     * @memberof PlanRestreamCheckV2Response
     */
    'refund_balance'?: number;
    /**
     * Decrease balance
     * @type {number}
     * @memberof PlanRestreamCheckV2Response
     */
    'decrease_balance'?: number;
    /**
     * Value for total
     * @type {number}
     * @memberof PlanRestreamCheckV2Response
     */
    'total'?: number;
    /**
     * Name for button
     * @type {string}
     * @memberof PlanRestreamCheckV2Response
     */
    'notification'?: string;
    /**
     * Date for notification
     * @type {string}
     * @memberof PlanRestreamCheckV2Response
     */
    'notification_date'?: string;
    /**
     * Name for button
     * @type {string}
     * @memberof PlanRestreamCheckV2Response
     */
    'button_name': string;
    /**
     * Currency
     * @type {string}
     * @memberof PlanRestreamCheckV2Response
     */
    'currency': PlanRestreamCheckV2ResponseCurrencyEnum;
    /**
     * Status for plan
     * @type {string}
     * @memberof PlanRestreamCheckV2Response
     */
    'choose_status': PlanRestreamCheckV2ResponseChooseStatusEnum;
    /**
     * Status for plan
     * @type {string}
     * @memberof PlanRestreamCheckV2Response
     */
    'status': PlanRestreamCheckV2ResponseStatusEnum;
    /**
     * Current channels
     * @type {number}
     * @memberof PlanRestreamCheckV2Response
     */
    'channel'?: number;
    /**
     * Current bitrate
     * @type {number}
     * @memberof PlanRestreamCheckV2Response
     */
    'bitrate'?: number;
}

export const PlanRestreamCheckV2ResponseCurrencyEnum = {
    Rub: 'rub',
    Usd: 'usd'
} as const;

export type PlanRestreamCheckV2ResponseCurrencyEnum = typeof PlanRestreamCheckV2ResponseCurrencyEnum[keyof typeof PlanRestreamCheckV2ResponseCurrencyEnum];
export const PlanRestreamCheckV2ResponseChooseStatusEnum = {
    New: 'new',
    Prolongate: 'prolongate',
    Upgrade: 'upgrade',
    Downgrade: 'downgrade'
} as const;

export type PlanRestreamCheckV2ResponseChooseStatusEnum = typeof PlanRestreamCheckV2ResponseChooseStatusEnum[keyof typeof PlanRestreamCheckV2ResponseChooseStatusEnum];
export const PlanRestreamCheckV2ResponseStatusEnum = {
    New: 'new',
    Current: 'current',
    CurrentUpgrade: 'current_upgrade',
    CurrentDowngrade: 'current_downgrade',
    Upgrade: 'upgrade',
    Downgrade: 'downgrade'
} as const;

export type PlanRestreamCheckV2ResponseStatusEnum = typeof PlanRestreamCheckV2ResponseStatusEnum[keyof typeof PlanRestreamCheckV2ResponseStatusEnum];

/**
 * 
 * @export
 * @interface PlanRestreamCurrentItem
 */
export interface PlanRestreamCurrentItem {
    /**
     * Plan restream id
     * @type {number}
     * @memberof PlanRestreamCurrentItem
     */
    'id': number;
    /**
     * Max channels
     * @type {number}
     * @memberof PlanRestreamCurrentItem
     */
    'channel_max'?: number;
    /**
     * Max bitrate
     * @type {number}
     * @memberof PlanRestreamCurrentItem
     */
    'bitrate_max'?: number;
    /**
     * Date end tariff
     * @type {string}
     * @memberof PlanRestreamCurrentItem
     */
    'date_end': string;
}
/**
 * 
 * @export
 * @interface PlanRestreamDiscountResponse
 */
export interface PlanRestreamDiscountResponse {
    /**
     * Month discount
     * @type {number}
     * @memberof PlanRestreamDiscountResponse
     */
    'month': number;
    /**
     * Year discount
     * @type {number}
     * @memberof PlanRestreamDiscountResponse
     */
    'year': number;
}
/**
 * 
 * @export
 * @interface PlanRestreamFeatureItem
 */
export interface PlanRestreamFeatureItem {
    /**
     * Name
     * @type {string}
     * @memberof PlanRestreamFeatureItem
     */
    'name': PlanRestreamFeatureItemNameEnum;
    /**
     * Unit
     * @type {string}
     * @memberof PlanRestreamFeatureItem
     */
    'unit'?: string;
}

export const PlanRestreamFeatureItemNameEnum = {
    CountChannelMax: 'count_channel_max',
    BitrateMax: 'bitrate_max',
    Resolution: 'resolution',
    CreateProjects: 'create_projects',
    Chat: 'chat',
    Video: 'video',
    VideoStorage: 'video_storage',
    ChangeSubject: 'change_subject',
    BackgroundChat: 'background_chat',
    DedicatedServer: 'dedicated_server',
    PersonalManager: 'personal_manager'
} as const;

export type PlanRestreamFeatureItemNameEnum = typeof PlanRestreamFeatureItemNameEnum[keyof typeof PlanRestreamFeatureItemNameEnum];

/**
 * 
 * @export
 * @interface PlanRestreamFeatureItemV2
 */
export interface PlanRestreamFeatureItemV2 {
    /**
     * Name
     * @type {string}
     * @memberof PlanRestreamFeatureItemV2
     */
    'name': string;
    /**
     * Type variable
     * @type {string}
     * @memberof PlanRestreamFeatureItemV2
     */
    'type': PlanRestreamFeatureItemV2TypeEnum;
    /**
     * 
     * @type {PlanRestreamFeatureItemV2Value}
     * @memberof PlanRestreamFeatureItemV2
     */
    'value': PlanRestreamFeatureItemV2Value;
    /**
     * Field for sort
     * @type {number}
     * @memberof PlanRestreamFeatureItemV2
     */
    'index': number;
    /**
     * Unit
     * @type {string}
     * @memberof PlanRestreamFeatureItemV2
     */
    'unit'?: string;
}

export const PlanRestreamFeatureItemV2TypeEnum = {
    String: 'string',
    Number: 'number',
    Boolean: 'boolean'
} as const;

export type PlanRestreamFeatureItemV2TypeEnum = typeof PlanRestreamFeatureItemV2TypeEnum[keyof typeof PlanRestreamFeatureItemV2TypeEnum];

/**
 * @type PlanRestreamFeatureItemV2Value
 * Value
 * @export
 */
export type PlanRestreamFeatureItemV2Value = boolean | number | string;

/**
 * 
 * @export
 * @interface PlanRestreamFeatureListResponse
 */
export interface PlanRestreamFeatureListResponse {
    /**
     * Array of items
     * @type {Array<PlanRestreamFeatureItem>}
     * @memberof PlanRestreamFeatureListResponse
     */
    'results': Array<PlanRestreamFeatureItem>;
}
/**
 * 
 * @export
 * @interface PlanRestreamForProject
 */
export interface PlanRestreamForProject {
    /**
     * Before tariff restream
     * @type {PlanRestreamItem}
     * @memberof PlanRestreamForProject
     */
    'before': PlanRestreamItem;
    /**
     * Current tariff restream
     * @type {PlanRestreamItem}
     * @memberof PlanRestreamForProject
     */
    'current': PlanRestreamItem;
    /**
     * Next tariff restream
     * @type {PlanRestreamItem}
     * @memberof PlanRestreamForProject
     */
    'next': PlanRestreamItem;
}
/**
 * 
 * @export
 * @interface PlanRestreamForProjectV2
 */
export interface PlanRestreamForProjectV2 {
    /**
     * Before tariff restream
     * @type {PlanRestreamBeforeItem}
     * @memberof PlanRestreamForProjectV2
     */
    'before'?: PlanRestreamBeforeItem;
    /**
     * Current tariff restream
     * @type {PlanRestreamCurrentItem}
     * @memberof PlanRestreamForProjectV2
     */
    'current': PlanRestreamCurrentItem;
    /**
     * Next tariff restream
     * @type {PlanRestreamNextItem}
     * @memberof PlanRestreamForProjectV2
     */
    'next'?: PlanRestreamNextItem;
}
/**
 * 
 * @export
 * @interface PlanRestreamItem
 */
export interface PlanRestreamItem {
    /**
     * Plan restream id
     * @type {number}
     * @memberof PlanRestreamItem
     */
    'id': number;
    /**
     * Max channels
     * @type {number}
     * @memberof PlanRestreamItem
     */
    'channel_max': number;
    /**
     * Max bitrate
     * @type {number}
     * @memberof PlanRestreamItem
     */
    'bitrate_max': number;
    /**
     * Date end tariff
     * @type {string}
     * @memberof PlanRestreamItem
     */
    'date_end': string;
}
/**
 * 
 * @export
 * @interface PlanRestreamNextItem
 */
export interface PlanRestreamNextItem {
    /**
     * Plan restream id
     * @type {number}
     * @memberof PlanRestreamNextItem
     */
    'id': number;
    /**
     * Max channels
     * @type {number}
     * @memberof PlanRestreamNextItem
     */
    'channel_max'?: number;
    /**
     * Max bitrate
     * @type {number}
     * @memberof PlanRestreamNextItem
     */
    'bitrate_max'?: number;
    /**
     * Date start tariff
     * @type {string}
     * @memberof PlanRestreamNextItem
     */
    'date_start': string;
}
/**
 * 
 * @export
 * @interface PlanRestreamPrice
 */
export interface PlanRestreamPrice {
    /**
     * Price per month
     * @type {number}
     * @memberof PlanRestreamPrice
     */
    'month': number;
    /**
     * Price per year
     * @type {number}
     * @memberof PlanRestreamPrice
     */
    'year': number;
}
/**
 * 
 * @export
 * @interface PlanRestreamProjectResponse
 */
export interface PlanRestreamProjectResponse {
    /**
     * Unique ID
     * @type {number}
     * @memberof PlanRestreamProjectResponse
     */
    'plan_restream_id': number;
    /**
     * Title
     * @type {string}
     * @memberof PlanRestreamProjectResponse
     */
    'title': string;
    /**
     * Active
     * @type {boolean}
     * @memberof PlanRestreamProjectResponse
     */
    'active': boolean;
    /**
     * Minimum channel count
     * @type {number}
     * @memberof PlanRestreamProjectResponse
     */
    'count_channel_min'?: number;
    /**
     * Maximum channel count
     * @type {number}
     * @memberof PlanRestreamProjectResponse
     */
    'count_channel_max': number;
    /**
     * Step channel
     * @type {number}
     * @memberof PlanRestreamProjectResponse
     */
    'count_channel_step'?: number;
    /**
     * Type
     * @type {string}
     * @memberof PlanRestreamProjectResponse
     */
    'type': PlanRestreamProjectResponseTypeEnum;
    /**
     * Maximum bitrate, kbps
     * @type {number}
     * @memberof PlanRestreamProjectResponse
     */
    'bitrate_max': number | null;
    /**
     * Minimum bitrate, kbps
     * @type {number}
     * @memberof PlanRestreamProjectResponse
     */
    'bitrate_min'?: number;
    /**
     * Step bitrate
     * @type {number}
     * @memberof PlanRestreamProjectResponse
     */
    'bitrate_step'?: number;
    /**
     * Field for sort
     * @type {number}
     * @memberof PlanRestreamProjectResponse
     */
    'index': number;
    /**
     * Price
     * @type {PlanRestreamPrice}
     * @memberof PlanRestreamProjectResponse
     */
    'price': PlanRestreamPrice;
    /**
     * Status
     * @type {string}
     * @memberof PlanRestreamProjectResponse
     */
    'status': PlanRestreamProjectResponseStatusEnum;
    /**
     * Features
     * @type {Array<PlanRestreamFeatureItemV2>}
     * @memberof PlanRestreamProjectResponse
     */
    'feature': Array<PlanRestreamFeatureItemV2>;
    /**
     * Tariff project
     * @type {PlanRestreamForProjectV2}
     * @memberof PlanRestreamProjectResponse
     */
    'own_tariff': PlanRestreamForProjectV2;
}

export const PlanRestreamProjectResponseTypeEnum = {
    Free: 'free',
    PaidFix: 'paid_fix',
    PaidFlex: 'paid_flex',
    Custom: 'custom'
} as const;

export type PlanRestreamProjectResponseTypeEnum = typeof PlanRestreamProjectResponseTypeEnum[keyof typeof PlanRestreamProjectResponseTypeEnum];
export const PlanRestreamProjectResponseStatusEnum = {
    Current: 'current',
    Upgrade: 'upgrade',
    Downgrade: 'downgrade'
} as const;

export type PlanRestreamProjectResponseStatusEnum = typeof PlanRestreamProjectResponseStatusEnum[keyof typeof PlanRestreamProjectResponseStatusEnum];

/**
 * 
 * @export
 * @interface PlanRestreamProjectResponseDto
 */
export interface PlanRestreamProjectResponseDto {
    /**
     * Array of items
     * @type {Array<PlanRestreamProjectResponse>}
     * @memberof PlanRestreamProjectResponseDto
     */
    'results': Array<PlanRestreamProjectResponse>;
}
/**
 * 
 * @export
 * @interface PlanRestreamResponse
 */
export interface PlanRestreamResponse {
    /**
     * Unique ID
     * @type {number}
     * @memberof PlanRestreamResponse
     */
    'plan_restream_id': number;
    /**
     * Title
     * @type {string}
     * @memberof PlanRestreamResponse
     */
    'title': string;
    /**
     * Active
     * @type {boolean}
     * @memberof PlanRestreamResponse
     */
    'active': boolean;
    /**
     * Minimum channel count
     * @type {number}
     * @memberof PlanRestreamResponse
     */
    'count_channel_min': number | null;
    /**
     * Maximum channel count
     * @type {number}
     * @memberof PlanRestreamResponse
     */
    'count_channel_max': number | null;
    /**
     * Type
     * @type {string}
     * @memberof PlanRestreamResponse
     */
    'type': PlanRestreamResponseTypeEnum;
    /**
     * Price (RUB)
     * @type {number}
     * @memberof PlanRestreamResponse
     */
    'price_rub': number | null;
    /**
     * Price (USD)
     * @type {number}
     * @memberof PlanRestreamResponse
     */
    'price_usd': number | null;
    /**
     * Maximum bitrate, kbps
     * @type {number}
     * @memberof PlanRestreamResponse
     */
    'bitrate_max': number | null;
    /**
     * Minimum bitrate, kbps
     * @type {number}
     * @memberof PlanRestreamResponse
     */
    'bitrate_min': number | null;
    /**
     * Resolution
     * @type {string}
     * @memberof PlanRestreamResponse
     */
    'resolution': PlanRestreamResponseResolutionEnum;
    /**
     * Fps
     * @type {string}
     * @memberof PlanRestreamResponse
     */
    'fps': PlanRestreamResponseFpsEnum;
    /**
     * Create project in account
     * @type {boolean}
     * @memberof PlanRestreamResponse
     */
    'create_projects': boolean;
    /**
     * Use multichat
     * @type {boolean}
     * @memberof PlanRestreamResponse
     */
    'chat': boolean;
    /**
     * Playing video as a broadcast
     * @type {boolean}
     * @memberof PlanRestreamResponse
     */
    'video': boolean;
    /**
     * Storage of video files, Gb
     * @type {number}
     * @memberof PlanRestreamResponse
     */
    'video_storage': number | null;
    /**
     * Change title, description, image and other data of stream
     * @type {boolean}
     * @memberof PlanRestreamResponse
     */
    'change_subject': boolean;
    /**
     * Collect chat messages in the background
     * @type {boolean}
     * @memberof PlanRestreamResponse
     */
    'background_chat': boolean;
    /**
     * Dedicated server
     * @type {boolean}
     * @memberof PlanRestreamResponse
     */
    'dedicated_server': boolean;
    /**
     * Personal manager
     * @type {number}
     * @memberof PlanRestreamResponse
     */
    'personal_manager': number | null;
    /**
     * pull links
     * @type {number}
     * @memberof PlanRestreamResponse
     */
    'pull_link_limit': number;
    /**
     * Field for sort
     * @type {number}
     * @memberof PlanRestreamResponse
     */
    'index': number;
    /**
     * Discount
     * @type {PlanRestreamDiscountResponse}
     * @memberof PlanRestreamResponse
     */
    'discount': PlanRestreamDiscountResponse;
}

export const PlanRestreamResponseTypeEnum = {
    Free: 'free',
    PaidFix: 'paid_fix',
    PaidFlex: 'paid_flex',
    Custom: 'custom'
} as const;

export type PlanRestreamResponseTypeEnum = typeof PlanRestreamResponseTypeEnum[keyof typeof PlanRestreamResponseTypeEnum];
export const PlanRestreamResponseResolutionEnum = {
    _720p: '720p',
    _1080p: '1080p',
    _2K: '2K',
    Uw: 'UW',
    _4K: '4K',
    _8K: '8K'
} as const;

export type PlanRestreamResponseResolutionEnum = typeof PlanRestreamResponseResolutionEnum[keyof typeof PlanRestreamResponseResolutionEnum];
export const PlanRestreamResponseFpsEnum = {
    _30: '30',
    _60: '60'
} as const;

export type PlanRestreamResponseFpsEnum = typeof PlanRestreamResponseFpsEnum[keyof typeof PlanRestreamResponseFpsEnum];

/**
 * 
 * @export
 * @interface PlanRestreamResponseDto
 */
export interface PlanRestreamResponseDto {
    /**
     * Array of items
     * @type {Array<PlanRestreamResponse>}
     * @memberof PlanRestreamResponseDto
     */
    'results': Array<PlanRestreamResponse>;
    /**
     * Features
     * @type {PlanRestreamFeatureListResponse}
     * @memberof PlanRestreamResponseDto
     */
    'feature': PlanRestreamFeatureListResponse;
}
/**
 * 
 * @export
 * @interface PlanStorage2UserItemResponse
 */
export interface PlanStorage2UserItemResponse {
    /**
     * Plan storage2user id
     * @type {number}
     * @memberof PlanStorage2UserItemResponse
     */
    'plan_storage2user_id': number;
    /**
     * Plan storage id
     * @type {number}
     * @memberof PlanStorage2UserItemResponse
     */
    'plan_storage_id': number;
    /**
     * Size
     * @type {number}
     * @memberof PlanStorage2UserItemResponse
     */
    'size': number;
    /**
     * Date start tariff
     * @type {string}
     * @memberof PlanStorage2UserItemResponse
     */
    'date_start': string;
    /**
     * Date end tariff
     * @type {string}
     * @memberof PlanStorage2UserItemResponse
     */
    'date_end': string;
    /**
     * Date create tariff
     * @type {string}
     * @memberof PlanStorage2UserItemResponse
     */
    'date_create': string;
    /**
     * Period
     * @type {string}
     * @memberof PlanStorage2UserItemResponse
     */
    'period': PlanStorage2UserItemResponsePeriodEnum | null;
    /**
     * Period uuid
     * @type {string}
     * @memberof PlanStorage2UserItemResponse
     */
    'period_uuid': string;
    /**
     * Status
     * @type {string}
     * @memberof PlanStorage2UserItemResponse
     */
    'status': string;
    /**
     * Prolongation
     * @type {number}
     * @memberof PlanStorage2UserItemResponse
     */
    'prolongation'?: number;
    /**
     * Money flow uuid
     * @type {string}
     * @memberof PlanStorage2UserItemResponse
     */
    'money_flow_uuid': string;
}

export const PlanStorage2UserItemResponsePeriodEnum = {
    Month: 'month',
    Year: 'year'
} as const;

export type PlanStorage2UserItemResponsePeriodEnum = typeof PlanStorage2UserItemResponsePeriodEnum[keyof typeof PlanStorage2UserItemResponsePeriodEnum];

/**
 * 
 * @export
 * @interface PlanStorageCheckResponse
 */
export interface PlanStorageCheckResponse {
    /**
     * Amount
     * @type {number}
     * @memberof PlanStorageCheckResponse
     */
    'amount': number;
    /**
     * Balance for pay object
     * @type {BalanceForPayResponse}
     * @memberof PlanStorageCheckResponse
     */
    'balance': BalanceForPayResponse;
    /**
     * Refund for rate
     * @type {PlanRefund}
     * @memberof PlanStorageCheckResponse
     */
    'refund': PlanRefund;
}
/**
 * 
 * @export
 * @interface PlanStorageDiscountResponse
 */
export interface PlanStorageDiscountResponse {
    /**
     * Month discount
     * @type {number}
     * @memberof PlanStorageDiscountResponse
     */
    'month': number;
    /**
     * Year discount
     * @type {number}
     * @memberof PlanStorageDiscountResponse
     */
    'year': number;
}
/**
 * 
 * @export
 * @interface PlanStorageForProject
 */
export interface PlanStorageForProject {
    /**
     * Before tariff restream
     * @type {PlanStorageItem}
     * @memberof PlanStorageForProject
     */
    'before': PlanStorageItem;
    /**
     * Current tariff restream
     * @type {PlanStorageItem}
     * @memberof PlanStorageForProject
     */
    'current': PlanStorageItem;
    /**
     * Next tariff restream
     * @type {PlanStorageItem}
     * @memberof PlanStorageForProject
     */
    'next': PlanStorageItem;
}
/**
 * 
 * @export
 * @interface PlanStorageItem
 */
export interface PlanStorageItem {
    /**
     * Plan restream id
     * @type {number}
     * @memberof PlanStorageItem
     */
    'id': number;
    /**
     * Size
     * @type {number}
     * @memberof PlanStorageItem
     */
    'size': number;
    /**
     * Period
     * @type {string}
     * @memberof PlanStorageItem
     */
    'period': PlanStorageItemPeriodEnum;
    /**
     * Date end tariff
     * @type {string}
     * @memberof PlanStorageItem
     */
    'date_end': string;
}

export const PlanStorageItemPeriodEnum = {
    Month: 'month',
    Year: 'year'
} as const;

export type PlanStorageItemPeriodEnum = typeof PlanStorageItemPeriodEnum[keyof typeof PlanStorageItemPeriodEnum];

/**
 * 
 * @export
 * @interface PlanStorageResponse
 */
export interface PlanStorageResponse {
    /**
     * Unique ID
     * @type {number}
     * @memberof PlanStorageResponse
     */
    'plan_storage_id': number;
    /**
     * Title
     * @type {string}
     * @memberof PlanStorageResponse
     */
    'title': string;
    /**
     * Minimum storage size, gb
     * @type {number}
     * @memberof PlanStorageResponse
     */
    'min': number;
    /**
     * Maximum storage size, gb
     * @type {number}
     * @memberof PlanStorageResponse
     */
    'max': number;
    /**
     * Price per gb (RUB)
     * @type {number}
     * @memberof PlanStorageResponse
     */
    'price_rub': number;
    /**
     * Price per gb (USD)
     * @type {number}
     * @memberof PlanStorageResponse
     */
    'price_usd': number;
    /**
     * Step increase in gb
     * @type {number}
     * @memberof PlanStorageResponse
     */
    'step': number;
    /**
     * Is active
     * @type {boolean}
     * @memberof PlanStorageResponse
     */
    'active': boolean;
    /**
     * Discount
     * @type {PlanStorageDiscountResponse}
     * @memberof PlanStorageResponse
     */
    'discount': PlanStorageDiscountResponse;
}
/**
 * 
 * @export
 * @interface PlanStorageResponseDto
 */
export interface PlanStorageResponseDto {
    /**
     * Array of items
     * @type {Array<PlanStorageResponse>}
     * @memberof PlanStorageResponseDto
     */
    'results': Array<PlanStorageResponse>;
}
/**
 * 
 * @export
 * @interface PlanTranscoding2UserItemResponse
 */
export interface PlanTranscoding2UserItemResponse {
    /**
     * Plan transcoding id
     * @type {number}
     * @memberof PlanTranscoding2UserItemResponse
     */
    'plan_transcoding2user_id': number;
    /**
     * Count flows
     * @type {number}
     * @memberof PlanTranscoding2UserItemResponse
     */
    'count': number;
    /**
     * Date start tariff
     * @type {string}
     * @memberof PlanTranscoding2UserItemResponse
     */
    'date_start': string;
    /**
     * Date end tariff
     * @type {string}
     * @memberof PlanTranscoding2UserItemResponse
     */
    'date_end': string;
    /**
     * Date create tariff
     * @type {string}
     * @memberof PlanTranscoding2UserItemResponse
     */
    'date_create': string;
    /**
     * Period
     * @type {string}
     * @memberof PlanTranscoding2UserItemResponse
     */
    'period': PlanTranscoding2UserItemResponsePeriodEnum | null;
    /**
     * Period uuid
     * @type {string}
     * @memberof PlanTranscoding2UserItemResponse
     */
    'period_uuid': string;
    /**
     * Status
     * @type {string}
     * @memberof PlanTranscoding2UserItemResponse
     */
    'status': string;
    /**
     * Prolongation
     * @type {number}
     * @memberof PlanTranscoding2UserItemResponse
     */
    'prolongation'?: number;
}

export const PlanTranscoding2UserItemResponsePeriodEnum = {
    Month: 'month',
    Year: 'year'
} as const;

export type PlanTranscoding2UserItemResponsePeriodEnum = typeof PlanTranscoding2UserItemResponsePeriodEnum[keyof typeof PlanTranscoding2UserItemResponsePeriodEnum];

/**
 * 
 * @export
 * @interface PlanTranscodingCheckResponse
 */
export interface PlanTranscodingCheckResponse {
    /**
     * Amount
     * @type {number}
     * @memberof PlanTranscodingCheckResponse
     */
    'amount': number;
    /**
     * Balance for pay object
     * @type {BalanceForPayResponse}
     * @memberof PlanTranscodingCheckResponse
     */
    'balance': BalanceForPayResponse;
    /**
     * Refund for rate
     * @type {PlanRefund}
     * @memberof PlanTranscodingCheckResponse
     */
    'refund': PlanRefund;
}
/**
 * 
 * @export
 * @interface PlanTranscodingDiscountResponse
 */
export interface PlanTranscodingDiscountResponse {
    /**
     * Month discount
     * @type {number}
     * @memberof PlanTranscodingDiscountResponse
     */
    'month': number;
    /**
     * Year discount
     * @type {number}
     * @memberof PlanTranscodingDiscountResponse
     */
    'year': number;
}
/**
 * 
 * @export
 * @interface PlanTranscodingForProject
 */
export interface PlanTranscodingForProject {
    /**
     * Before tariff transcoding
     * @type {PlanTranscodingItem}
     * @memberof PlanTranscodingForProject
     */
    'before': PlanTranscodingItem;
    /**
     * Current tariff transcoding
     * @type {PlanTranscodingItem}
     * @memberof PlanTranscodingForProject
     */
    'current': PlanTranscodingItem;
    /**
     * Next tariff transcoding
     * @type {PlanTranscodingItem}
     * @memberof PlanTranscodingForProject
     */
    'next': PlanTranscodingItem;
}
/**
 * 
 * @export
 * @interface PlanTranscodingItem
 */
export interface PlanTranscodingItem {
    /**
     * Plan transcoding id
     * @type {number}
     * @memberof PlanTranscodingItem
     */
    'id': number;
    /**
     * Count flows
     * @type {number}
     * @memberof PlanTranscodingItem
     */
    'count': number;
    /**
     * Date end tariff
     * @type {string}
     * @memberof PlanTranscodingItem
     */
    'date_end': string;
    /**
     * Plan title
     * @type {string}
     * @memberof PlanTranscodingItem
     */
    'title': string;
    /**
     * Prolongation
     * @type {number}
     * @memberof PlanTranscodingItem
     */
    'prolongation'?: number;
}
/**
 * 
 * @export
 * @interface PlanTranscodingResponse
 */
export interface PlanTranscodingResponse {
    /**
     * Unique id
     * @type {number}
     * @memberof PlanTranscodingResponse
     */
    'plan_transcoding_id': number;
    /**
     * Title
     * @type {string}
     * @memberof PlanTranscodingResponse
     */
    'title': string;
    /**
     * Type
     * @type {string}
     * @memberof PlanTranscodingResponse
     */
    'type': PlanTranscodingResponseTypeEnum;
    /**
     * Price (RUB)
     * @type {number}
     * @memberof PlanTranscodingResponse
     */
    'price_rub': number;
    /**
     * Price (USD)
     * @type {number}
     * @memberof PlanTranscodingResponse
     */
    'price_usd': number;
    /**
     * Maximum resolution
     * @type {string}
     * @memberof PlanTranscodingResponse
     */
    'resolution': PlanTranscodingResponseResolutionEnum | null;
    /**
     * Maximum fps
     * @type {string}
     * @memberof PlanTranscodingResponse
     */
    'fps': PlanTranscodingResponseFpsEnum;
    /**
     * Server load weight
     * @type {number}
     * @memberof PlanTranscodingResponse
     */
    'weight': number;
    /**
     * Active
     * @type {boolean}
     * @memberof PlanTranscodingResponse
     */
    'active': boolean;
    /**
     * Field for sort
     * @type {number}
     * @memberof PlanTranscodingResponse
     */
    'index': number;
    /**
     * Free spaces slot
     * @type {number}
     * @memberof PlanTranscodingResponse
     */
    'space': number;
    /**
     * Discount
     * @type {PlanTranscodingDiscountResponse}
     * @memberof PlanTranscodingResponse
     */
    'discount': PlanTranscodingDiscountResponse;
}

export const PlanTranscodingResponseTypeEnum = {
    Free: 'free',
    PaidMonth: 'paid_month',
    PaidMinute: 'paid_minute',
    Custom: 'custom'
} as const;

export type PlanTranscodingResponseTypeEnum = typeof PlanTranscodingResponseTypeEnum[keyof typeof PlanTranscodingResponseTypeEnum];
export const PlanTranscodingResponseResolutionEnum = {
    _720p: '720p',
    _1080p: '1080p',
    _2K: '2K',
    Uw: 'UW',
    _4K: '4K',
    _8K: '8K'
} as const;

export type PlanTranscodingResponseResolutionEnum = typeof PlanTranscodingResponseResolutionEnum[keyof typeof PlanTranscodingResponseResolutionEnum];
export const PlanTranscodingResponseFpsEnum = {
    _30: '30',
    _60: '60'
} as const;

export type PlanTranscodingResponseFpsEnum = typeof PlanTranscodingResponseFpsEnum[keyof typeof PlanTranscodingResponseFpsEnum];

/**
 * 
 * @export
 * @interface PlanTranscodingResponseDto
 */
export interface PlanTranscodingResponseDto {
    /**
     * Array of items
     * @type {Array<PlanTranscodingResponse>}
     * @memberof PlanTranscodingResponseDto
     */
    'results': Array<PlanTranscodingResponse>;
}
/**
 * 
 * @export
 * @interface PlannedItemResponse
 */
export interface PlannedItemResponse {
    /**
     * id
     * @type {string}
     * @memberof PlannedItemResponse
     */
    'id': string;
    /**
     * title
     * @type {string}
     * @memberof PlannedItemResponse
     */
    'title': string;
    /**
     * description
     * @type {string}
     * @memberof PlannedItemResponse
     */
    'description': string;
    /**
     * date
     * @type {string}
     * @memberof PlannedItemResponse
     */
    'date': string;
}
/**
 * 
 * @export
 * @interface PlaylistItemResponse
 */
export interface PlaylistItemResponse {
    /**
     * id
     * @type {string}
     * @memberof PlaylistItemResponse
     */
    'id': string;
    /**
     * name
     * @type {string}
     * @memberof PlaylistItemResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ProjectChannelInviteChannelLinkResponse
 */
export interface ProjectChannelInviteChannelLinkResponse {
    /**
     * Unique id
     * @type {number}
     * @memberof ProjectChannelInviteChannelLinkResponse
     */
    'channel_id': number;
    /**
     * First name
     * @type {string}
     * @memberof ProjectChannelInviteChannelLinkResponse
     */
    'name': string;
    /**
     * Link to avatar 50*50px
     * @type {string}
     * @memberof ProjectChannelInviteChannelLinkResponse
     */
    'photo_50': string;
}
/**
 * 
 * @export
 * @interface ProjectChannelInviteLinkResponse
 */
export interface ProjectChannelInviteLinkResponse {
    /**
     * Unique id
     * @type {number}
     * @memberof ProjectChannelInviteLinkResponse
     */
    'project_channel_invite_id': number;
    /**
     * Channel id
     * @type {number}
     * @memberof ProjectChannelInviteLinkResponse
     */
    'channel_id': number;
    /**
     * Project id (in invite for project id)
     * @type {number}
     * @memberof ProjectChannelInviteLinkResponse
     */
    'to_project_id': number | null;
    /**
     * Access type
     * @type {number}
     * @memberof ProjectChannelInviteLinkResponse
     */
    'access_type': number;
    /**
     * Date create
     * @type {string}
     * @memberof ProjectChannelInviteLinkResponse
     */
    'date': string;
    /**
     * Secret key for link
     * @type {string}
     * @memberof ProjectChannelInviteLinkResponse
     */
    'secret': string;
    /**
     * Email
     * @type {string}
     * @memberof ProjectChannelInviteLinkResponse
     */
    'email': string | null;
    /**
     * If rejected then true
     * @type {boolean}
     * @memberof ProjectChannelInviteLinkResponse
     */
    'reject': boolean | null;
    /**
     * The user who granted access
     * @type {number}
     * @memberof ProjectChannelInviteLinkResponse
     */
    'from_user_id': number | null;
    /**
     * Project info
     * @type {ProjectChannelInviteChannelLinkResponse}
     * @memberof ProjectChannelInviteLinkResponse
     */
    'channel_'?: ProjectChannelInviteChannelLinkResponse;
}
/**
 * 
 * @export
 * @interface ProjectChannelInviteProjectResponse
 */
export interface ProjectChannelInviteProjectResponse {
    /**
     * Unique id
     * @type {number}
     * @memberof ProjectChannelInviteProjectResponse
     */
    'user_id': number;
    /**
     * First name
     * @type {string}
     * @memberof ProjectChannelInviteProjectResponse
     */
    'name': string;
    /**
     * Last name
     * @type {string}
     * @memberof ProjectChannelInviteProjectResponse
     */
    'fename': string;
    /**
     * Link to avatar 50*50px
     * @type {string}
     * @memberof ProjectChannelInviteProjectResponse
     */
    'photo_50': string;
    /**
     * Unique symbol id of user
     * @type {string}
     * @memberof ProjectChannelInviteProjectResponse
     */
    'ref_id': string;
}
/**
 * 
 * @export
 * @interface ProjectChannelInviteResponse
 */
export interface ProjectChannelInviteResponse {
    /**
     * Unique id
     * @type {number}
     * @memberof ProjectChannelInviteResponse
     */
    'project_channel_invite_id': number;
    /**
     * Channel id
     * @type {number}
     * @memberof ProjectChannelInviteResponse
     */
    'channel_id': number;
    /**
     * Project id (user)
     * @type {number}
     * @memberof ProjectChannelInviteResponse
     */
    'to_project_id': number | null;
    /**
     * Access type
     * @type {number}
     * @memberof ProjectChannelInviteResponse
     */
    'access_type': number;
    /**
     * Date create
     * @type {string}
     * @memberof ProjectChannelInviteResponse
     */
    'date': string;
    /**
     * Secret key for link
     * @type {string}
     * @memberof ProjectChannelInviteResponse
     */
    'secret': string;
    /**
     * Email
     * @type {string}
     * @memberof ProjectChannelInviteResponse
     */
    'email': string | null;
    /**
     * If rejected request then true
     * @type {boolean}
     * @memberof ProjectChannelInviteResponse
     */
    'reject': boolean | null;
    /**
     * The user who granted access
     * @type {number}
     * @memberof ProjectChannelInviteResponse
     */
    'from_user_id': number | null;
    /**
     * from_project_id
     * @type {number}
     * @memberof ProjectChannelInviteResponse
     */
    'from_project_id': number | null;
    /**
     * User info
     * @type {ProjectChannelInviteProjectResponse}
     * @memberof ProjectChannelInviteResponse
     */
    'to_project_'?: ProjectChannelInviteProjectResponse;
}
/**
 * 
 * @export
 * @interface ProjectChannelResponse
 */
export interface ProjectChannelResponse {
    /**
     * Primary key
     * @type {number}
     * @memberof ProjectChannelResponse
     */
    'id': number;
    /**
     * User id
     * @type {number}
     * @memberof ProjectChannelResponse
     */
    'project_id': number;
    /**
     * Channel id
     * @type {number}
     * @memberof ProjectChannelResponse
     */
    'channel_id': number;
    /**
     * Owner id
     * @type {number}
     * @memberof ProjectChannelResponse
     */
    'owner_id': number;
    /**
     * usageType
     * @type {number}
     * @memberof ProjectChannelResponse
     */
    'usageType': number;
}
/**
 * 
 * @export
 * @interface ProjectHistoryResponse
 */
export interface ProjectHistoryResponse {
    /**
     * Primary key
     * @type {number}
     * @memberof ProjectHistoryResponse
     */
    'id': number;
    /**
     * Action
     * @type {string}
     * @memberof ProjectHistoryResponse
     */
    'action': ProjectHistoryResponseActionEnum;
    /**
     * Project id
     * @type {number}
     * @memberof ProjectHistoryResponse
     */
    'project_id': number;
    /**
     * User id
     * @type {number}
     * @memberof ProjectHistoryResponse
     */
    'user_id': number;
    /**
     * Group id
     * @type {number}
     * @memberof ProjectHistoryResponse
     */
    'group_id': number;
    /**
     * Date
     * @type {string}
     * @memberof ProjectHistoryResponse
     */
    'date'?: string;
}

export const ProjectHistoryResponseActionEnum = {
    ProjectChannelInviteAdd: 'project_channel_invite_add',
    ProjectChannelInviteDel: 'project_channel_invite_del',
    ProjectChannelInviteAccept: 'project_channel_invite_accept',
    ProjectChannelInviteDecline: 'project_channel_invite_decline',
    UserProjectInviteAdd: 'user_project_invite_add',
    UserProjectInviteDel: 'user_project_invite_del',
    UserProjectInviteAccept: 'user_project_invite_accept',
    UserProjectInviteDecline: 'user_project_invite_decline',
    UserProjectAdd: 'user_project_add',
    UserProjectDel: 'user_project_del',
    UserProjectChange: 'user_project_change',
    ProjectChannelAdd: 'project_channel_add',
    ProjectChannelDel: 'project_channel_del',
    ProjectChannelChange: 'project_channel_change'
} as const;

export type ProjectHistoryResponseActionEnum = typeof ProjectHistoryResponseActionEnum[keyof typeof ProjectHistoryResponseActionEnum];

/**
 * 
 * @export
 * @interface ProjectInfoAccessResponse
 */
export interface ProjectInfoAccessResponse {
    /**
     * Access type
     * @type {number}
     * @memberof ProjectInfoAccessResponse
     */
    'access_type': ProjectInfoAccessResponseAccessTypeEnum;
}

export const ProjectInfoAccessResponseAccessTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type ProjectInfoAccessResponseAccessTypeEnum = typeof ProjectInfoAccessResponseAccessTypeEnum[keyof typeof ProjectInfoAccessResponseAccessTypeEnum];

/**
 * 
 * @export
 * @interface ProjectInfoDataResponse
 */
export interface ProjectInfoDataResponse {
    /**
     * Project id
     * @type {number}
     * @memberof ProjectInfoDataResponse
     */
    'project_id': number;
    /**
     * Project name
     * @type {string}
     * @memberof ProjectInfoDataResponse
     */
    'name': string;
    /**
     * Project fename
     * @type {string}
     * @memberof ProjectInfoDataResponse
     */
    'fename': string;
    /**
     * Project photo in 50px size
     * @type {string}
     * @memberof ProjectInfoDataResponse
     */
    'photo_50': string;
    /**
     * Project photo in 100px size
     * @type {string}
     * @memberof ProjectInfoDataResponse
     */
    'photo_100': string;
    /**
     * External project id
     * @type {string}
     * @memberof ProjectInfoDataResponse
     */
    'external_id': string;
    /**
     * Project type
     * @type {number}
     * @memberof ProjectInfoDataResponse
     */
    'type': ProjectInfoDataResponseTypeEnum;
    /**
     * Bonus balance
     * @type {number}
     * @memberof ProjectInfoDataResponse
     */
    'balance_bonus': number;
    /**
     * Payment balance
     * @type {number}
     * @memberof ProjectInfoDataResponse
     */
    'balance_payment': number;
    /**
     * Profit balance
     * @type {number}
     * @memberof ProjectInfoDataResponse
     */
    'balance_profit': number;
    /**
     * Currency
     * @type {number}
     * @memberof ProjectInfoDataResponse
     */
    'currency': ProjectInfoDataResponseCurrencyEnum | null;
    /**
     * Country id
     * @type {number}
     * @memberof ProjectInfoDataResponse
     */
    'country_id': number;
}

export const ProjectInfoDataResponseTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type ProjectInfoDataResponseTypeEnum = typeof ProjectInfoDataResponseTypeEnum[keyof typeof ProjectInfoDataResponseTypeEnum];
export const ProjectInfoDataResponseCurrencyEnum = {
} as const;

export type ProjectInfoDataResponseCurrencyEnum = typeof ProjectInfoDataResponseCurrencyEnum[keyof typeof ProjectInfoDataResponseCurrencyEnum];

/**
 * 
 * @export
 * @interface ProjectInfoResponse
 */
export interface ProjectInfoResponse {
    /**
     * Version
     * @type {string}
     * @memberof ProjectInfoResponse
     */
    'v': ProjectInfoResponseVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof ProjectInfoResponse
     */
    'language': ProjectInfoResponseLanguageEnum;
    /**
     * Project info
     * @type {ProjectInfoDataResponse}
     * @memberof ProjectInfoResponse
     */
    'data': ProjectInfoDataResponse;
    /**
     * Restream tariff
     * @type {ProjectInfoRestreamResponse}
     * @memberof ProjectInfoResponse
     */
    'restream': ProjectInfoRestreamResponse;
    /**
     * Transcoding tariff
     * @type {ProjectInfoTranscodingResponse}
     * @memberof ProjectInfoResponse
     */
    'transcoding': ProjectInfoTranscodingResponse | null;
    /**
     * Storage tariff
     * @type {ProjectInfoStorageResponse}
     * @memberof ProjectInfoResponse
     */
    'storage': ProjectInfoStorageResponse | null;
    /**
     * Project info access
     * @type {ProjectInfoAccessResponse}
     * @memberof ProjectInfoResponse
     */
    'access': ProjectInfoAccessResponse;
}

export const ProjectInfoResponseVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type ProjectInfoResponseVEnum = typeof ProjectInfoResponseVEnum[keyof typeof ProjectInfoResponseVEnum];
export const ProjectInfoResponseLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type ProjectInfoResponseLanguageEnum = typeof ProjectInfoResponseLanguageEnum[keyof typeof ProjectInfoResponseLanguageEnum];

/**
 * 
 * @export
 * @interface ProjectInfoRestreamResponse
 */
export interface ProjectInfoRestreamResponse {
    /**
     * Plan restream to user
     * @type {PlanRestream2UserItemResponse}
     * @memberof ProjectInfoRestreamResponse
     */
    'plan2user': PlanRestream2UserItemResponse;
    /**
     * Plan restream data
     * @type {PlanRestreamResponse}
     * @memberof ProjectInfoRestreamResponse
     */
    'data': PlanRestreamResponse;
}
/**
 * 
 * @export
 * @interface ProjectInfoStorageResponse
 */
export interface ProjectInfoStorageResponse {
    /**
     * Plan storage to user
     * @type {PlanStorage2UserItemResponse}
     * @memberof ProjectInfoStorageResponse
     */
    'plan2user': PlanStorage2UserItemResponse;
    /**
     * Plan storage data
     * @type {PlanTranscodingResponse}
     * @memberof ProjectInfoStorageResponse
     */
    'data': PlanTranscodingResponse;
}
/**
 * 
 * @export
 * @interface ProjectInfoTranscodingResponse
 */
export interface ProjectInfoTranscodingResponse {
    /**
     * Plan transcoding to user
     * @type {PlanTranscoding2UserItemResponse}
     * @memberof ProjectInfoTranscodingResponse
     */
    'plan2user': PlanTranscoding2UserItemResponse;
    /**
     * Plan transcoding data
     * @type {PlanTranscodingResponse}
     * @memberof ProjectInfoTranscodingResponse
     */
    'data': PlanTranscodingResponse;
}
/**
 * 
 * @export
 * @interface PullKeyItemResponse
 */
export interface PullKeyItemResponse {
    /**
     * Primary key
     * @type {number}
     * @memberof PullKeyItemResponse
     */
    'id': number;
    /**
     * Uuid key
     * @type {string}
     * @memberof PullKeyItemResponse
     */
    'uuid': string;
    /**
     * Transport
     * @type {string}
     * @memberof PullKeyItemResponse
     */
    'transport': PullKeyItemResponseTransportEnum;
    /**
     * Name
     * @type {string}
     * @memberof PullKeyItemResponse
     */
    'name': string;
    /**
     * Share url
     * @type {string}
     * @memberof PullKeyItemResponse
     */
    'shareUrl': string;
    /**
     * Pull status
     * @type {string}
     * @memberof PullKeyItemResponse
     */
    'status': PullKeyItemResponseStatusEnum;
}

export const PullKeyItemResponseTransportEnum = {
    Rtmp: 'rtmp',
    Srt: 'srt',
    Hls: 'hls'
} as const;

export type PullKeyItemResponseTransportEnum = typeof PullKeyItemResponseTransportEnum[keyof typeof PullKeyItemResponseTransportEnum];
export const PullKeyItemResponseStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    Error: 'error'
} as const;

export type PullKeyItemResponseStatusEnum = typeof PullKeyItemResponseStatusEnum[keyof typeof PullKeyItemResponseStatusEnum];

/**
 * 
 * @export
 * @interface PullKeyListResponse
 */
export interface PullKeyListResponse {
    /**
     * Array of items
     * @type {Array<PullKeyItemResponse>}
     * @memberof PullKeyListResponse
     */
    'results': Array<PullKeyItemResponse>;
}
/**
 * 
 * @export
 * @interface PullServerListItem
 */
export interface PullServerListItem {
    /**
     * City
     * @type {string}
     * @memberof PullServerListItem
     */
    'city': string;
    /**
     * Ping host
     * @type {string}
     * @memberof PullServerListItem
     */
    'pingHost': string;
    /**
     * Transports
     * @type {PullServerTransports}
     * @memberof PullServerListItem
     */
    'url': PullServerTransports;
    /**
     * Country
     * @type {CountryItem}
     * @memberof PullServerListItem
     */
    'country': CountryItem;
}
/**
 * 
 * @export
 * @interface PullServerListResponse
 */
export interface PullServerListResponse {
    /**
     * Array of items
     * @type {Array<PullServerListItem>}
     * @memberof PullServerListResponse
     */
    'results': Array<PullServerListItem>;
}
/**
 * 
 * @export
 * @interface PullServerTransports
 */
export interface PullServerTransports {
    /**
     * Rtmp url
     * @type {string}
     * @memberof PullServerTransports
     */
    'rtmp': string;
    /**
     * Srt url
     * @type {string}
     * @memberof PullServerTransports
     */
    'srt': string;
    /**
     * Hls url
     * @type {string}
     * @memberof PullServerTransports
     */
    'hls': string;
}
/**
 * 
 * @export
 * @interface RefreshAuthResponse
 */
export interface RefreshAuthResponse {
    /**
     * Access token
     * @type {string}
     * @memberof RefreshAuthResponse
     */
    'accessToken': string;
    /**
     * Refresh token
     * @type {string}
     * @memberof RefreshAuthResponse
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface RtmpServerGraphResponse
 */
export interface RtmpServerGraphResponse {
    /**
     * Type of graph to display
     * @type {string}
     * @memberof RtmpServerGraphResponse
     */
    'type': RtmpServerGraphResponseTypeEnum;
    /**
     * Time line for graph [timestamp]
     * @type {Array<number>}
     * @memberof RtmpServerGraphResponse
     */
    'timeLine': Array<number>;
    /**
     * 
     * @type {Array<TCountryChartData>}
     * @memberof RtmpServerGraphResponse
     */
    'countries': Array<TCountryChartData>;
}

export const RtmpServerGraphResponseTypeEnum = {
    Performance: 'performance',
    Network: 'network',
    Cpu: 'cpu',
    Ram: 'ram',
    DeliveredPackages: 'deliveredPackages'
} as const;

export type RtmpServerGraphResponseTypeEnum = typeof RtmpServerGraphResponseTypeEnum[keyof typeof RtmpServerGraphResponseTypeEnum];

/**
 * 
 * @export
 * @interface RtmpServerListItem
 */
export interface RtmpServerListItem {
    /**
     * City
     * @type {string}
     * @memberof RtmpServerListItem
     */
    'city': string;
    /**
     * Rtmp url
     * @type {string}
     * @memberof RtmpServerListItem
     */
    'url': string;
    /**
     * Country
     * @type {CountryItem}
     * @memberof RtmpServerListItem
     */
    'country': CountryItem;
    /**
     * Network load of the selected time
     * @type {RtmpServerLoading}
     * @memberof RtmpServerListItem
     */
    'network': RtmpServerLoading;
    /**
     * CPU load of the selected time
     * @type {RtmpServerLoading}
     * @memberof RtmpServerListItem
     */
    'cpu': RtmpServerLoading;
    /**
     * RAM load of the selected time
     * @type {RtmpServerLoading}
     * @memberof RtmpServerListItem
     */
    'ram': RtmpServerLoading;
    /**
     * Quality connection of pool
     * @type {number}
     * @memberof RtmpServerListItem
     */
    'quality': number;
    /**
     * Sort index
     * @type {number}
     * @memberof RtmpServerListItem
     */
    'index': number;
    /**
     * Quality in string format
     * @type {string}
     * @memberof RtmpServerListItem
     */
    'serverStatus': RtmpServerListItemServerStatusEnum;
    /**
     * Quality array
     * @type {Array<RtmpServerPlatformQuality>}
     * @memberof RtmpServerListItem
     */
    'platforms': Array<RtmpServerPlatformQuality>;
}

export const RtmpServerListItemServerStatusEnum = {
    Good: 'good',
    Problem: 'problem',
    Bad: 'bad'
} as const;

export type RtmpServerListItemServerStatusEnum = typeof RtmpServerListItemServerStatusEnum[keyof typeof RtmpServerListItemServerStatusEnum];

/**
 * 
 * @export
 * @interface RtmpServerListResponse
 */
export interface RtmpServerListResponse {
    /**
     * Array of items
     * @type {Array<RtmpServerListItem>}
     * @memberof RtmpServerListResponse
     */
    'results': Array<RtmpServerListItem>;
}
/**
 * 
 * @export
 * @interface RtmpServerLoading
 */
export interface RtmpServerLoading {
    /**
     * Average
     * @type {number}
     * @memberof RtmpServerLoading
     */
    'avg': number;
    /**
     * Max
     * @type {number}
     * @memberof RtmpServerLoading
     */
    'max': number;
}
/**
 * 
 * @export
 * @interface RtmpServerLocationResponse
 */
export interface RtmpServerLocationResponse {
    /**
     * Location name
     * @type {string}
     * @memberof RtmpServerLocationResponse
     */
    'name': string;
    /**
     * Host
     * @type {string}
     * @memberof RtmpServerLocationResponse
     */
    'host': string;
    /**
     * Url for connect
     * @type {string}
     * @memberof RtmpServerLocationResponse
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface RtmpServerPlatformQuality
 */
export interface RtmpServerPlatformQuality {
    /**
     * Platform id
     * @type {number}
     * @memberof RtmpServerPlatformQuality
     */
    'id': number;
    /**
     * Quality connection
     * @type {number}
     * @memberof RtmpServerPlatformQuality
     */
    'quality': number;
    /**
     * Title of platform
     * @type {string}
     * @memberof RtmpServerPlatformQuality
     */
    'title': string;
    /**
     * Quality in string format
     * @type {string}
     * @memberof RtmpServerPlatformQuality
     */
    'status': RtmpServerPlatformQualityStatusEnum;
    /**
     * Reconnect
     * @type {number}
     * @memberof RtmpServerPlatformQuality
     */
    'reconnect': number;
}

export const RtmpServerPlatformQualityStatusEnum = {
    Good: 'good',
    Problem: 'problem',
    Bad: 'bad'
} as const;

export type RtmpServerPlatformQualityStatusEnum = typeof RtmpServerPlatformQualityStatusEnum[keyof typeof RtmpServerPlatformQualityStatusEnum];

/**
 * 
 * @export
 * @interface RtmpServerStateItem
 */
export interface RtmpServerStateItem {
    /**
     * City
     * @type {string}
     * @memberof RtmpServerStateItem
     */
    'city': string;
    /**
     * Country
     * @type {CountryItem}
     * @memberof RtmpServerStateItem
     */
    'country': CountryItem;
    /**
     * Latitude
     * @type {number}
     * @memberof RtmpServerStateItem
     */
    'lat': number;
    /**
     * Longitude
     * @type {number}
     * @memberof RtmpServerStateItem
     */
    'long': number;
    /**
     * Network load of the selected time
     * @type {RtmpServerLoading}
     * @memberof RtmpServerStateItem
     */
    'network': RtmpServerLoading;
    /**
     * CPU load of the selected time
     * @type {RtmpServerLoading}
     * @memberof RtmpServerStateItem
     */
    'cpu': RtmpServerLoading;
    /**
     * RAM load of the selected time
     * @type {RtmpServerLoading}
     * @memberof RtmpServerStateItem
     */
    'ram': RtmpServerLoading;
    /**
     * Quality connection of pool
     * @type {number}
     * @memberof RtmpServerStateItem
     */
    'quality': number;
    /**
     * Quality in string format
     * @type {string}
     * @memberof RtmpServerStateItem
     */
    'serverStatus': RtmpServerStateItemServerStatusEnum;
    /**
     * Quality array
     * @type {Array<RtmpServerPlatformQuality>}
     * @memberof RtmpServerStateItem
     */
    'platforms': Array<RtmpServerPlatformQuality>;
}

export const RtmpServerStateItemServerStatusEnum = {
    Good: 'good',
    Problem: 'problem',
    Bad: 'bad'
} as const;

export type RtmpServerStateItemServerStatusEnum = typeof RtmpServerStateItemServerStatusEnum[keyof typeof RtmpServerStateItemServerStatusEnum];

/**
 * 
 * @export
 * @interface RtmpServerStateResponse
 */
export interface RtmpServerStateResponse {
    /**
     * Array of items
     * @type {Array<RtmpServerStateItem>}
     * @memberof RtmpServerStateResponse
     */
    'results': Array<RtmpServerStateItem>;
}
/**
 * 
 * @export
 * @interface SetRecordStreamRequest
 */
export interface SetRecordStreamRequest {
    /**
     * Version
     * @type {string}
     * @memberof SetRecordStreamRequest
     */
    'v': SetRecordStreamRequestVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof SetRecordStreamRequest
     */
    'language': SetRecordStreamRequestLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof SetRecordStreamRequest
     */
    'project_id': number;
    /**
     * Record status
     * @type {boolean}
     * @memberof SetRecordStreamRequest
     */
    'record': boolean;
}

export const SetRecordStreamRequestVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type SetRecordStreamRequestVEnum = typeof SetRecordStreamRequestVEnum[keyof typeof SetRecordStreamRequestVEnum];
export const SetRecordStreamRequestLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SetRecordStreamRequestLanguageEnum = typeof SetRecordStreamRequestLanguageEnum[keyof typeof SetRecordStreamRequestLanguageEnum];

/**
 * 
 * @export
 * @interface SiteAuthCentrifugeResponse
 */
export interface SiteAuthCentrifugeResponse {
    /**
     * Access token
     * @type {string}
     * @memberof SiteAuthCentrifugeResponse
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface SiteAuthExchangeRequest
 */
export interface SiteAuthExchangeRequest {
    /**
     * Version
     * @type {string}
     * @memberof SiteAuthExchangeRequest
     */
    'v': SiteAuthExchangeRequestVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof SiteAuthExchangeRequest
     */
    'language': SiteAuthExchangeRequestLanguageEnum;
    /**
     * Auth code for exchange of token
     * @type {string}
     * @memberof SiteAuthExchangeRequest
     */
    'code': string;
    /**
     * userAgent
     * @type {string}
     * @memberof SiteAuthExchangeRequest
     */
    'userAgent': string;
    /**
     * Fingerprint
     * @type {string}
     * @memberof SiteAuthExchangeRequest
     */
    'fingerprint'?: string;
    /**
     * App oauth
     * @type {string}
     * @memberof SiteAuthExchangeRequest
     */
    'app': SiteAuthExchangeRequestAppEnum;
}

export const SiteAuthExchangeRequestVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type SiteAuthExchangeRequestVEnum = typeof SiteAuthExchangeRequestVEnum[keyof typeof SiteAuthExchangeRequestVEnum];
export const SiteAuthExchangeRequestLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SiteAuthExchangeRequestLanguageEnum = typeof SiteAuthExchangeRequestLanguageEnum[keyof typeof SiteAuthExchangeRequestLanguageEnum];
export const SiteAuthExchangeRequestAppEnum = {
    Site: 'site',
    Admin: 'admin',
    Mobile: 'mobile',
    Desktop: 'desktop'
} as const;

export type SiteAuthExchangeRequestAppEnum = typeof SiteAuthExchangeRequestAppEnum[keyof typeof SiteAuthExchangeRequestAppEnum];

/**
 * 
 * @export
 * @interface SiteBlogPageTagResponse
 */
export interface SiteBlogPageTagResponse {
    /**
     * 
     * @type {BlogPageSiteResponseId}
     * @memberof SiteBlogPageTagResponse
     */
    '_id': BlogPageSiteResponseId;
    /**
     * Language for indexing
     * @type {string}
     * @memberof SiteBlogPageTagResponse
     */
    'language': SiteBlogPageTagResponseLanguageEnum;
    /**
     * Language ISO
     * @type {string}
     * @memberof SiteBlogPageTagResponse
     */
    'language_iso': SiteBlogPageTagResponseLanguageIsoEnum;
    /**
     * Title
     * @type {string}
     * @memberof SiteBlogPageTagResponse
     */
    'title': string;
    /**
     * Count of user
     * @type {number}
     * @memberof SiteBlogPageTagResponse
     */
    'count_use': number;
}

export const SiteBlogPageTagResponseLanguageEnum = {
    Russian: 'russian',
    English: 'english',
    None: 'none'
} as const;

export type SiteBlogPageTagResponseLanguageEnum = typeof SiteBlogPageTagResponseLanguageEnum[keyof typeof SiteBlogPageTagResponseLanguageEnum];
export const SiteBlogPageTagResponseLanguageIsoEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SiteBlogPageTagResponseLanguageIsoEnum = typeof SiteBlogPageTagResponseLanguageIsoEnum[keyof typeof SiteBlogPageTagResponseLanguageIsoEnum];

/**
 * 
 * @export
 * @interface SiteChannelStatusResponse
 */
export interface SiteChannelStatusResponse {
    /**
     * message
     * @type {string}
     * @memberof SiteChannelStatusResponse
     */
    'message': string | null;
}
/**
 * 
 * @export
 * @interface SiteGetPolicyStructure
 */
export interface SiteGetPolicyStructure {
    /**
     * Policy page key word
     * @type {string}
     * @memberof SiteGetPolicyStructure
     */
    'results': SiteGetPolicyStructureResultsEnum;
}

export const SiteGetPolicyStructureResultsEnum = {
    RefundPolicy: 'refund-policy',
    TermsOfUse: 'terms-of-use',
    UsingCookie: 'using-cookie',
    AcceptableUse: 'acceptable-use',
    PrivacyNotice: 'privacy-notice'
} as const;

export type SiteGetPolicyStructureResultsEnum = typeof SiteGetPolicyStructureResultsEnum[keyof typeof SiteGetPolicyStructureResultsEnum];

/**
 * 
 * @export
 * @interface SiteGetPolicyStructureDto
 */
export interface SiteGetPolicyStructureDto {
    /**
     * Array of policy pages
     * @type {Array<SiteGetPolicyStructure>}
     * @memberof SiteGetPolicyStructureDto
     */
    'results': Array<SiteGetPolicyStructure>;
}
/**
 * 
 * @export
 * @interface SiteGetShortChannelItem
 */
export interface SiteGetShortChannelItem {
    /**
     * channel_id
     * @type {number}
     * @memberof SiteGetShortChannelItem
     */
    'channel_id': number;
    /**
     * type
     * @type {string}
     * @memberof SiteGetShortChannelItem
     */
    'type': string;
    /**
     * name
     * @type {string}
     * @memberof SiteGetShortChannelItem
     */
    'name': string;
    /**
     * photo_default
     * @type {string}
     * @memberof SiteGetShortChannelItem
     */
    'photo_default': string | null;
}
/**
 * 
 * @export
 * @interface SiteGetShortChannelResponse
 */
export interface SiteGetShortChannelResponse {
    /**
     * Array of items
     * @type {Array<SiteGetShortChannelItem>}
     * @memberof SiteGetShortChannelResponse
     */
    'results': Array<SiteGetShortChannelItem>;
}
/**
 * 
 * @export
 * @interface SiteLiveRestreamCentrifugeItemV2
 */
export interface SiteLiveRestreamCentrifugeItemV2 {
    /**
     * Token for authentication channel
     * @type {string}
     * @memberof SiteLiveRestreamCentrifugeItemV2
     */
    'token': string;
    /**
     * Channel for subscription
     * @type {string}
     * @memberof SiteLiveRestreamCentrifugeItemV2
     */
    'channel': string;
}
/**
 * 
 * @export
 * @interface SiteLiveRestreamCentrifugeResponse
 */
export interface SiteLiveRestreamCentrifugeResponse {
    /**
     * Event for restream update url
     * @type {SiteLiveRestreamCentrifugeItemV2}
     * @memberof SiteLiveRestreamCentrifugeResponse
     */
    'update_url_channel': SiteLiveRestreamCentrifugeItemV2;
    /**
     * Event for restream update viewers
     * @type {SiteLiveRestreamCentrifugeItemV2}
     * @memberof SiteLiveRestreamCentrifugeResponse
     */
    'update_stats_channel': SiteLiveRestreamCentrifugeItemV2;
}
/**
 * 
 * @export
 * @interface SiteLiveRestreamInfoItem
 */
export interface SiteLiveRestreamInfoItem {
    /**
     * Restream id
     * @type {number}
     * @memberof SiteLiveRestreamInfoItem
     */
    'id': number;
    /**
     * Channel id
     * @type {number}
     * @memberof SiteLiveRestreamInfoItem
     */
    'channel_id': number;
    /**
     * Channel name
     * @type {string}
     * @memberof SiteLiveRestreamInfoItem
     */
    'channel_name': string;
    /**
     * Channel type
     * @type {string}
     * @memberof SiteLiveRestreamInfoItem
     */
    'channel_type': string;
    /**
     * Stream url
     * @type {string}
     * @memberof SiteLiveRestreamInfoItem
     */
    'url'?: string;
    /**
     * Count of viewers
     * @type {number}
     * @memberof SiteLiveRestreamInfoItem
     */
    'viewer'?: number;
    /**
     * Count of message
     * @type {number}
     * @memberof SiteLiveRestreamInfoItem
     */
    'message'?: number;
    /**
     * Count of like
     * @type {number}
     * @memberof SiteLiveRestreamInfoItem
     */
    'like'?: number;
}
/**
 * 
 * @export
 * @interface SiteLiveRestreamsInfoResponse
 */
export interface SiteLiveRestreamsInfoResponse {
    /**
     * Array of items
     * @type {Array<SiteLiveRestreamInfoItem>}
     * @memberof SiteLiveRestreamsInfoResponse
     */
    'results': Array<SiteLiveRestreamInfoItem>;
    /**
     * 
     * @type {SiteLiveRestreamCentrifugeResponse}
     * @memberof SiteLiveRestreamsInfoResponse
     */
    'centrifuge': SiteLiveRestreamCentrifugeResponse;
}
/**
 * 
 * @export
 * @interface SiteLogoutAuthRequest
 */
export interface SiteLogoutAuthRequest {
    /**
     * App oauth
     * @type {string}
     * @memberof SiteLogoutAuthRequest
     */
    'app': SiteLogoutAuthRequestAppEnum;
    /**
     * Refresh token
     * @type {string}
     * @memberof SiteLogoutAuthRequest
     */
    'refresh': string;
}

export const SiteLogoutAuthRequestAppEnum = {
    Site: 'site',
    Admin: 'admin',
    Mobile: 'mobile',
    Desktop: 'desktop'
} as const;

export type SiteLogoutAuthRequestAppEnum = typeof SiteLogoutAuthRequestAppEnum[keyof typeof SiteLogoutAuthRequestAppEnum];

/**
 * 
 * @export
 * @interface SiteMarkReadHistoryRequest
 */
export interface SiteMarkReadHistoryRequest {
    /**
     * Id of page in mongodb
     * @type {Array<string>}
     * @memberof SiteMarkReadHistoryRequest
     */
    'notify_history_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface SiteMarkReadHistoryResponse
 */
export interface SiteMarkReadHistoryResponse {
    /**
     * Count read
     * @type {number}
     * @memberof SiteMarkReadHistoryResponse
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface SiteNotifyUserResponse
 */
export interface SiteNotifyUserResponse {
    /**
     * User id
     * @type {number}
     * @memberof SiteNotifyUserResponse
     */
    'user_id': number;
    /**
     * Channels
     * @type {NotifyUserChannels}
     * @memberof SiteNotifyUserResponse
     */
    'channels': NotifyUserChannels;
    /**
     * Relation
     * @type {NotifyUserRelation}
     * @memberof SiteNotifyUserResponse
     */
    'relation': NotifyUserRelation;
}
/**
 * 
 * @export
 * @interface SitePlannedResponse
 */
export interface SitePlannedResponse {
    /**
     * Planned item
     * @type {PlannedItemResponse}
     * @memberof SitePlannedResponse
     */
    'planned'?: PlannedItemResponse;
}
/**
 * 
 * @export
 * @interface SitePlatformsSupportedItem
 */
export interface SitePlatformsSupportedItem {
    /**
     * id
     * @type {number}
     * @memberof SitePlatformsSupportedItem
     */
    'id': number;
    /**
     * The possibility of adding a platform
     * @type {number}
     * @memberof SitePlatformsSupportedItem
     */
    'is_adding': number;
    /**
     * title
     * @type {string}
     * @memberof SitePlatformsSupportedItem
     */
    'title': string;
    /**
     * Extension
     * @type {string}
     * @memberof SitePlatformsSupportedItem
     */
    'extension': SitePlatformsSupportedItemExtensionEnum;
    /**
     * url
     * @type {string}
     * @memberof SitePlatformsSupportedItem
     */
    'url': string;
    /**
     * type
     * @type {string}
     * @memberof SitePlatformsSupportedItem
     */
    'type': string;
    /**
     * oauth
     * @type {number}
     * @memberof SitePlatformsSupportedItem
     */
    'oauth': number;
    /**
     * read_chat
     * @type {number}
     * @memberof SitePlatformsSupportedItem
     */
    'read_chat': number;
    /**
     * write_chat
     * @type {number}
     * @memberof SitePlatformsSupportedItem
     */
    'write_chat': number;
    /**
     * edit_name
     * @type {number}
     * @memberof SitePlatformsSupportedItem
     */
    'edit_name': number;
    /**
     * set_title
     * @type {number}
     * @memberof SitePlatformsSupportedItem
     */
    'set_title': number;
    /**
     * set_description
     * @type {number}
     * @memberof SitePlatformsSupportedItem
     */
    'set_description': number;
    /**
     * created_stream
     * @type {number}
     * @memberof SitePlatformsSupportedItem
     */
    'created_stream': number;
    /**
     * rtmp_url
     * @type {number}
     * @memberof SitePlatformsSupportedItem
     */
    'rtmp_url': number;
    /**
     * rtmp_key
     * @type {number}
     * @memberof SitePlatformsSupportedItem
     */
    'rtmp_key': number;
    /**
     * planned
     * @type {number}
     * @memberof SitePlatformsSupportedItem
     */
    'planned': number;
    /**
     * options
     * @type {number}
     * @memberof SitePlatformsSupportedItem
     */
    'options': number;
    /**
     * url_stream
     * @type {number}
     * @memberof SitePlatformsSupportedItem
     */
    'url_stream': number;
    /**
     * viewers
     * @type {number}
     * @memberof SitePlatformsSupportedItem
     */
    'viewers': number;
    /**
     * messages
     * @type {number}
     * @memberof SitePlatformsSupportedItem
     */
    'messages': number;
    /**
     * like
     * @type {number}
     * @memberof SitePlatformsSupportedItem
     */
    'like': number;
}

export const SitePlatformsSupportedItemExtensionEnum = {
    Png: 'png',
    Svg: 'svg'
} as const;

export type SitePlatformsSupportedItemExtensionEnum = typeof SitePlatformsSupportedItemExtensionEnum[keyof typeof SitePlatformsSupportedItemExtensionEnum];

/**
 * 
 * @export
 * @interface SitePlatformsSupportedResponse
 */
export interface SitePlatformsSupportedResponse {
    /**
     * Array of items
     * @type {Array<SitePlatformsSupportedItem>}
     * @memberof SitePlatformsSupportedResponse
     */
    'results': Array<SitePlatformsSupportedItem>;
}
/**
 * 
 * @export
 * @interface SitePromoApplyResponse
 */
export interface SitePromoApplyResponse {
    /**
     * Result apply code
     * @type {string}
     * @memberof SitePromoApplyResponse
     */
    'result': SitePromoApplyResponseResultEnum;
}

export const SitePromoApplyResponseResultEnum = {
    TopUp: 'top_up',
    Tariff: 'tariff'
} as const;

export type SitePromoApplyResponseResultEnum = typeof SitePromoApplyResponseResultEnum[keyof typeof SitePromoApplyResponseResultEnum];

/**
 * 
 * @export
 * @interface SitePromoCheckResponse
 */
export interface SitePromoCheckResponse {
    /**
     * Code for auth in app
     * @type {string}
     * @memberof SitePromoCheckResponse
     */
    'name': string;
    /**
     * Id entity of type
     * @type {number}
     * @memberof SitePromoCheckResponse
     */
    'id': number;
    /**
     * Type promo code
     * @type {string}
     * @memberof SitePromoCheckResponse
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface SiteRefreshAuthBodyRequest
 */
export interface SiteRefreshAuthBodyRequest {
    /**
     * Version
     * @type {string}
     * @memberof SiteRefreshAuthBodyRequest
     */
    'v': SiteRefreshAuthBodyRequestVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof SiteRefreshAuthBodyRequest
     */
    'language': SiteRefreshAuthBodyRequestLanguageEnum;
    /**
     * App oauth
     * @type {string}
     * @memberof SiteRefreshAuthBodyRequest
     */
    'app': SiteRefreshAuthBodyRequestAppEnum;
    /**
     * Refresh token
     * @type {string}
     * @memberof SiteRefreshAuthBodyRequest
     */
    'refresh': string;
    /**
     * Fingerprint
     * @type {string}
     * @memberof SiteRefreshAuthBodyRequest
     */
    'fingerprint'?: string;
}

export const SiteRefreshAuthBodyRequestVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type SiteRefreshAuthBodyRequestVEnum = typeof SiteRefreshAuthBodyRequestVEnum[keyof typeof SiteRefreshAuthBodyRequestVEnum];
export const SiteRefreshAuthBodyRequestLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SiteRefreshAuthBodyRequestLanguageEnum = typeof SiteRefreshAuthBodyRequestLanguageEnum[keyof typeof SiteRefreshAuthBodyRequestLanguageEnum];
export const SiteRefreshAuthBodyRequestAppEnum = {
    Site: 'site',
    Admin: 'admin',
    Mobile: 'mobile',
    Desktop: 'desktop'
} as const;

export type SiteRefreshAuthBodyRequestAppEnum = typeof SiteRefreshAuthBodyRequestAppEnum[keyof typeof SiteRefreshAuthBodyRequestAppEnum];

/**
 * 
 * @export
 * @interface SiteScreenNotifyUserResponse
 */
export interface SiteScreenNotifyUserResponse {
    /**
     * Level of notify. Default is info
     * @type {string}
     * @memberof SiteScreenNotifyUserResponse
     */
    'type': SiteScreenNotifyUserResponseTypeEnum;
    /**
     * Title of notify
     * @type {string}
     * @memberof SiteScreenNotifyUserResponse
     */
    'title'?: string;
    /**
     * Text of notify
     * @type {string}
     * @memberof SiteScreenNotifyUserResponse
     */
    'text': string;
    /**
     * Array of texts
     * @type {Array<InternalNotifyTypeAction>}
     * @memberof SiteScreenNotifyUserResponse
     */
    'actions'?: Array<InternalNotifyTypeAction>;
}

export const SiteScreenNotifyUserResponseTypeEnum = {
    Debug: 'debug',
    Info: 'info',
    Warning: 'warning',
    Error: 'error'
} as const;

export type SiteScreenNotifyUserResponseTypeEnum = typeof SiteScreenNotifyUserResponseTypeEnum[keyof typeof SiteScreenNotifyUserResponseTypeEnum];

/**
 * 
 * @export
 * @interface SiteSearchChannelCredentialDto
 */
export interface SiteSearchChannelCredentialDto {
    /**
     * Account status of credentials
     * @type {SiteSearchChannelTokensDto}
     * @memberof SiteSearchChannelCredentialDto
     */
    'account': SiteSearchChannelTokensDto;
    /**
     * Groups status of credentials
     * @type {SiteSearchChannelTokensDto}
     * @memberof SiteSearchChannelCredentialDto
     */
    'group': SiteSearchChannelTokensDto;
}
/**
 * 
 * @export
 * @interface SiteSearchChannelCredentialsDto
 */
export interface SiteSearchChannelCredentialsDto {
    /**
     * 
     * @type {number}
     * @memberof SiteSearchChannelCredentialsDto
     */
    'cid': number;
    /**
     * 
     * @type {string}
     * @memberof SiteSearchChannelCredentialsDto
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof SiteSearchChannelCredentialsDto
     */
    'status': number;
    /**
     * 
     * @type {number}
     * @memberof SiteSearchChannelCredentialsDto
     */
    'role': number;
    /**
     * 
     * @type {boolean}
     * @memberof SiteSearchChannelCredentialsDto
     */
    'personal': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SiteSearchChannelCredentialsDto
     */
    'update': boolean;
}
/**
 * 
 * @export
 * @interface SiteSearchChannelItem
 */
export interface SiteSearchChannelItem {
    /**
     * name
     * @type {string}
     * @memberof SiteSearchChannelItem
     */
    'name': string;
    /**
     * name
     * @type {string}
     * @memberof SiteSearchChannelItem
     */
    'id': string;
    /**
     * Transcoder id
     * @type {number}
     * @memberof SiteSearchChannelItem
     */
    'transcoderId'?: number;
    /**
     * group_id
     * @type {number}
     * @memberof SiteSearchChannelItem
     */
    'group_id': number;
    /**
     * type
     * @type {string}
     * @memberof SiteSearchChannelItem
     */
    'type': string;
    /**
     * photo_default
     * @type {string}
     * @memberof SiteSearchChannelItem
     */
    'photo_default': string;
    /**
     * sell
     * @type {boolean}
     * @memberof SiteSearchChannelItem
     */
    'sell': boolean;
    /**
     * price
     * @type {number}
     * @memberof SiteSearchChannelItem
     */
    'price': number;
    /**
     * live
     * @type {boolean}
     * @memberof SiteSearchChannelItem
     */
    'live': boolean;
    /**
     * status
     * @type {string}
     * @memberof SiteSearchChannelItem
     */
    'status': SiteSearchChannelItemStatusEnum;
    /**
     * user_id
     * @type {number}
     * @memberof SiteSearchChannelItem
     */
    'user_id': number;
    /**
     * active
     * @type {boolean}
     * @memberof SiteSearchChannelItem
     */
    'active': boolean;
    /**
     * guestsNum
     * @type {number}
     * @memberof SiteSearchChannelItem
     */
    'guestsNum': number;
    /**
     * guestRights
     * @type {number}
     * @memberof SiteSearchChannelItem
     */
    'guestRights': number | null;
    /**
     * usageType
     * @type {number}
     * @memberof SiteSearchChannelItem
     */
    'usageType': number;
    /**
     * companyRole
     * @type {number}
     * @memberof SiteSearchChannelItem
     */
    'companyRole': number | null;
    /**
     * threads
     * @type {number}
     * @memberof SiteSearchChannelItem
     */
    'threads': number;
    /**
     * 
     * @type {SiteSearchChannelItemStreamInfo}
     * @memberof SiteSearchChannelItem
     */
    'streamInfo': SiteSearchChannelItemStreamInfo;
    /**
     * rtmp
     * @type {SiteSearchChannelRtmpDto}
     * @memberof SiteSearchChannelItem
     */
    'rtmp': SiteSearchChannelRtmpDto | null;
    /**
     * credentials
     * @type {Array<SiteSearchChannelCredentialsDto>}
     * @memberof SiteSearchChannelItem
     */
    'credentials': Array<SiteSearchChannelCredentialsDto> | null;
    /**
     * Tokens
     * @type {SiteSearchChannelCredentialDto}
     * @memberof SiteSearchChannelItem
     */
    'tokens': SiteSearchChannelCredentialDto;
    /**
     * live_users
     * @type {Array<SiteSearchChannelLiveUserDto>}
     * @memberof SiteSearchChannelItem
     */
    'live_users'?: Array<SiteSearchChannelLiveUserDto>;
    /**
     * Platform
     * @type {SiteSearchChannelPlatformDto}
     * @memberof SiteSearchChannelItem
     */
    'platform': SiteSearchChannelPlatformDto;
}

export const SiteSearchChannelItemStatusEnum = {
    Init: 'init',
    Pending: 'pending',
    Error: 'error',
    Live: 'live',
    Offline: 'offline',
    Busy: 'busy'
} as const;

export type SiteSearchChannelItemStatusEnum = typeof SiteSearchChannelItemStatusEnum[keyof typeof SiteSearchChannelItemStatusEnum];

/**
 * @type SiteSearchChannelItemStreamInfo
 * streamInfo
 * @export
 */
export type SiteSearchChannelItemStreamInfo = ChannelDefaultInfoDto | ChannelOkInfoDto | ChannelTrovoInfoDto | ChannelTwitchInfoDto | ChannelVkInfoDto | ChannelYoutubeInfoDto;

/**
 * 
 * @export
 * @interface SiteSearchChannelLiveUserDto
 */
export interface SiteSearchChannelLiveUserDto {
    /**
     * 
     * @type {number}
     * @memberof SiteSearchChannelLiveUserDto
     */
    'restreamId': number;
    /**
     * 
     * @type {number}
     * @memberof SiteSearchChannelLiveUserDto
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof SiteSearchChannelLiveUserDto
     */
    'video'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SiteSearchChannelLiveUserDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SiteSearchChannelLiveUserDto
     */
    'photo': string;
}
/**
 * 
 * @export
 * @interface SiteSearchChannelPlatformDto
 */
export interface SiteSearchChannelPlatformDto {
    /**
     * Title
     * @type {string}
     * @memberof SiteSearchChannelPlatformDto
     */
    'title': string;
    /**
     * Type platform
     * @type {string}
     * @memberof SiteSearchChannelPlatformDto
     */
    'type': string;
    /**
     * Url
     * @type {string}
     * @memberof SiteSearchChannelPlatformDto
     */
    'url': string;
    /**
     * extension
     * @type {string}
     * @memberof SiteSearchChannelPlatformDto
     */
    'extension': SiteSearchChannelPlatformDtoExtensionEnum;
    /**
     * Is edit name
     * @type {number}
     * @memberof SiteSearchChannelPlatformDto
     */
    'edit_name': number;
}

export const SiteSearchChannelPlatformDtoExtensionEnum = {
    Png: 'png',
    Svg: 'svg'
} as const;

export type SiteSearchChannelPlatformDtoExtensionEnum = typeof SiteSearchChannelPlatformDtoExtensionEnum[keyof typeof SiteSearchChannelPlatformDtoExtensionEnum];

/**
 * 
 * @export
 * @interface SiteSearchChannelPlatformsDto
 */
export interface SiteSearchChannelPlatformsDto {
    /**
     * Id
     * @type {number}
     * @memberof SiteSearchChannelPlatformsDto
     */
    'id': number;
    /**
     * Type
     * @type {string}
     * @memberof SiteSearchChannelPlatformsDto
     */
    'type': string;
    /**
     * Title
     * @type {string}
     * @memberof SiteSearchChannelPlatformsDto
     */
    'title': string;
    /**
     * Is edit name
     * @type {number}
     * @memberof SiteSearchChannelPlatformsDto
     */
    'edit_name': number;
}
/**
 * 
 * @export
 * @interface SiteSearchChannelResponse
 */
export interface SiteSearchChannelResponse {
    /**
     * Array of items
     * @type {Array<SiteSearchChannelItem>}
     * @memberof SiteSearchChannelResponse
     */
    'results': Array<SiteSearchChannelItem>;
    /**
     * 
     * @type {Array<SiteSearchChannelPlatformsDto>}
     * @memberof SiteSearchChannelResponse
     */
    'platforms': Array<SiteSearchChannelPlatformsDto>;
    /**
     * 
     * @type {number}
     * @memberof SiteSearchChannelResponse
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof SiteSearchChannelResponse
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof SiteSearchChannelResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface SiteSearchChannelRtmpDto
 */
export interface SiteSearchChannelRtmpDto {
    /**
     * 
     * @type {string}
     * @memberof SiteSearchChannelRtmpDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SiteSearchChannelRtmpDto
     */
    'path'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SiteSearchChannelRtmpDto
     */
    'port'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SiteSearchChannelRtmpDto
     */
    'query'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SiteSearchChannelRtmpDto
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof SiteSearchChannelRtmpDto
     */
    'protocol': string;
}
/**
 * 
 * @export
 * @interface SiteSearchChannelTokensDto
 */
export interface SiteSearchChannelTokensDto {
    /**
     * Status of tokens
     * @type {string}
     * @memberof SiteSearchChannelTokensDto
     */
    'status': SiteSearchChannelTokensDtoStatusEnum;
}

export const SiteSearchChannelTokensDtoStatusEnum = {
    Unused: 'unused',
    Invalid: 'invalid',
    Deprecated: 'deprecated',
    Valid: 'valid'
} as const;

export type SiteSearchChannelTokensDtoStatusEnum = typeof SiteSearchChannelTokensDtoStatusEnum[keyof typeof SiteSearchChannelTokensDtoStatusEnum];

/**
 * 
 * @export
 * @interface SiteSetNameRequest
 */
export interface SiteSetNameRequest {
    /**
     * Version
     * @type {string}
     * @memberof SiteSetNameRequest
     */
    'v': SiteSetNameRequestVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof SiteSetNameRequest
     */
    'language': SiteSetNameRequestLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof SiteSetNameRequest
     */
    'project_id': number;
    /**
     * Channel id
     * @type {number}
     * @memberof SiteSetNameRequest
     */
    'channel_id': number;
    /**
     * 
     * @type {string}
     * @memberof SiteSetNameRequest
     */
    'name': string;
}

export const SiteSetNameRequestVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type SiteSetNameRequestVEnum = typeof SiteSetNameRequestVEnum[keyof typeof SiteSetNameRequestVEnum];
export const SiteSetNameRequestLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SiteSetNameRequestLanguageEnum = typeof SiteSetNameRequestLanguageEnum[keyof typeof SiteSetNameRequestLanguageEnum];

/**
 * 
 * @export
 * @interface SiteSetNotifyUserRequest
 */
export interface SiteSetNotifyUserRequest {
    /**
     * Project id
     * @type {number}
     * @memberof SiteSetNotifyUserRequest
     */
    'project_id': number;
    /**
     * Notify channel
     * @type {string}
     * @memberof SiteSetNotifyUserRequest
     */
    'notify_channel': SiteSetNotifyUserRequestNotifyChannelEnum;
    /**
     * Notify category
     * @type {string}
     * @memberof SiteSetNotifyUserRequest
     */
    'notify_category': SiteSetNotifyUserRequestNotifyCategoryEnum;
    /**
     * Set status
     * @type {string}
     * @memberof SiteSetNotifyUserRequest
     */
    'status': SiteSetNotifyUserRequestStatusEnum;
}

export const SiteSetNotifyUserRequestNotifyChannelEnum = {
    Telegram: 'telegram',
    Cabinet: 'cabinet',
    Mobile: 'mobile'
} as const;

export type SiteSetNotifyUserRequestNotifyChannelEnum = typeof SiteSetNotifyUserRequestNotifyChannelEnum[keyof typeof SiteSetNotifyUserRequestNotifyChannelEnum];
export const SiteSetNotifyUserRequestNotifyCategoryEnum = {
    Important: 'important',
    Stream: 'stream'
} as const;

export type SiteSetNotifyUserRequestNotifyCategoryEnum = typeof SiteSetNotifyUserRequestNotifyCategoryEnum[keyof typeof SiteSetNotifyUserRequestNotifyCategoryEnum];
export const SiteSetNotifyUserRequestStatusEnum = {
    Enable: 'enable',
    Disable: 'disable'
} as const;

export type SiteSetNotifyUserRequestStatusEnum = typeof SiteSetNotifyUserRequestStatusEnum[keyof typeof SiteSetNotifyUserRequestStatusEnum];

/**
 * 
 * @export
 * @interface SiteSetPlannedRequest
 */
export interface SiteSetPlannedRequest {
    /**
     * Version
     * @type {string}
     * @memberof SiteSetPlannedRequest
     */
    'v': SiteSetPlannedRequestVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof SiteSetPlannedRequest
     */
    'language': SiteSetPlannedRequestLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof SiteSetPlannedRequest
     */
    'project_id': number;
    /**
     * Channel id
     * @type {number}
     * @memberof SiteSetPlannedRequest
     */
    'channel_id': number;
    /**
     * 
     * @type {string}
     * @memberof SiteSetPlannedRequest
     */
    'id'?: string;
}

export const SiteSetPlannedRequestVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type SiteSetPlannedRequestVEnum = typeof SiteSetPlannedRequestVEnum[keyof typeof SiteSetPlannedRequestVEnum];
export const SiteSetPlannedRequestLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SiteSetPlannedRequestLanguageEnum = typeof SiteSetPlannedRequestLanguageEnum[keyof typeof SiteSetPlannedRequestLanguageEnum];

/**
 * 
 * @export
 * @interface SiteSetTranscoderRequest
 */
export interface SiteSetTranscoderRequest {
    /**
     * Version
     * @type {string}
     * @memberof SiteSetTranscoderRequest
     */
    'v': SiteSetTranscoderRequestVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof SiteSetTranscoderRequest
     */
    'language': SiteSetTranscoderRequestLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof SiteSetTranscoderRequest
     */
    'project_id': number;
    /**
     * Channel id
     * @type {number}
     * @memberof SiteSetTranscoderRequest
     */
    'channel_id': number;
    /**
     * Transcoder id
     * @type {number}
     * @memberof SiteSetTranscoderRequest
     */
    'transcoder_id'?: number;
}

export const SiteSetTranscoderRequestVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type SiteSetTranscoderRequestVEnum = typeof SiteSetTranscoderRequestVEnum[keyof typeof SiteSetTranscoderRequestVEnum];
export const SiteSetTranscoderRequestLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SiteSetTranscoderRequestLanguageEnum = typeof SiteSetTranscoderRequestLanguageEnum[keyof typeof SiteSetTranscoderRequestLanguageEnum];

/**
 * 
 * @export
 * @interface SiteSetUrlRequest
 */
export interface SiteSetUrlRequest {
    /**
     * Version
     * @type {string}
     * @memberof SiteSetUrlRequest
     */
    'v': SiteSetUrlRequestVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof SiteSetUrlRequest
     */
    'language': SiteSetUrlRequestLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof SiteSetUrlRequest
     */
    'project_id': number;
    /**
     * Channel id
     * @type {number}
     * @memberof SiteSetUrlRequest
     */
    'channel_id': number;
    /**
     * 
     * @type {string}
     * @memberof SiteSetUrlRequest
     */
    'url': string;
}

export const SiteSetUrlRequestVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type SiteSetUrlRequestVEnum = typeof SiteSetUrlRequestVEnum[keyof typeof SiteSetUrlRequestVEnum];
export const SiteSetUrlRequestLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SiteSetUrlRequestLanguageEnum = typeof SiteSetUrlRequestLanguageEnum[keyof typeof SiteSetUrlRequestLanguageEnum];

/**
 * 
 * @export
 * @interface SiteTelegramChatInfoResponseDto
 */
export interface SiteTelegramChatInfoResponseDto {
    /**
     * 
     * @type {number}
     * @memberof SiteTelegramChatInfoResponseDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SiteTelegramChatInfoResponseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SiteTelegramChatInfoResponseDto
     */
    'domain'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteTelegramChatInfoResponseDto
     */
    'image': string;
}
/**
 * 
 * @export
 * @interface SiteTelegramChatPostsItem
 */
export interface SiteTelegramChatPostsItem {
    /**
     * message_id
     * @type {number}
     * @memberof SiteTelegramChatPostsItem
     */
    'message_id': number;
    /**
     * text
     * @type {string}
     * @memberof SiteTelegramChatPostsItem
     */
    'text': string;
    /**
     * attachments
     * @type {object}
     * @memberof SiteTelegramChatPostsItem
     */
    'attachments': object;
}
/**
 * 
 * @export
 * @interface SiteTelegramChatPostsResponseDto
 */
export interface SiteTelegramChatPostsResponseDto {
    /**
     * Array of items
     * @type {Array<SiteTelegramChatPostsItem>}
     * @memberof SiteTelegramChatPostsResponseDto
     */
    'results': Array<SiteTelegramChatPostsItem>;
}
/**
 * 
 * @export
 * @interface SiteTelegramSetSettingsRequestDto
 */
export interface SiteTelegramSetSettingsRequestDto {
    /**
     * Filter mode
     * @type {number}
     * @memberof SiteTelegramSetSettingsRequestDto
     */
    'filter_mode': SiteTelegramSetSettingsRequestDtoFilterModeEnum;
    /**
     * Message ID
     * @type {number}
     * @memberof SiteTelegramSetSettingsRequestDto
     */
    'message_id'?: number;
    /**
     * Message Link
     * @type {string}
     * @memberof SiteTelegramSetSettingsRequestDto
     */
    'link'?: string;
}

export const SiteTelegramSetSettingsRequestDtoFilterModeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type SiteTelegramSetSettingsRequestDtoFilterModeEnum = typeof SiteTelegramSetSettingsRequestDtoFilterModeEnum[keyof typeof SiteTelegramSetSettingsRequestDtoFilterModeEnum];

/**
 * 
 * @export
 * @interface SiteTotalInfoReferralsResponse
 */
export interface SiteTotalInfoReferralsResponse {
    /**
     * Amount of referrals
     * @type {Array<AmountItem>}
     * @memberof SiteTotalInfoReferralsResponse
     */
    'profit': Array<AmountItem>;
    /**
     * Members of referral
     * @type {number}
     * @memberof SiteTotalInfoReferralsResponse
     */
    'members': number;
}
/**
 * 
 * @export
 * @interface SiteTranscoderChannelItem
 */
export interface SiteTranscoderChannelItem {
    /**
     * 
     * @type {number}
     * @memberof SiteTranscoderChannelItem
     */
    'group_id': number;
    /**
     * 
     * @type {string}
     * @memberof SiteTranscoderChannelItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SiteTranscoderChannelItem
     */
    'type': string;
    /**
     * 
     * @type {boolean}
     * @memberof SiteTranscoderChannelItem
     */
    'active': boolean;
    /**
     * 
     * @type {string}
     * @memberof SiteTranscoderChannelItem
     */
    'photo_default': string;
    /**
     * 
     * @type {number}
     * @memberof SiteTranscoderChannelItem
     */
    'live': number;
    /**
     * 
     * @type {string}
     * @memberof SiteTranscoderChannelItem
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof SiteTranscoderChannelItem
     */
    'user_id': number;
    /**
     * 
     * @type {number}
     * @memberof SiteTranscoderChannelItem
     */
    'transcoderId': number;
}
/**
 * 
 * @export
 * @interface SiteTranscoderCreateDto
 */
export interface SiteTranscoderCreateDto {
    /**
     * Version
     * @type {string}
     * @memberof SiteTranscoderCreateDto
     */
    'v': SiteTranscoderCreateDtoVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof SiteTranscoderCreateDto
     */
    'language': SiteTranscoderCreateDtoLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof SiteTranscoderCreateDto
     */
    'project_id': number;
    /**
     * Width
     * @type {number}
     * @memberof SiteTranscoderCreateDto
     */
    'width'?: number;
    /**
     * Height
     * @type {number}
     * @memberof SiteTranscoderCreateDto
     */
    'height'?: number;
    /**
     * Fps
     * @type {number}
     * @memberof SiteTranscoderCreateDto
     */
    'fps'?: number;
    /**
     * Video bitrate, kbps
     * @type {number}
     * @memberof SiteTranscoderCreateDto
     */
    'vBitrate'?: number;
    /**
     * Audio bitrate, kbps
     * @type {number}
     * @memberof SiteTranscoderCreateDto
     */
    'aBitrate'?: number;
    /**
     * Name
     * @type {string}
     * @memberof SiteTranscoderCreateDto
     */
    'name': string;
    /**
     * Rotation
     * @type {number}
     * @memberof SiteTranscoderCreateDto
     */
    'rotation'?: number;
    /**
     * Rotation
     * @type {number}
     * @memberof SiteTranscoderCreateDto
     */
    'bFrames'?: number;
    /**
     * ChannelIds
     * @type {number}
     * @memberof SiteTranscoderCreateDto
     */
    'channelIds'?: number;
    /**
     * Video codec id
     * @type {number}
     * @memberof SiteTranscoderCreateDto
     */
    'videoCodecId': number;
}

export const SiteTranscoderCreateDtoVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type SiteTranscoderCreateDtoVEnum = typeof SiteTranscoderCreateDtoVEnum[keyof typeof SiteTranscoderCreateDtoVEnum];
export const SiteTranscoderCreateDtoLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SiteTranscoderCreateDtoLanguageEnum = typeof SiteTranscoderCreateDtoLanguageEnum[keyof typeof SiteTranscoderCreateDtoLanguageEnum];

/**
 * 
 * @export
 * @interface SiteTranscoderItemDto
 */
export interface SiteTranscoderItemDto {
    /**
     * Version
     * @type {string}
     * @memberof SiteTranscoderItemDto
     */
    'v': SiteTranscoderItemDtoVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof SiteTranscoderItemDto
     */
    'language': SiteTranscoderItemDtoLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof SiteTranscoderItemDto
     */
    'project_id': number;
    /**
     * Transcoder id
     * @type {number}
     * @memberof SiteTranscoderItemDto
     */
    'transcoder_id': number;
}

export const SiteTranscoderItemDtoVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type SiteTranscoderItemDtoVEnum = typeof SiteTranscoderItemDtoVEnum[keyof typeof SiteTranscoderItemDtoVEnum];
export const SiteTranscoderItemDtoLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SiteTranscoderItemDtoLanguageEnum = typeof SiteTranscoderItemDtoLanguageEnum[keyof typeof SiteTranscoderItemDtoLanguageEnum];

/**
 * 
 * @export
 * @interface SiteTranscoderListItem
 */
export interface SiteTranscoderListItem {
    /**
     * Id
     * @type {number}
     * @memberof SiteTranscoderListItem
     */
    'id': number;
    /**
     * Name
     * @type {string}
     * @memberof SiteTranscoderListItem
     */
    'name': string;
    /**
     * createdAt
     * @type {string}
     * @memberof SiteTranscoderListItem
     */
    'createdAt': string;
    /**
     * fps
     * @type {number}
     * @memberof SiteTranscoderListItem
     */
    'fps'?: number;
    /**
     * video bitrate
     * @type {number}
     * @memberof SiteTranscoderListItem
     */
    'vBitrate'?: number;
    /**
     * audio bitrate
     * @type {number}
     * @memberof SiteTranscoderListItem
     */
    'aBitrate'?: number;
    /**
     * width
     * @type {number}
     * @memberof SiteTranscoderListItem
     */
    'width'?: number;
    /**
     * height
     * @type {number}
     * @memberof SiteTranscoderListItem
     */
    'height'?: number;
    /**
     * rotation
     * @type {number}
     * @memberof SiteTranscoderListItem
     */
    'rotation'?: number;
    /**
     * B-Frames
     * @type {number}
     * @memberof SiteTranscoderListItem
     */
    'bFrames'?: number;
    /**
     * Status
     * @type {string}
     * @memberof SiteTranscoderListItem
     */
    'status': SiteTranscoderListItemStatusEnum;
    /**
     * Video codec
     * @type {string}
     * @memberof SiteTranscoderListItem
     */
    'videoCodec': SiteTranscoderListItemVideoCodecEnum;
    /**
     * B-Frames
     * @type {Array<SiteTranscoderChannelItem>}
     * @memberof SiteTranscoderListItem
     */
    'channels': Array<SiteTranscoderChannelItem>;
}

export const SiteTranscoderListItemStatusEnum = {
    Active: 'active',
    Inactive: 'inactive'
} as const;

export type SiteTranscoderListItemStatusEnum = typeof SiteTranscoderListItemStatusEnum[keyof typeof SiteTranscoderListItemStatusEnum];
export const SiteTranscoderListItemVideoCodecEnum = {
    H264: 'h264',
    Hevc: 'hevc'
} as const;

export type SiteTranscoderListItemVideoCodecEnum = typeof SiteTranscoderListItemVideoCodecEnum[keyof typeof SiteTranscoderListItemVideoCodecEnum];

/**
 * 
 * @export
 * @interface SiteTranscoderListResponse
 */
export interface SiteTranscoderListResponse {
    /**
     * Array of items
     * @type {Array<SiteTranscoderListItem>}
     * @memberof SiteTranscoderListResponse
     */
    'results': Array<SiteTranscoderListItem>;
}
/**
 * 
 * @export
 * @interface SiteTranscoderUpdateDto
 */
export interface SiteTranscoderUpdateDto {
    /**
     * Version
     * @type {string}
     * @memberof SiteTranscoderUpdateDto
     */
    'v': SiteTranscoderUpdateDtoVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof SiteTranscoderUpdateDto
     */
    'language': SiteTranscoderUpdateDtoLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof SiteTranscoderUpdateDto
     */
    'project_id': number;
    /**
     * Transcoder id
     * @type {number}
     * @memberof SiteTranscoderUpdateDto
     */
    'transcoder_id': number;
    /**
     * Width
     * @type {number}
     * @memberof SiteTranscoderUpdateDto
     */
    'width'?: number;
    /**
     * Height
     * @type {number}
     * @memberof SiteTranscoderUpdateDto
     */
    'height'?: number;
    /**
     * Fps
     * @type {number}
     * @memberof SiteTranscoderUpdateDto
     */
    'fps'?: number;
    /**
     * Video bitrate, kbps
     * @type {number}
     * @memberof SiteTranscoderUpdateDto
     */
    'vBitrate'?: number;
    /**
     * Audio bitrate, kbps
     * @type {number}
     * @memberof SiteTranscoderUpdateDto
     */
    'aBitrate'?: number;
    /**
     * Name
     * @type {string}
     * @memberof SiteTranscoderUpdateDto
     */
    'name'?: string;
    /**
     * Rotation
     * @type {number}
     * @memberof SiteTranscoderUpdateDto
     */
    'rotation'?: number;
    /**
     * Rotation
     * @type {number}
     * @memberof SiteTranscoderUpdateDto
     */
    'bFrames'?: number;
    /**
     * ChannelIds
     * @type {number}
     * @memberof SiteTranscoderUpdateDto
     */
    'channelIds'?: number;
    /**
     * Video codec id
     * @type {number}
     * @memberof SiteTranscoderUpdateDto
     */
    'videoCodecId': number;
}

export const SiteTranscoderUpdateDtoVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type SiteTranscoderUpdateDtoVEnum = typeof SiteTranscoderUpdateDtoVEnum[keyof typeof SiteTranscoderUpdateDtoVEnum];
export const SiteTranscoderUpdateDtoLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SiteTranscoderUpdateDtoLanguageEnum = typeof SiteTranscoderUpdateDtoLanguageEnum[keyof typeof SiteTranscoderUpdateDtoLanguageEnum];

/**
 * 
 * @export
 * @interface SiteUpdateChatTelegramRequest
 */
export interface SiteUpdateChatTelegramRequest {
    /**
     * Version
     * @type {string}
     * @memberof SiteUpdateChatTelegramRequest
     */
    'v': SiteUpdateChatTelegramRequestVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof SiteUpdateChatTelegramRequest
     */
    'language': SiteUpdateChatTelegramRequestLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof SiteUpdateChatTelegramRequest
     */
    'project_id': number;
    /**
     * Channel id
     * @type {number}
     * @memberof SiteUpdateChatTelegramRequest
     */
    'channel_id': number;
    /**
     * link
     * @type {string}
     * @memberof SiteUpdateChatTelegramRequest
     */
    'link'?: string;
    /**
     * select
     * @type {number}
     * @memberof SiteUpdateChatTelegramRequest
     */
    'select'?: number;
    /**
     * messageId
     * @type {number}
     * @memberof SiteUpdateChatTelegramRequest
     */
    'messageId'?: number;
}

export const SiteUpdateChatTelegramRequestVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type SiteUpdateChatTelegramRequestVEnum = typeof SiteUpdateChatTelegramRequestVEnum[keyof typeof SiteUpdateChatTelegramRequestVEnum];
export const SiteUpdateChatTelegramRequestLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SiteUpdateChatTelegramRequestLanguageEnum = typeof SiteUpdateChatTelegramRequestLanguageEnum[keyof typeof SiteUpdateChatTelegramRequestLanguageEnum];

/**
 * 
 * @export
 * @interface SiteUpdateOptionsOkRequest
 */
export interface SiteUpdateOptionsOkRequest {
    /**
     * Version
     * @type {string}
     * @memberof SiteUpdateOptionsOkRequest
     */
    'v': SiteUpdateOptionsOkRequestVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof SiteUpdateOptionsOkRequest
     */
    'language': SiteUpdateOptionsOkRequestLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof SiteUpdateOptionsOkRequest
     */
    'project_id': number;
    /**
     * Channel id
     * @type {number}
     * @memberof SiteUpdateOptionsOkRequest
     */
    'channel_id': number;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsOkRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsOkRequest
     */
    'description': string;
}

export const SiteUpdateOptionsOkRequestVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type SiteUpdateOptionsOkRequestVEnum = typeof SiteUpdateOptionsOkRequestVEnum[keyof typeof SiteUpdateOptionsOkRequestVEnum];
export const SiteUpdateOptionsOkRequestLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SiteUpdateOptionsOkRequestLanguageEnum = typeof SiteUpdateOptionsOkRequestLanguageEnum[keyof typeof SiteUpdateOptionsOkRequestLanguageEnum];

/**
 * 
 * @export
 * @interface SiteUpdateOptionsTrovoRequest
 */
export interface SiteUpdateOptionsTrovoRequest {
    /**
     * Version
     * @type {string}
     * @memberof SiteUpdateOptionsTrovoRequest
     */
    'v': SiteUpdateOptionsTrovoRequestVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof SiteUpdateOptionsTrovoRequest
     */
    'language': SiteUpdateOptionsTrovoRequestLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof SiteUpdateOptionsTrovoRequest
     */
    'project_id': number;
    /**
     * Channel id
     * @type {number}
     * @memberof SiteUpdateOptionsTrovoRequest
     */
    'channel_id': number;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsTrovoRequest
     */
    'title': string;
    /**
     * category id
     * @type {string}
     * @memberof SiteUpdateOptionsTrovoRequest
     */
    'category_id': string;
    /**
     * category name
     * @type {string}
     * @memberof SiteUpdateOptionsTrovoRequest
     */
    'category_name': string;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsTrovoRequest
     */
    'audience': SiteUpdateOptionsTrovoRequestAudienceEnum;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsTrovoRequest
     */
    'lang': SiteUpdateOptionsTrovoRequestLangEnum;
}

export const SiteUpdateOptionsTrovoRequestVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type SiteUpdateOptionsTrovoRequestVEnum = typeof SiteUpdateOptionsTrovoRequestVEnum[keyof typeof SiteUpdateOptionsTrovoRequestVEnum];
export const SiteUpdateOptionsTrovoRequestLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SiteUpdateOptionsTrovoRequestLanguageEnum = typeof SiteUpdateOptionsTrovoRequestLanguageEnum[keyof typeof SiteUpdateOptionsTrovoRequestLanguageEnum];
export const SiteUpdateOptionsTrovoRequestAudienceEnum = {
    ChannelAudienceTypeFamilyfriendly: 'CHANNEL_AUDIENCE_TYPE_FAMILYFRIENDLY',
    ChannelAudienceTypeTeen: 'CHANNEL_AUDIENCE_TYPE_TEEN',
    ChannelAudienceTypeEighteenplus: 'CHANNEL_AUDIENCE_TYPE_EIGHTEENPLUS'
} as const;

export type SiteUpdateOptionsTrovoRequestAudienceEnum = typeof SiteUpdateOptionsTrovoRequestAudienceEnum[keyof typeof SiteUpdateOptionsTrovoRequestAudienceEnum];
export const SiteUpdateOptionsTrovoRequestLangEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SiteUpdateOptionsTrovoRequestLangEnum = typeof SiteUpdateOptionsTrovoRequestLangEnum[keyof typeof SiteUpdateOptionsTrovoRequestLangEnum];

/**
 * 
 * @export
 * @interface SiteUpdateOptionsTwitchRequest
 */
export interface SiteUpdateOptionsTwitchRequest {
    /**
     * Version
     * @type {string}
     * @memberof SiteUpdateOptionsTwitchRequest
     */
    'v': SiteUpdateOptionsTwitchRequestVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof SiteUpdateOptionsTwitchRequest
     */
    'language': SiteUpdateOptionsTwitchRequestLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof SiteUpdateOptionsTwitchRequest
     */
    'project_id': number;
    /**
     * Channel id
     * @type {number}
     * @memberof SiteUpdateOptionsTwitchRequest
     */
    'channel_id': number;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsTwitchRequest
     */
    'title': string;
    /**
     * category id
     * @type {string}
     * @memberof SiteUpdateOptionsTwitchRequest
     */
    'category_id': string;
    /**
     * category name
     * @type {string}
     * @memberof SiteUpdateOptionsTwitchRequest
     */
    'category_name': string;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsTwitchRequest
     */
    'lang': SiteUpdateOptionsTwitchRequestLangEnum;
    /**
     * 
     * @type {Set<string>}
     * @memberof SiteUpdateOptionsTwitchRequest
     */
    'tags': Set<string>;
    /**
     * domain
     * @type {string}
     * @memberof SiteUpdateOptionsTwitchRequest
     */
    'domain': string;
}

export const SiteUpdateOptionsTwitchRequestVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type SiteUpdateOptionsTwitchRequestVEnum = typeof SiteUpdateOptionsTwitchRequestVEnum[keyof typeof SiteUpdateOptionsTwitchRequestVEnum];
export const SiteUpdateOptionsTwitchRequestLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SiteUpdateOptionsTwitchRequestLanguageEnum = typeof SiteUpdateOptionsTwitchRequestLanguageEnum[keyof typeof SiteUpdateOptionsTwitchRequestLanguageEnum];
export const SiteUpdateOptionsTwitchRequestLangEnum = {
    Ru: 'ru',
    En: 'en'
} as const;

export type SiteUpdateOptionsTwitchRequestLangEnum = typeof SiteUpdateOptionsTwitchRequestLangEnum[keyof typeof SiteUpdateOptionsTwitchRequestLangEnum];

/**
 * 
 * @export
 * @interface SiteUpdateOptionsVkRequest
 */
export interface SiteUpdateOptionsVkRequest {
    /**
     * Version
     * @type {string}
     * @memberof SiteUpdateOptionsVkRequest
     */
    'v': SiteUpdateOptionsVkRequestVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof SiteUpdateOptionsVkRequest
     */
    'language': SiteUpdateOptionsVkRequestLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof SiteUpdateOptionsVkRequest
     */
    'project_id': number;
    /**
     * Channel id
     * @type {number}
     * @memberof SiteUpdateOptionsVkRequest
     */
    'channel_id': number;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsVkRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsVkRequest
     */
    'description': string;
    /**
     * category id
     * @type {string}
     * @memberof SiteUpdateOptionsVkRequest
     */
    'category_id': string;
    /**
     * category name
     * @type {string}
     * @memberof SiteUpdateOptionsVkRequest
     */
    'category_name': string;
    /**
     * category id
     * @type {string}
     * @memberof SiteUpdateOptionsVkRequest
     */
    'category_secondary_id': string;
    /**
     * category name
     * @type {string}
     * @memberof SiteUpdateOptionsVkRequest
     */
    'category_secondary_name': string;
    /**
     * playlist id
     * @type {string}
     * @memberof SiteUpdateOptionsVkRequest
     */
    'playlist_id': string;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsVkRequest
     */
    'privacy_comments': SiteUpdateOptionsVkRequestPrivacyCommentsEnum;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsVkRequest
     */
    'privacy_video': SiteUpdateOptionsVkRequestPrivacyVideoEnum;
    /**
     * Is publish stream on wall
     * @type {boolean}
     * @memberof SiteUpdateOptionsVkRequest
     */
    'wall': boolean;
}

export const SiteUpdateOptionsVkRequestVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type SiteUpdateOptionsVkRequestVEnum = typeof SiteUpdateOptionsVkRequestVEnum[keyof typeof SiteUpdateOptionsVkRequestVEnum];
export const SiteUpdateOptionsVkRequestLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SiteUpdateOptionsVkRequestLanguageEnum = typeof SiteUpdateOptionsVkRequestLanguageEnum[keyof typeof SiteUpdateOptionsVkRequestLanguageEnum];
export const SiteUpdateOptionsVkRequestPrivacyCommentsEnum = {
    All: 'all',
    Members: 'members',
    Editors: 'editors',
    Nobody: 'nobody'
} as const;

export type SiteUpdateOptionsVkRequestPrivacyCommentsEnum = typeof SiteUpdateOptionsVkRequestPrivacyCommentsEnum[keyof typeof SiteUpdateOptionsVkRequestPrivacyCommentsEnum];
export const SiteUpdateOptionsVkRequestPrivacyVideoEnum = {
    All: 'all',
    Members: 'members',
    Editors: 'editors',
    Nobody: 'nobody'
} as const;

export type SiteUpdateOptionsVkRequestPrivacyVideoEnum = typeof SiteUpdateOptionsVkRequestPrivacyVideoEnum[keyof typeof SiteUpdateOptionsVkRequestPrivacyVideoEnum];

/**
 * 
 * @export
 * @interface SiteUpdateOptionsVkVideoLiveRequest
 */
export interface SiteUpdateOptionsVkVideoLiveRequest {
    /**
     * Version
     * @type {string}
     * @memberof SiteUpdateOptionsVkVideoLiveRequest
     */
    'v': SiteUpdateOptionsVkVideoLiveRequestVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof SiteUpdateOptionsVkVideoLiveRequest
     */
    'language': SiteUpdateOptionsVkVideoLiveRequestLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof SiteUpdateOptionsVkVideoLiveRequest
     */
    'project_id': number;
    /**
     * Channel id
     * @type {number}
     * @memberof SiteUpdateOptionsVkVideoLiveRequest
     */
    'channel_id': number;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsVkVideoLiveRequest
     */
    'title': string;
    /**
     * category id
     * @type {string}
     * @memberof SiteUpdateOptionsVkVideoLiveRequest
     */
    'category_id': string;
    /**
     * category name
     * @type {string}
     * @memberof SiteUpdateOptionsVkVideoLiveRequest
     */
    'category_name': string;
}

export const SiteUpdateOptionsVkVideoLiveRequestVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type SiteUpdateOptionsVkVideoLiveRequestVEnum = typeof SiteUpdateOptionsVkVideoLiveRequestVEnum[keyof typeof SiteUpdateOptionsVkVideoLiveRequestVEnum];
export const SiteUpdateOptionsVkVideoLiveRequestLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SiteUpdateOptionsVkVideoLiveRequestLanguageEnum = typeof SiteUpdateOptionsVkVideoLiveRequestLanguageEnum[keyof typeof SiteUpdateOptionsVkVideoLiveRequestLanguageEnum];

/**
 * 
 * @export
 * @interface SiteUpdateOptionsYoutubeRequest
 */
export interface SiteUpdateOptionsYoutubeRequest {
    /**
     * Version
     * @type {string}
     * @memberof SiteUpdateOptionsYoutubeRequest
     */
    'v': SiteUpdateOptionsYoutubeRequestVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof SiteUpdateOptionsYoutubeRequest
     */
    'language': SiteUpdateOptionsYoutubeRequestLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof SiteUpdateOptionsYoutubeRequest
     */
    'project_id': number;
    /**
     * Channel id
     * @type {number}
     * @memberof SiteUpdateOptionsYoutubeRequest
     */
    'channel_id': number;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsYoutubeRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsYoutubeRequest
     */
    'description': string;
    /**
     * category id
     * @type {string}
     * @memberof SiteUpdateOptionsYoutubeRequest
     */
    'category_id': string;
    /**
     * category name
     * @type {string}
     * @memberof SiteUpdateOptionsYoutubeRequest
     */
    'category_name': string;
    /**
     * playlist id
     * @type {string}
     * @memberof SiteUpdateOptionsYoutubeRequest
     */
    'playlist_id': string;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsYoutubeRequest
     */
    'audience': SiteUpdateOptionsYoutubeRequestAudienceEnum;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsYoutubeRequest
     */
    'latency': SiteUpdateOptionsYoutubeRequestLatencyEnum;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsYoutubeRequest
     */
    'privacy_video': SiteUpdateOptionsYoutubeRequestPrivacyVideoEnum;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsYoutubeRequest
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdateOptionsYoutubeRequest
     */
    'lang': SiteUpdateOptionsYoutubeRequestLangEnum;
    /**
     * 
     * @type {Set<string>}
     * @memberof SiteUpdateOptionsYoutubeRequest
     */
    'tags': Set<string>;
}

export const SiteUpdateOptionsYoutubeRequestVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type SiteUpdateOptionsYoutubeRequestVEnum = typeof SiteUpdateOptionsYoutubeRequestVEnum[keyof typeof SiteUpdateOptionsYoutubeRequestVEnum];
export const SiteUpdateOptionsYoutubeRequestLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type SiteUpdateOptionsYoutubeRequestLanguageEnum = typeof SiteUpdateOptionsYoutubeRequestLanguageEnum[keyof typeof SiteUpdateOptionsYoutubeRequestLanguageEnum];
export const SiteUpdateOptionsYoutubeRequestAudienceEnum = {
    MarkForKids: 'mark_for_kids',
    MarkForNokids: 'mark_for_nokids'
} as const;

export type SiteUpdateOptionsYoutubeRequestAudienceEnum = typeof SiteUpdateOptionsYoutubeRequestAudienceEnum[keyof typeof SiteUpdateOptionsYoutubeRequestAudienceEnum];
export const SiteUpdateOptionsYoutubeRequestLatencyEnum = {
    Normal: 'normal',
    Low: 'low',
    UltraLow: 'ultraLow'
} as const;

export type SiteUpdateOptionsYoutubeRequestLatencyEnum = typeof SiteUpdateOptionsYoutubeRequestLatencyEnum[keyof typeof SiteUpdateOptionsYoutubeRequestLatencyEnum];
export const SiteUpdateOptionsYoutubeRequestPrivacyVideoEnum = {
    Private: 'private',
    Public: 'public',
    Unlisted: 'unlisted'
} as const;

export type SiteUpdateOptionsYoutubeRequestPrivacyVideoEnum = typeof SiteUpdateOptionsYoutubeRequestPrivacyVideoEnum[keyof typeof SiteUpdateOptionsYoutubeRequestPrivacyVideoEnum];
export const SiteUpdateOptionsYoutubeRequestLangEnum = {
    Ru: 'ru',
    En: 'en'
} as const;

export type SiteUpdateOptionsYoutubeRequestLangEnum = typeof SiteUpdateOptionsYoutubeRequestLangEnum[keyof typeof SiteUpdateOptionsYoutubeRequestLangEnum];

/**
 * 
 * @export
 * @interface StructureHelpPageConnectionsItemFinal
 */
export interface StructureHelpPageConnectionsItemFinal {
    /**
     * 
     * @type {BlogPageSiteResponseId}
     * @memberof StructureHelpPageConnectionsItemFinal
     */
    '_id': BlogPageSiteResponseId;
    /**
     * Notion id
     * @type {string}
     * @memberof StructureHelpPageConnectionsItemFinal
     */
    'notion_id': string;
    /**
     * Notion parent id
     * @type {string}
     * @memberof StructureHelpPageConnectionsItemFinal
     */
    'notion_parent_id': string;
    /**
     * url
     * @type {string}
     * @memberof StructureHelpPageConnectionsItemFinal
     */
    'url': string;
    /**
     * Generated url from root path
     * @type {string}
     * @memberof StructureHelpPageConnectionsItemFinal
     */
    'url_inherit': string;
    /**
     * Page status
     * @type {string}
     * @memberof StructureHelpPageConnectionsItemFinal
     */
    'status': StructureHelpPageConnectionsItemFinalStatusEnum;
    /**
     * Subject
     * @type {Array<StructureHelpPageConnectionsItemLang>}
     * @memberof StructureHelpPageConnectionsItemFinal
     */
    'title': Array<StructureHelpPageConnectionsItemLang>;
    /**
     * Page icon
     * @type {object}
     * @memberof StructureHelpPageConnectionsItemFinal
     */
    'icon': object | null;
    /**
     * Priority for sorting
     * @type {number}
     * @memberof StructureHelpPageConnectionsItemFinal
     */
    'priority': number;
}

export const StructureHelpPageConnectionsItemFinalStatusEnum = {
    None: 'None',
    Backlog: 'Backlog',
    Drafting: 'Drafting',
    Reviewing: 'Reviewing',
    Done: 'Done',
    Published: 'Published'
} as const;

export type StructureHelpPageConnectionsItemFinalStatusEnum = typeof StructureHelpPageConnectionsItemFinalStatusEnum[keyof typeof StructureHelpPageConnectionsItemFinalStatusEnum];

/**
 * 
 * @export
 * @interface StructureHelpPageConnectionsItemLang
 */
export interface StructureHelpPageConnectionsItemLang {
    /**
     * Full language name
     * @type {string}
     * @memberof StructureHelpPageConnectionsItemLang
     */
    'language': StructureHelpPageConnectionsItemLangLanguageEnum;
    /**
     * Short language name
     * @type {string}
     * @memberof StructureHelpPageConnectionsItemLang
     */
    'language_iso': StructureHelpPageConnectionsItemLangLanguageIsoEnum;
    /**
     * Help menu article title
     * @type {string}
     * @memberof StructureHelpPageConnectionsItemLang
     */
    'value': string;
}

export const StructureHelpPageConnectionsItemLangLanguageEnum = {
    Russian: 'russian',
    English: 'english',
    None: 'none'
} as const;

export type StructureHelpPageConnectionsItemLangLanguageEnum = typeof StructureHelpPageConnectionsItemLangLanguageEnum[keyof typeof StructureHelpPageConnectionsItemLangLanguageEnum];
export const StructureHelpPageConnectionsItemLangLanguageIsoEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type StructureHelpPageConnectionsItemLangLanguageIsoEnum = typeof StructureHelpPageConnectionsItemLangLanguageIsoEnum[keyof typeof StructureHelpPageConnectionsItemLangLanguageIsoEnum];

/**
 * 
 * @export
 * @interface StructureHelpPageItemResponse
 */
export interface StructureHelpPageItemResponse {
    /**
     * 
     * @type {BlogPageSiteResponseId}
     * @memberof StructureHelpPageItemResponse
     */
    '_id': BlogPageSiteResponseId;
    /**
     * Notion id
     * @type {string}
     * @memberof StructureHelpPageItemResponse
     */
    'notion_id': string;
    /**
     * Notion parent id
     * @type {string}
     * @memberof StructureHelpPageItemResponse
     */
    'notion_parent_id': string;
    /**
     * url
     * @type {string}
     * @memberof StructureHelpPageItemResponse
     */
    'url': string;
    /**
     * Generated url from root path
     * @type {string}
     * @memberof StructureHelpPageItemResponse
     */
    'url_inherit': string;
    /**
     * Page status
     * @type {string}
     * @memberof StructureHelpPageItemResponse
     */
    'status': StructureHelpPageItemResponseStatusEnum;
    /**
     * Subject
     * @type {Array<StructureHelpPageConnectionsItemLang>}
     * @memberof StructureHelpPageItemResponse
     */
    'title': Array<StructureHelpPageConnectionsItemLang>;
    /**
     * Page icon
     * @type {object}
     * @memberof StructureHelpPageItemResponse
     */
    'icon': object | null;
    /**
     * Priority for sorting
     * @type {number}
     * @memberof StructureHelpPageItemResponse
     */
    'priority': number;
    /**
     * Structure of child pages same as this array of class StructureHelpPageItemResponse, maximum 4
     * @type {Array<StructureHelpPageItemResponse2>}
     * @memberof StructureHelpPageItemResponse
     */
    'connections': Array<StructureHelpPageItemResponse2>;
}

export const StructureHelpPageItemResponseStatusEnum = {
    None: 'None',
    Backlog: 'Backlog',
    Drafting: 'Drafting',
    Reviewing: 'Reviewing',
    Done: 'Done',
    Published: 'Published'
} as const;

export type StructureHelpPageItemResponseStatusEnum = typeof StructureHelpPageItemResponseStatusEnum[keyof typeof StructureHelpPageItemResponseStatusEnum];

/**
 * 
 * @export
 * @interface StructureHelpPageItemResponse2
 */
export interface StructureHelpPageItemResponse2 {
    /**
     * 
     * @type {BlogPageSiteResponseId}
     * @memberof StructureHelpPageItemResponse2
     */
    '_id': BlogPageSiteResponseId;
    /**
     * Notion id
     * @type {string}
     * @memberof StructureHelpPageItemResponse2
     */
    'notion_id': string;
    /**
     * Notion parent id
     * @type {string}
     * @memberof StructureHelpPageItemResponse2
     */
    'notion_parent_id': string;
    /**
     * url
     * @type {string}
     * @memberof StructureHelpPageItemResponse2
     */
    'url': string;
    /**
     * Generated url from root path
     * @type {string}
     * @memberof StructureHelpPageItemResponse2
     */
    'url_inherit': string;
    /**
     * Page status
     * @type {string}
     * @memberof StructureHelpPageItemResponse2
     */
    'status': StructureHelpPageItemResponse2StatusEnum;
    /**
     * Subject
     * @type {Array<StructureHelpPageConnectionsItemLang>}
     * @memberof StructureHelpPageItemResponse2
     */
    'title': Array<StructureHelpPageConnectionsItemLang>;
    /**
     * Page icon
     * @type {object}
     * @memberof StructureHelpPageItemResponse2
     */
    'icon': object | null;
    /**
     * Priority for sorting
     * @type {number}
     * @memberof StructureHelpPageItemResponse2
     */
    'priority': number;
    /**
     * Structure of child pages same as this array of class StructureHelpPageItemResponse, maximum 4
     * @type {Array<StructureHelpPageItemResponse3>}
     * @memberof StructureHelpPageItemResponse2
     */
    'connections': Array<StructureHelpPageItemResponse3>;
}

export const StructureHelpPageItemResponse2StatusEnum = {
    None: 'None',
    Backlog: 'Backlog',
    Drafting: 'Drafting',
    Reviewing: 'Reviewing',
    Done: 'Done',
    Published: 'Published'
} as const;

export type StructureHelpPageItemResponse2StatusEnum = typeof StructureHelpPageItemResponse2StatusEnum[keyof typeof StructureHelpPageItemResponse2StatusEnum];

/**
 * 
 * @export
 * @interface StructureHelpPageItemResponse3
 */
export interface StructureHelpPageItemResponse3 {
    /**
     * 
     * @type {BlogPageSiteResponseId}
     * @memberof StructureHelpPageItemResponse3
     */
    '_id': BlogPageSiteResponseId;
    /**
     * Notion id
     * @type {string}
     * @memberof StructureHelpPageItemResponse3
     */
    'notion_id': string;
    /**
     * Notion parent id
     * @type {string}
     * @memberof StructureHelpPageItemResponse3
     */
    'notion_parent_id': string;
    /**
     * url
     * @type {string}
     * @memberof StructureHelpPageItemResponse3
     */
    'url': string;
    /**
     * Generated url from root path
     * @type {string}
     * @memberof StructureHelpPageItemResponse3
     */
    'url_inherit': string;
    /**
     * Page status
     * @type {string}
     * @memberof StructureHelpPageItemResponse3
     */
    'status': StructureHelpPageItemResponse3StatusEnum;
    /**
     * Subject
     * @type {Array<StructureHelpPageConnectionsItemLang>}
     * @memberof StructureHelpPageItemResponse3
     */
    'title': Array<StructureHelpPageConnectionsItemLang>;
    /**
     * Page icon
     * @type {object}
     * @memberof StructureHelpPageItemResponse3
     */
    'icon': object | null;
    /**
     * Priority for sorting
     * @type {number}
     * @memberof StructureHelpPageItemResponse3
     */
    'priority': number;
    /**
     * Structure of child pages same as this array of class StructureHelpPageItemResponse, maximum 4
     * @type {Array<StructureHelpPageConnectionsItemFinal>}
     * @memberof StructureHelpPageItemResponse3
     */
    'connections': Array<StructureHelpPageConnectionsItemFinal>;
}

export const StructureHelpPageItemResponse3StatusEnum = {
    None: 'None',
    Backlog: 'Backlog',
    Drafting: 'Drafting',
    Reviewing: 'Reviewing',
    Done: 'Done',
    Published: 'Published'
} as const;

export type StructureHelpPageItemResponse3StatusEnum = typeof StructureHelpPageItemResponse3StatusEnum[keyof typeof StructureHelpPageItemResponse3StatusEnum];

/**
 * 
 * @export
 * @interface StructureHelpPageResponse
 */
export interface StructureHelpPageResponse {
    /**
     * Response execution success
     * @type {boolean}
     * @memberof StructureHelpPageResponse
     */
    'success': boolean;
    /**
     * Structure of help page
     * @type {Array<StructureHelpPageItemResponse>}
     * @memberof StructureHelpPageResponse
     */
    'result': Array<StructureHelpPageItemResponse>;
}
/**
 * 
 * @export
 * @interface SuccessResponse
 */
export interface SuccessResponse {
    /**
     * Response execution success
     * @type {boolean}
     * @memberof SuccessResponse
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface TCityChartData
 */
export interface TCityChartData {
    /**
     * Points for chart [0-100%]
     * @type {Array<number>}
     * @memberof TCityChartData
     */
    'chartData': Array<number>;
    /**
     * cityName
     * @type {string}
     * @memberof TCityChartData
     */
    'cityName': string;
}
/**
 * 
 * @export
 * @interface TCountryChartData
 */
export interface TCountryChartData {
    /**
     * countryName
     * @type {string}
     * @memberof TCountryChartData
     */
    'countryName': string;
    /**
     * Array of cities data
     * @type {Array<TCityChartData>}
     * @memberof TCountryChartData
     */
    'cities': Array<TCityChartData>;
}
/**
 * 
 * @export
 * @interface TelegramInitConnectResponseDto
 */
export interface TelegramInitConnectResponseDto {
    /**
     * Code for connect
     * @type {string}
     * @memberof TelegramInitConnectResponseDto
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface TelegramSettingsDto
 */
export interface TelegramSettingsDto {
    /**
     * Filter
     * @type {number}
     * @memberof TelegramSettingsDto
     */
    'filter_mode': TelegramSettingsDtoFilterModeEnum;
    /**
     * Chat info
     * @type {SiteTelegramChatInfoResponseDto}
     * @memberof TelegramSettingsDto
     */
    'chat': SiteTelegramChatInfoResponseDto;
    /**
     * Post
     * @type {SiteTelegramChatPostsItem}
     * @memberof TelegramSettingsDto
     */
    'post'?: SiteTelegramChatPostsItem;
}

export const TelegramSettingsDtoFilterModeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type TelegramSettingsDtoFilterModeEnum = typeof TelegramSettingsDtoFilterModeEnum[keyof typeof TelegramSettingsDtoFilterModeEnum];

/**
 * 
 * @export
 * @interface TelegramSettingsResponseDto
 */
export interface TelegramSettingsResponseDto {
    /**
     * Status connected
     * @type {boolean}
     * @memberof TelegramSettingsResponseDto
     */
    'connected': boolean;
    /**
     * Payload settings for telegram
     * @type {TelegramSettingsDto}
     * @memberof TelegramSettingsResponseDto
     */
    'data': TelegramSettingsDto | null;
}
/**
 * 
 * @export
 * @interface TransactionResponse
 */
export interface TransactionResponse {
    /**
     * 
     * @type {number}
     * @memberof TransactionResponse
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionResponse
     */
    'user_id': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionResponse
     */
    'payout_id': number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'sum': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'description': string;
    /**
     * 
     * @type {object}
     * @memberof TransactionResponse
     */
    'code': object;
    /**
     * 
     * @type {number}
     * @memberof TransactionResponse
     */
    'referral_id': number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionResponse
     */
    'paymentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionResponse
     */
    'payoutId': number | null;
}
/**
 * 
 * @export
 * @interface UpdatePullKeyRequest
 */
export interface UpdatePullKeyRequest {
    /**
     * Version
     * @type {string}
     * @memberof UpdatePullKeyRequest
     */
    'v': UpdatePullKeyRequestVEnum;
    /**
     * Current language
     * @type {string}
     * @memberof UpdatePullKeyRequest
     */
    'language': UpdatePullKeyRequestLanguageEnum;
    /**
     * Project id
     * @type {number}
     * @memberof UpdatePullKeyRequest
     */
    'project_id': number;
    /**
     * Key
     * @type {string}
     * @memberof UpdatePullKeyRequest
     */
    'key': string;
    /**
     * Region for link
     * @type {string}
     * @memberof UpdatePullKeyRequest
     */
    'region': string;
}

export const UpdatePullKeyRequestVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;

export type UpdatePullKeyRequestVEnum = typeof UpdatePullKeyRequestVEnum[keyof typeof UpdatePullKeyRequestVEnum];
export const UpdatePullKeyRequestLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type UpdatePullKeyRequestLanguageEnum = typeof UpdatePullKeyRequestLanguageEnum[keyof typeof UpdatePullKeyRequestLanguageEnum];

/**
 * 
 * @export
 * @interface UserProfileResponse
 */
export interface UserProfileResponse {
    /**
     * User id
     * @type {number}
     * @memberof UserProfileResponse
     */
    'id': UserProfileResponseIdEnum;
    /**
     * Type profile
     * @type {number}
     * @memberof UserProfileResponse
     */
    'type': number;
    /**
     * FirstName
     * @type {string}
     * @memberof UserProfileResponse
     */
    'firstName': string;
    /**
     * LastName
     * @type {string}
     * @memberof UserProfileResponse
     */
    'lastName': string;
    /**
     * Photo
     * @type {string}
     * @memberof UserProfileResponse
     */
    'photo': string;
    /**
     * RefId
     * @type {string}
     * @memberof UserProfileResponse
     */
    'refId': string;
    /**
     * Count partners
     * @type {number}
     * @memberof UserProfileResponse
     */
    'partners': number;
    /**
     * Referrals income
     * @type {string}
     * @memberof UserProfileResponse
     */
    'referralsIncome': string;
    /**
     * Scope
     * @type {number}
     * @memberof UserProfileResponse
     */
    'scope': number;
    /**
     * Currency
     * @type {string}
     * @memberof UserProfileResponse
     */
    'currency': UserProfileResponseCurrencyEnum;
    /**
     * Country
     * @type {number}
     * @memberof UserProfileResponse
     */
    'countrie_id': number;
    /**
     * Language
     * @type {string}
     * @memberof UserProfileResponse
     */
    'language': UserProfileResponseLanguageEnum;
    /**
     * Balance
     * @type {number}
     * @memberof UserProfileResponse
     */
    'balance': number;
    /**
     * Last select project
     * @type {number}
     * @memberof UserProfileResponse
     */
    'lastProjectId': number | null;
}

export const UserProfileResponseIdEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type UserProfileResponseIdEnum = typeof UserProfileResponseIdEnum[keyof typeof UserProfileResponseIdEnum];
export const UserProfileResponseCurrencyEnum = {
    Rub: 'rub',
    Usd: 'usd'
} as const;

export type UserProfileResponseCurrencyEnum = typeof UserProfileResponseCurrencyEnum[keyof typeof UserProfileResponseCurrencyEnum];
export const UserProfileResponseLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;

export type UserProfileResponseLanguageEnum = typeof UserProfileResponseLanguageEnum[keyof typeof UserProfileResponseLanguageEnum];

/**
 * 
 * @export
 * @interface UserProject2ProjectResponse
 */
export interface UserProject2ProjectResponse {
    /**
     * User id
     * @type {number}
     * @memberof UserProject2ProjectResponse
     */
    'user_id': number;
    /**
     * Project id
     * @type {number}
     * @memberof UserProject2ProjectResponse
     */
    'project_id': number;
    /**
     * Имя
     * @type {string}
     * @memberof UserProject2ProjectResponse
     */
    'name': string;
    /**
     * Фамилия
     * @type {string}
     * @memberof UserProject2ProjectResponse
     */
    'fename': string;
    /**
     * Аватарка
     * @type {string}
     * @memberof UserProject2ProjectResponse
     */
    'photo_50': string;
    /**
     * Тип 0 - личный проект, 1 - командный проект
     * @type {number}
     * @memberof UserProject2ProjectResponse
     */
    'type': UserProject2ProjectResponseTypeEnum;
    /**
     * External id
     * @type {string}
     * @memberof UserProject2ProjectResponse
     */
    'external_id': string;
    /**
     * Access type
     * @type {number}
     * @memberof UserProject2ProjectResponse
     */
    'access_type': UserProject2ProjectResponseAccessTypeEnum;
}

export const UserProject2ProjectResponseTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type UserProject2ProjectResponseTypeEnum = typeof UserProject2ProjectResponseTypeEnum[keyof typeof UserProject2ProjectResponseTypeEnum];
export const UserProject2ProjectResponseAccessTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type UserProject2ProjectResponseAccessTypeEnum = typeof UserProject2ProjectResponseAccessTypeEnum[keyof typeof UserProject2ProjectResponseAccessTypeEnum];

/**
 * 
 * @export
 * @interface UserProjectGetResponse
 */
export interface UserProjectGetResponse {
    /**
     * Имя
     * @type {string}
     * @memberof UserProjectGetResponse
     */
    'name': string;
    /**
     * Фамилия
     * @type {string}
     * @memberof UserProjectGetResponse
     */
    'fename': string;
    /**
     * Аватарка
     * @type {string}
     * @memberof UserProjectGetResponse
     */
    'photo_50': string;
    /**
     * Тип 0 - личный проект, 1 - командный проект
     * @type {number}
     * @memberof UserProjectGetResponse
     */
    'type': UserProjectGetResponseTypeEnum;
    /**
     * External id
     * @type {string}
     * @memberof UserProjectGetResponse
     */
    'external_id': string;
    /**
     * Internal id
     * @type {number}
     * @memberof UserProjectGetResponse
     */
    'internal_id': number;
    /**
     * Countrie id
     * @type {number}
     * @memberof UserProjectGetResponse
     */
    'countrie_id': number;
    /**
     * Balance bonus
     * @type {number}
     * @memberof UserProjectGetResponse
     */
    'balance_bonus': number;
    /**
     * Balance payment
     * @type {number}
     * @memberof UserProjectGetResponse
     */
    'balance_payment': number;
    /**
     * Balance profit
     * @type {number}
     * @memberof UserProjectGetResponse
     */
    'balance_profit': number;
    /**
     * Currency
     * @type {string}
     * @memberof UserProjectGetResponse
     */
    'currency': UserProjectGetResponseCurrencyEnum;
}

export const UserProjectGetResponseTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type UserProjectGetResponseTypeEnum = typeof UserProjectGetResponseTypeEnum[keyof typeof UserProjectGetResponseTypeEnum];
export const UserProjectGetResponseCurrencyEnum = {
    Rub: 'rub',
    Usd: 'usd'
} as const;

export type UserProjectGetResponseCurrencyEnum = typeof UserProjectGetResponseCurrencyEnum[keyof typeof UserProjectGetResponseCurrencyEnum];

/**
 * 
 * @export
 * @interface UserProjectResponse
 */
export interface UserProjectResponse {
    /**
     * Primary key
     * @type {number}
     * @memberof UserProjectResponse
     */
    'id': number;
    /**
     * User id
     * @type {number}
     * @memberof UserProjectResponse
     */
    'user_id': number;
    /**
     * Project id
     * @type {number}
     * @memberof UserProjectResponse
     */
    'project_id': number;
    /**
     * Access type
     * @type {number}
     * @memberof UserProjectResponse
     */
    'access_type': UserProjectResponseAccessTypeEnum;
    /**
     * Project data
     * @type {UserProject2ProjectResponse}
     * @memberof UserProjectResponse
     */
    'project': UserProject2ProjectResponse;
    /**
     * Members count
     * @type {number}
     * @memberof UserProjectResponse
     */
    'member_count': number;
}

export const UserProjectResponseAccessTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type UserProjectResponseAccessTypeEnum = typeof UserProjectResponseAccessTypeEnum[keyof typeof UserProjectResponseAccessTypeEnum];

/**
 * 
 * @export
 * @interface ValidationErrorDto
 */
export interface ValidationErrorDto {
    /**
     * Object that was validated.
     * @type {object}
     * @memberof ValidationErrorDto
     */
    'target'?: object;
    /**
     * Object\'s property that hasn\'t passed validation.
     * @type {string}
     * @memberof ValidationErrorDto
     */
    'property'?: string;
    /**
     * Value that haven\'t pass a validation.
     * @type {object}
     * @memberof ValidationErrorDto
     */
    'value'?: object;
    /**
     * Constraints that failed validation with error messages. Array of object {string: string}
     * @type {object}
     * @memberof ValidationErrorDto
     */
    'constraints'?: object;
    /**
     * Which value caused the error. Childrens its this class
     * @type {Array<ValidationErrorDto>}
     * @memberof ValidationErrorDto
     */
    'children'?: Array<ValidationErrorDto>;
    /**
     * A transient set of data passed through to the validation result for response mapping
     * @type {object}
     * @memberof ValidationErrorDto
     */
    'contexts'?: object;
}

/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Bitrate for stream
         * @param {SiteAnalyticsTsControllerStreamBitrate1VEnum} v Version
         * @param {SiteAnalyticsTsControllerStreamBitrate1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} streamId stream id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteAnalyticsTsControllerStreamBitrate1: async (v: SiteAnalyticsTsControllerStreamBitrate1VEnum, language: SiteAnalyticsTsControllerStreamBitrate1LanguageEnum, projectId: number, streamId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteAnalyticsTsControllerStreamBitrate1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteAnalyticsTsControllerStreamBitrate1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteAnalyticsTsControllerStreamBitrate1', 'projectId', projectId)
            // verify required parameter 'streamId' is not null or undefined
            assertParamExists('siteAnalyticsTsControllerStreamBitrate1', 'streamId', streamId)
            const localVarPath = `/method/analytics/stream/graph/bitrate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (streamId !== undefined) {
                localVarQueryParameter['stream_id'] = streamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Events for stream
         * @param {SiteAnalyticsTsControllerStreamEvents1VEnum} v Version
         * @param {SiteAnalyticsTsControllerStreamEvents1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} streamId stream id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteAnalyticsTsControllerStreamEvents1: async (v: SiteAnalyticsTsControllerStreamEvents1VEnum, language: SiteAnalyticsTsControllerStreamEvents1LanguageEnum, projectId: number, streamId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteAnalyticsTsControllerStreamEvents1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteAnalyticsTsControllerStreamEvents1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteAnalyticsTsControllerStreamEvents1', 'projectId', projectId)
            // verify required parameter 'streamId' is not null or undefined
            assertParamExists('siteAnalyticsTsControllerStreamEvents1', 'streamId', streamId)
            const localVarPath = `/method/analytics/stream/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (streamId !== undefined) {
                localVarQueryParameter['stream_id'] = streamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Viewers for stream
         * @param {SiteAnalyticsTsControllerStreamViewers1VEnum} v Version
         * @param {SiteAnalyticsTsControllerStreamViewers1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} streamId stream id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteAnalyticsTsControllerStreamViewers1: async (v: SiteAnalyticsTsControllerStreamViewers1VEnum, language: SiteAnalyticsTsControllerStreamViewers1LanguageEnum, projectId: number, streamId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteAnalyticsTsControllerStreamViewers1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteAnalyticsTsControllerStreamViewers1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteAnalyticsTsControllerStreamViewers1', 'projectId', projectId)
            // verify required parameter 'streamId' is not null or undefined
            assertParamExists('siteAnalyticsTsControllerStreamViewers1', 'streamId', streamId)
            const localVarPath = `/method/analytics/stream/graph/viewers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (streamId !== undefined) {
                localVarQueryParameter['stream_id'] = streamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Bitrate for stream
         * @param {SiteAnalyticsTsControllerStreamBitrate1VEnum} v Version
         * @param {SiteAnalyticsTsControllerStreamBitrate1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} streamId stream id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteAnalyticsTsControllerStreamBitrate1(v: SiteAnalyticsTsControllerStreamBitrate1VEnum, language: SiteAnalyticsTsControllerStreamBitrate1LanguageEnum, projectId: number, streamId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteAnalyticsTsControllerStreamBitrate1(v, language, projectId, streamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.siteAnalyticsTsControllerStreamBitrate1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Events for stream
         * @param {SiteAnalyticsTsControllerStreamEvents1VEnum} v Version
         * @param {SiteAnalyticsTsControllerStreamEvents1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} streamId stream id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteAnalyticsTsControllerStreamEvents1(v: SiteAnalyticsTsControllerStreamEvents1VEnum, language: SiteAnalyticsTsControllerStreamEvents1LanguageEnum, projectId: number, streamId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteAnalyticsTsControllerStreamEvents1(v, language, projectId, streamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.siteAnalyticsTsControllerStreamEvents1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Viewers for stream
         * @param {SiteAnalyticsTsControllerStreamViewers1VEnum} v Version
         * @param {SiteAnalyticsTsControllerStreamViewers1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} streamId stream id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteAnalyticsTsControllerStreamViewers1(v: SiteAnalyticsTsControllerStreamViewers1VEnum, language: SiteAnalyticsTsControllerStreamViewers1LanguageEnum, projectId: number, streamId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteAnalyticsTsControllerStreamViewers1(v, language, projectId, streamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.siteAnalyticsTsControllerStreamViewers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Bitrate for stream
         * @param {SiteAnalyticsTsControllerStreamBitrate1VEnum} v Version
         * @param {SiteAnalyticsTsControllerStreamBitrate1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} streamId stream id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteAnalyticsTsControllerStreamBitrate1(v: SiteAnalyticsTsControllerStreamBitrate1VEnum, language: SiteAnalyticsTsControllerStreamBitrate1LanguageEnum, projectId: number, streamId: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.siteAnalyticsTsControllerStreamBitrate1(v, language, projectId, streamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Events for stream
         * @param {SiteAnalyticsTsControllerStreamEvents1VEnum} v Version
         * @param {SiteAnalyticsTsControllerStreamEvents1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} streamId stream id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteAnalyticsTsControllerStreamEvents1(v: SiteAnalyticsTsControllerStreamEvents1VEnum, language: SiteAnalyticsTsControllerStreamEvents1LanguageEnum, projectId: number, streamId: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.siteAnalyticsTsControllerStreamEvents1(v, language, projectId, streamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Viewers for stream
         * @param {SiteAnalyticsTsControllerStreamViewers1VEnum} v Version
         * @param {SiteAnalyticsTsControllerStreamViewers1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} streamId stream id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteAnalyticsTsControllerStreamViewers1(v: SiteAnalyticsTsControllerStreamViewers1VEnum, language: SiteAnalyticsTsControllerStreamViewers1LanguageEnum, projectId: number, streamId: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.siteAnalyticsTsControllerStreamViewers1(v, language, projectId, streamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * 
     * @summary Bitrate for stream
     * @param {SiteAnalyticsTsControllerStreamBitrate1VEnum} v Version
     * @param {SiteAnalyticsTsControllerStreamBitrate1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} streamId stream id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public siteAnalyticsTsControllerStreamBitrate1(v: SiteAnalyticsTsControllerStreamBitrate1VEnum, language: SiteAnalyticsTsControllerStreamBitrate1LanguageEnum, projectId: number, streamId: number, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).siteAnalyticsTsControllerStreamBitrate1(v, language, projectId, streamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Events for stream
     * @param {SiteAnalyticsTsControllerStreamEvents1VEnum} v Version
     * @param {SiteAnalyticsTsControllerStreamEvents1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} streamId stream id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public siteAnalyticsTsControllerStreamEvents1(v: SiteAnalyticsTsControllerStreamEvents1VEnum, language: SiteAnalyticsTsControllerStreamEvents1LanguageEnum, projectId: number, streamId: number, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).siteAnalyticsTsControllerStreamEvents1(v, language, projectId, streamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Viewers for stream
     * @param {SiteAnalyticsTsControllerStreamViewers1VEnum} v Version
     * @param {SiteAnalyticsTsControllerStreamViewers1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} streamId stream id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public siteAnalyticsTsControllerStreamViewers1(v: SiteAnalyticsTsControllerStreamViewers1VEnum, language: SiteAnalyticsTsControllerStreamViewers1LanguageEnum, projectId: number, streamId: number, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).siteAnalyticsTsControllerStreamViewers1(v, language, projectId, streamId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SiteAnalyticsTsControllerStreamBitrate1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteAnalyticsTsControllerStreamBitrate1VEnum = typeof SiteAnalyticsTsControllerStreamBitrate1VEnum[keyof typeof SiteAnalyticsTsControllerStreamBitrate1VEnum];
/**
 * @export
 */
export const SiteAnalyticsTsControllerStreamBitrate1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteAnalyticsTsControllerStreamBitrate1LanguageEnum = typeof SiteAnalyticsTsControllerStreamBitrate1LanguageEnum[keyof typeof SiteAnalyticsTsControllerStreamBitrate1LanguageEnum];
/**
 * @export
 */
export const SiteAnalyticsTsControllerStreamEvents1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteAnalyticsTsControllerStreamEvents1VEnum = typeof SiteAnalyticsTsControllerStreamEvents1VEnum[keyof typeof SiteAnalyticsTsControllerStreamEvents1VEnum];
/**
 * @export
 */
export const SiteAnalyticsTsControllerStreamEvents1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteAnalyticsTsControllerStreamEvents1LanguageEnum = typeof SiteAnalyticsTsControllerStreamEvents1LanguageEnum[keyof typeof SiteAnalyticsTsControllerStreamEvents1LanguageEnum];
/**
 * @export
 */
export const SiteAnalyticsTsControllerStreamViewers1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteAnalyticsTsControllerStreamViewers1VEnum = typeof SiteAnalyticsTsControllerStreamViewers1VEnum[keyof typeof SiteAnalyticsTsControllerStreamViewers1VEnum];
/**
 * @export
 */
export const SiteAnalyticsTsControllerStreamViewers1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteAnalyticsTsControllerStreamViewers1LanguageEnum = typeof SiteAnalyticsTsControllerStreamViewers1LanguageEnum[keyof typeof SiteAnalyticsTsControllerStreamViewers1LanguageEnum];


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Auth telegram
         * @param {AuthControllerAuthTelegram1VEnum} v Version
         * @param {AuthControllerAuthTelegram1LanguageEnum} language Current language
         * @param {number} authDate Time auth
         * @param {number} id Telegram userId
         * @param {string} firstName First name
         * @param {string} hash Hash
         * @param {AuthControllerAuthTelegram1AppEnum} app App oauth
         * @param {string} [lastName] Last name
         * @param {string} [username] Nickname
         * @param {string} [photoUrl] Photo
         * @param {string} [languageCode] IETF language tag of the user\&#39;s language
         * @param {boolean} [isPremium] True, if this user is a Telegram Premium user
         * @param {boolean} [addedToAttachmentMenu] True, if this user added the bot to the attachment menu
         * @param {string} [refId] Referal id
         * @param {string} [redirect] Redirect url
         * @param {string} [country] Country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerAuthTelegram1: async (v: AuthControllerAuthTelegram1VEnum, language: AuthControllerAuthTelegram1LanguageEnum, authDate: number, id: number, firstName: string, hash: string, app: AuthControllerAuthTelegram1AppEnum, lastName?: string, username?: string, photoUrl?: string, languageCode?: string, isPremium?: boolean, addedToAttachmentMenu?: boolean, refId?: string, redirect?: string, country?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('authControllerAuthTelegram1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('authControllerAuthTelegram1', 'language', language)
            // verify required parameter 'authDate' is not null or undefined
            assertParamExists('authControllerAuthTelegram1', 'authDate', authDate)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authControllerAuthTelegram1', 'id', id)
            // verify required parameter 'firstName' is not null or undefined
            assertParamExists('authControllerAuthTelegram1', 'firstName', firstName)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('authControllerAuthTelegram1', 'hash', hash)
            // verify required parameter 'app' is not null or undefined
            assertParamExists('authControllerAuthTelegram1', 'app', app)
            const localVarPath = `/method/auth/auth-telegram`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (authDate !== undefined) {
                localVarQueryParameter['auth_date'] = authDate;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['first_name'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['last_name'] = lastName;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (photoUrl !== undefined) {
                localVarQueryParameter['photo_url'] = photoUrl;
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            if (isPremium !== undefined) {
                localVarQueryParameter['is_premium'] = isPremium;
            }

            if (addedToAttachmentMenu !== undefined) {
                localVarQueryParameter['added_to_attachment_menu'] = addedToAttachmentMenu;
            }

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }

            if (refId !== undefined) {
                localVarQueryParameter['refId'] = refId;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Internal request of auth google
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCallbackGoogle1: async (state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'state' is not null or undefined
            assertParamExists('authControllerCallbackGoogle1', 'state', state)
            const localVarPath = `/method/auth/callback/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Internal request of auth old vk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCallbackVk1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/method/auth/callback/vk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Internal request of auth new vk
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCallbackVkId1: async (state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'state' is not null or undefined
            assertParamExists('authControllerCallbackVkId1', 'state', state)
            const localVarPath = `/method/auth/callback/vk-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get code for auth
         * @param {AuthControllerCode1VEnum} v Version
         * @param {AuthControllerCode1LanguageEnum} language Current language
         * @param {AuthControllerCode1AppEnum} app Create auth code for app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCode1: async (v: AuthControllerCode1VEnum, language: AuthControllerCode1LanguageEnum, app: AuthControllerCode1AppEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('authControllerCode1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('authControllerCode1', 'language', language)
            // verify required parameter 'app' is not null or undefined
            assertParamExists('authControllerCode1', 'app', app)
            const localVarPath = `/method/auth/app/code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Connected social account
         * @param {AuthControllerConnect1VEnum} v Version
         * @param {AuthControllerConnect1LanguageEnum} language Current language
         * @param {AuthControllerConnect1ProviderEnum} provider Provider oauth
         * @param {AuthControllerConnect1AppEnum} [app] App oauth
         * @param {string} [redirect] Redirect url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerConnect1: async (v: AuthControllerConnect1VEnum, language: AuthControllerConnect1LanguageEnum, provider: AuthControllerConnect1ProviderEnum, app?: AuthControllerConnect1AppEnum, redirect?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('authControllerConnect1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('authControllerConnect1', 'language', language)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('authControllerConnect1', 'provider', provider)
            const localVarPath = `/method/auth/connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary CallBack for connect social
         * @param {AuthControllerConnectResult1VEnum} v Version
         * @param {AuthControllerConnectResult1LanguageEnum} language Current language
         * @param {string} message Result message for connect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerConnectResult1: async (v: AuthControllerConnectResult1VEnum, language: AuthControllerConnectResult1LanguageEnum, message: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('authControllerConnectResult1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('authControllerConnectResult1', 'language', language)
            // verify required parameter 'message' is not null or undefined
            assertParamExists('authControllerConnectResult1', 'message', message)
            const localVarPath = `/method/auth/connect/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (message !== undefined) {
                localVarQueryParameter['message'] = message;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Connect telegram in account
         * @param {AuthControllerConnectTelegram1VEnum} v Version
         * @param {AuthControllerConnectTelegram1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerConnectTelegram1: async (v: AuthControllerConnectTelegram1VEnum, language: AuthControllerConnectTelegram1LanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('authControllerConnectTelegram1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('authControllerConnectTelegram1', 'language', language)
            const localVarPath = `/method/auth/connect-telegram`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disconnected social account
         * @param {AuthControllerDisconnect1VEnum} v Version
         * @param {AuthControllerDisconnect1LanguageEnum} language Current language
         * @param {number} socialId Social id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerDisconnect1: async (v: AuthControllerDisconnect1VEnum, language: AuthControllerDisconnect1LanguageEnum, socialId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('authControllerDisconnect1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('authControllerDisconnect1', 'language', language)
            // verify required parameter 'socialId' is not null or undefined
            assertParamExists('authControllerDisconnect1', 'socialId', socialId)
            const localVarPath = `/method/auth/disconnect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (socialId !== undefined) {
                localVarQueryParameter['social_id'] = socialId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Code exchange
         * @param {SiteAuthExchangeRequest} siteAuthExchangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerExchange1: async (siteAuthExchangeRequest: SiteAuthExchangeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteAuthExchangeRequest' is not null or undefined
            assertParamExists('authControllerExchange1', 'siteAuthExchangeRequest', siteAuthExchangeRequest)
            const localVarPath = `/method/auth/app/exchange`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteAuthExchangeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get url for start oauth
         * @param {AuthControllerGetAuthUrl1VEnum} v Version
         * @param {AuthControllerGetAuthUrl1LanguageEnum} language Current language
         * @param {AuthControllerGetAuthUrl1ProviderEnum} provider Provider oauth
         * @param {AuthControllerGetAuthUrl1AppEnum} [app] App oauth
         * @param {string} [redirect] Redirect url
         * @param {string} [refId] Referal id
         * @param {string} [country] Country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetAuthUrl1: async (v: AuthControllerGetAuthUrl1VEnum, language: AuthControllerGetAuthUrl1LanguageEnum, provider: AuthControllerGetAuthUrl1ProviderEnum, app?: AuthControllerGetAuthUrl1AppEnum, redirect?: string, refId?: string, country?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('authControllerGetAuthUrl1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('authControllerGetAuthUrl1', 'language', language)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('authControllerGetAuthUrl1', 'provider', provider)
            const localVarPath = `/method/auth/redirect-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }

            if (refId !== undefined) {
                localVarQueryParameter['refId'] = refId;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get basic data for auth user
         * @param {AuthControllerGetProfile1VEnum} v Version
         * @param {AuthControllerGetProfile1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile1: async (v: AuthControllerGetProfile1VEnum, language: AuthControllerGetProfile1LanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('authControllerGetProfile1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('authControllerGetProfile1', 'language', language)
            const localVarPath = `/method/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Guest request of auth
         * @param {string} refId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGuest1: async (refId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refId' is not null or undefined
            assertParamExists('authControllerGuest1', 'refId', refId)
            const localVarPath = `/method/auth/guest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (refId !== undefined) {
                localVarQueryParameter['refId'] = refId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout
         * @param {SiteLogoutAuthRequest} siteLogoutAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout1: async (siteLogoutAuthRequest: SiteLogoutAuthRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteLogoutAuthRequest' is not null or undefined
            assertParamExists('authControllerLogout1', 'siteLogoutAuthRequest', siteLogoutAuthRequest)
            const localVarPath = `/method/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteLogoutAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update access token
         * @param {string} userAgent 
         * @param {SiteRefreshAuthBodyRequest} siteRefreshAuthBodyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshAccess1: async (userAgent: string, siteRefreshAuthBodyRequest: SiteRefreshAuthBodyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAgent' is not null or undefined
            assertParamExists('authControllerRefreshAccess1', 'userAgent', userAgent)
            // verify required parameter 'siteRefreshAuthBodyRequest' is not null or undefined
            assertParamExists('authControllerRefreshAccess1', 'siteRefreshAuthBodyRequest', siteRefreshAuthBodyRequest)
            const localVarPath = `/method/auth/refresh-access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (userAgent != null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteRefreshAuthBodyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Auth telegram
         * @param {AuthControllerAuthTelegram1VEnum} v Version
         * @param {AuthControllerAuthTelegram1LanguageEnum} language Current language
         * @param {number} authDate Time auth
         * @param {number} id Telegram userId
         * @param {string} firstName First name
         * @param {string} hash Hash
         * @param {AuthControllerAuthTelegram1AppEnum} app App oauth
         * @param {string} [lastName] Last name
         * @param {string} [username] Nickname
         * @param {string} [photoUrl] Photo
         * @param {string} [languageCode] IETF language tag of the user\&#39;s language
         * @param {boolean} [isPremium] True, if this user is a Telegram Premium user
         * @param {boolean} [addedToAttachmentMenu] True, if this user added the bot to the attachment menu
         * @param {string} [refId] Referal id
         * @param {string} [redirect] Redirect url
         * @param {string} [country] Country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerAuthTelegram1(v: AuthControllerAuthTelegram1VEnum, language: AuthControllerAuthTelegram1LanguageEnum, authDate: number, id: number, firstName: string, hash: string, app: AuthControllerAuthTelegram1AppEnum, lastName?: string, username?: string, photoUrl?: string, languageCode?: string, isPremium?: boolean, addedToAttachmentMenu?: boolean, refId?: string, redirect?: string, country?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerAuthTelegram1(v, language, authDate, id, firstName, hash, app, lastName, username, photoUrl, languageCode, isPremium, addedToAttachmentMenu, refId, redirect, country, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerAuthTelegram1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Internal request of auth google
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerCallbackGoogle1(state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerCallbackGoogle1(state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerCallbackGoogle1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Internal request of auth old vk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerCallbackVk1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerCallbackVk1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerCallbackVk1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Internal request of auth new vk
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerCallbackVkId1(state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerCallbackVkId1(state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerCallbackVkId1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get code for auth
         * @param {AuthControllerCode1VEnum} v Version
         * @param {AuthControllerCode1LanguageEnum} language Current language
         * @param {AuthControllerCode1AppEnum} app Create auth code for app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerCode1(v: AuthControllerCode1VEnum, language: AuthControllerCode1LanguageEnum, app: AuthControllerCode1AppEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodeAppAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerCode1(v, language, app, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerCode1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Connected social account
         * @param {AuthControllerConnect1VEnum} v Version
         * @param {AuthControllerConnect1LanguageEnum} language Current language
         * @param {AuthControllerConnect1ProviderEnum} provider Provider oauth
         * @param {AuthControllerConnect1AppEnum} [app] App oauth
         * @param {string} [redirect] Redirect url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerConnect1(v: AuthControllerConnect1VEnum, language: AuthControllerConnect1LanguageEnum, provider: AuthControllerConnect1ProviderEnum, app?: AuthControllerConnect1AppEnum, redirect?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerConnect1(v, language, provider, app, redirect, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerConnect1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary CallBack for connect social
         * @param {AuthControllerConnectResult1VEnum} v Version
         * @param {AuthControllerConnectResult1LanguageEnum} language Current language
         * @param {string} message Result message for connect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerConnectResult1(v: AuthControllerConnectResult1VEnum, language: AuthControllerConnectResult1LanguageEnum, message: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerConnectResult1(v, language, message, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerConnectResult1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Connect telegram in account
         * @param {AuthControllerConnectTelegram1VEnum} v Version
         * @param {AuthControllerConnectTelegram1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerConnectTelegram1(v: AuthControllerConnectTelegram1VEnum, language: AuthControllerConnectTelegram1LanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerConnectTelegram1(v, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerConnectTelegram1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Disconnected social account
         * @param {AuthControllerDisconnect1VEnum} v Version
         * @param {AuthControllerDisconnect1LanguageEnum} language Current language
         * @param {number} socialId Social id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerDisconnect1(v: AuthControllerDisconnect1VEnum, language: AuthControllerDisconnect1LanguageEnum, socialId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerDisconnect1(v, language, socialId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerDisconnect1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Code exchange
         * @param {SiteAuthExchangeRequest} siteAuthExchangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerExchange1(siteAuthExchangeRequest: SiteAuthExchangeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerExchange1(siteAuthExchangeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerExchange1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get url for start oauth
         * @param {AuthControllerGetAuthUrl1VEnum} v Version
         * @param {AuthControllerGetAuthUrl1LanguageEnum} language Current language
         * @param {AuthControllerGetAuthUrl1ProviderEnum} provider Provider oauth
         * @param {AuthControllerGetAuthUrl1AppEnum} [app] App oauth
         * @param {string} [redirect] Redirect url
         * @param {string} [refId] Referal id
         * @param {string} [country] Country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetAuthUrl1(v: AuthControllerGetAuthUrl1VEnum, language: AuthControllerGetAuthUrl1LanguageEnum, provider: AuthControllerGetAuthUrl1ProviderEnum, app?: AuthControllerGetAuthUrl1AppEnum, redirect?: string, refId?: string, country?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetAuthUrl1(v, language, provider, app, redirect, refId, country, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetAuthUrl1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get basic data for auth user
         * @param {AuthControllerGetProfile1VEnum} v Version
         * @param {AuthControllerGetProfile1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetProfile1(v: AuthControllerGetProfile1VEnum, language: AuthControllerGetProfile1LanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetProfile1(v, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetProfile1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Guest request of auth
         * @param {string} refId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGuest1(refId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGuest1(refId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGuest1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout
         * @param {SiteLogoutAuthRequest} siteLogoutAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogout1(siteLogoutAuthRequest: SiteLogoutAuthRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogout1(siteLogoutAuthRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLogout1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update access token
         * @param {string} userAgent 
         * @param {SiteRefreshAuthBodyRequest} siteRefreshAuthBodyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefreshAccess1(userAgent: string, siteRefreshAuthBodyRequest: SiteRefreshAuthBodyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefreshAccess1(userAgent, siteRefreshAuthBodyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRefreshAccess1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Auth telegram
         * @param {AuthControllerAuthTelegram1VEnum} v Version
         * @param {AuthControllerAuthTelegram1LanguageEnum} language Current language
         * @param {number} authDate Time auth
         * @param {number} id Telegram userId
         * @param {string} firstName First name
         * @param {string} hash Hash
         * @param {AuthControllerAuthTelegram1AppEnum} app App oauth
         * @param {string} [lastName] Last name
         * @param {string} [username] Nickname
         * @param {string} [photoUrl] Photo
         * @param {string} [languageCode] IETF language tag of the user\&#39;s language
         * @param {boolean} [isPremium] True, if this user is a Telegram Premium user
         * @param {boolean} [addedToAttachmentMenu] True, if this user added the bot to the attachment menu
         * @param {string} [refId] Referal id
         * @param {string} [redirect] Redirect url
         * @param {string} [country] Country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerAuthTelegram1(v: AuthControllerAuthTelegram1VEnum, language: AuthControllerAuthTelegram1LanguageEnum, authDate: number, id: number, firstName: string, hash: string, app: AuthControllerAuthTelegram1AppEnum, lastName?: string, username?: string, photoUrl?: string, languageCode?: string, isPremium?: boolean, addedToAttachmentMenu?: boolean, refId?: string, redirect?: string, country?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerAuthTelegram1(v, language, authDate, id, firstName, hash, app, lastName, username, photoUrl, languageCode, isPremium, addedToAttachmentMenu, refId, redirect, country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Internal request of auth google
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCallbackGoogle1(state: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerCallbackGoogle1(state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Internal request of auth old vk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCallbackVk1(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerCallbackVk1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Internal request of auth new vk
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCallbackVkId1(state: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerCallbackVkId1(state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get code for auth
         * @param {AuthControllerCode1VEnum} v Version
         * @param {AuthControllerCode1LanguageEnum} language Current language
         * @param {AuthControllerCode1AppEnum} app Create auth code for app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCode1(v: AuthControllerCode1VEnum, language: AuthControllerCode1LanguageEnum, app: AuthControllerCode1AppEnum, options?: RawAxiosRequestConfig): AxiosPromise<CodeAppAuthResponse> {
            return localVarFp.authControllerCode1(v, language, app, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Connected social account
         * @param {AuthControllerConnect1VEnum} v Version
         * @param {AuthControllerConnect1LanguageEnum} language Current language
         * @param {AuthControllerConnect1ProviderEnum} provider Provider oauth
         * @param {AuthControllerConnect1AppEnum} [app] App oauth
         * @param {string} [redirect] Redirect url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerConnect1(v: AuthControllerConnect1VEnum, language: AuthControllerConnect1LanguageEnum, provider: AuthControllerConnect1ProviderEnum, app?: AuthControllerConnect1AppEnum, redirect?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerConnect1(v, language, provider, app, redirect, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary CallBack for connect social
         * @param {AuthControllerConnectResult1VEnum} v Version
         * @param {AuthControllerConnectResult1LanguageEnum} language Current language
         * @param {string} message Result message for connect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerConnectResult1(v: AuthControllerConnectResult1VEnum, language: AuthControllerConnectResult1LanguageEnum, message: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerConnectResult1(v, language, message, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Connect telegram in account
         * @param {AuthControllerConnectTelegram1VEnum} v Version
         * @param {AuthControllerConnectTelegram1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerConnectTelegram1(v: AuthControllerConnectTelegram1VEnum, language: AuthControllerConnectTelegram1LanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.authControllerConnectTelegram1(v, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disconnected social account
         * @param {AuthControllerDisconnect1VEnum} v Version
         * @param {AuthControllerDisconnect1LanguageEnum} language Current language
         * @param {number} socialId Social id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerDisconnect1(v: AuthControllerDisconnect1VEnum, language: AuthControllerDisconnect1LanguageEnum, socialId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.authControllerDisconnect1(v, language, socialId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Code exchange
         * @param {SiteAuthExchangeRequest} siteAuthExchangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerExchange1(siteAuthExchangeRequest: SiteAuthExchangeRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefreshAuthResponse> {
            return localVarFp.authControllerExchange1(siteAuthExchangeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get url for start oauth
         * @param {AuthControllerGetAuthUrl1VEnum} v Version
         * @param {AuthControllerGetAuthUrl1LanguageEnum} language Current language
         * @param {AuthControllerGetAuthUrl1ProviderEnum} provider Provider oauth
         * @param {AuthControllerGetAuthUrl1AppEnum} [app] App oauth
         * @param {string} [redirect] Redirect url
         * @param {string} [refId] Referal id
         * @param {string} [country] Country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetAuthUrl1(v: AuthControllerGetAuthUrl1VEnum, language: AuthControllerGetAuthUrl1LanguageEnum, provider: AuthControllerGetAuthUrl1ProviderEnum, app?: AuthControllerGetAuthUrl1AppEnum, redirect?: string, refId?: string, country?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerGetAuthUrl1(v, language, provider, app, redirect, refId, country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get basic data for auth user
         * @param {AuthControllerGetProfile1VEnum} v Version
         * @param {AuthControllerGetProfile1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile1(v: AuthControllerGetProfile1VEnum, language: AuthControllerGetProfile1LanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerGetProfile1(v, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Guest request of auth
         * @param {string} refId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGuest1(refId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerGuest1(refId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout
         * @param {SiteLogoutAuthRequest} siteLogoutAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout1(siteLogoutAuthRequest: SiteLogoutAuthRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.authControllerLogout1(siteLogoutAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update access token
         * @param {string} userAgent 
         * @param {SiteRefreshAuthBodyRequest} siteRefreshAuthBodyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshAccess1(userAgent: string, siteRefreshAuthBodyRequest: SiteRefreshAuthBodyRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefreshAuthResponse> {
            return localVarFp.authControllerRefreshAccess1(userAgent, siteRefreshAuthBodyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Auth telegram
     * @param {AuthControllerAuthTelegram1VEnum} v Version
     * @param {AuthControllerAuthTelegram1LanguageEnum} language Current language
     * @param {number} authDate Time auth
     * @param {number} id Telegram userId
     * @param {string} firstName First name
     * @param {string} hash Hash
     * @param {AuthControllerAuthTelegram1AppEnum} app App oauth
     * @param {string} [lastName] Last name
     * @param {string} [username] Nickname
     * @param {string} [photoUrl] Photo
     * @param {string} [languageCode] IETF language tag of the user\&#39;s language
     * @param {boolean} [isPremium] True, if this user is a Telegram Premium user
     * @param {boolean} [addedToAttachmentMenu] True, if this user added the bot to the attachment menu
     * @param {string} [refId] Referal id
     * @param {string} [redirect] Redirect url
     * @param {string} [country] Country code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerAuthTelegram1(v: AuthControllerAuthTelegram1VEnum, language: AuthControllerAuthTelegram1LanguageEnum, authDate: number, id: number, firstName: string, hash: string, app: AuthControllerAuthTelegram1AppEnum, lastName?: string, username?: string, photoUrl?: string, languageCode?: string, isPremium?: boolean, addedToAttachmentMenu?: boolean, refId?: string, redirect?: string, country?: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerAuthTelegram1(v, language, authDate, id, firstName, hash, app, lastName, username, photoUrl, languageCode, isPremium, addedToAttachmentMenu, refId, redirect, country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Internal request of auth google
     * @param {string} state 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerCallbackGoogle1(state: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerCallbackGoogle1(state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Internal request of auth old vk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerCallbackVk1(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerCallbackVk1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Internal request of auth new vk
     * @param {string} state 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerCallbackVkId1(state: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerCallbackVkId1(state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get code for auth
     * @param {AuthControllerCode1VEnum} v Version
     * @param {AuthControllerCode1LanguageEnum} language Current language
     * @param {AuthControllerCode1AppEnum} app Create auth code for app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerCode1(v: AuthControllerCode1VEnum, language: AuthControllerCode1LanguageEnum, app: AuthControllerCode1AppEnum, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerCode1(v, language, app, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Connected social account
     * @param {AuthControllerConnect1VEnum} v Version
     * @param {AuthControllerConnect1LanguageEnum} language Current language
     * @param {AuthControllerConnect1ProviderEnum} provider Provider oauth
     * @param {AuthControllerConnect1AppEnum} [app] App oauth
     * @param {string} [redirect] Redirect url
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerConnect1(v: AuthControllerConnect1VEnum, language: AuthControllerConnect1LanguageEnum, provider: AuthControllerConnect1ProviderEnum, app?: AuthControllerConnect1AppEnum, redirect?: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerConnect1(v, language, provider, app, redirect, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary CallBack for connect social
     * @param {AuthControllerConnectResult1VEnum} v Version
     * @param {AuthControllerConnectResult1LanguageEnum} language Current language
     * @param {string} message Result message for connect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerConnectResult1(v: AuthControllerConnectResult1VEnum, language: AuthControllerConnectResult1LanguageEnum, message: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerConnectResult1(v, language, message, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Connect telegram in account
     * @param {AuthControllerConnectTelegram1VEnum} v Version
     * @param {AuthControllerConnectTelegram1LanguageEnum} language Current language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerConnectTelegram1(v: AuthControllerConnectTelegram1VEnum, language: AuthControllerConnectTelegram1LanguageEnum, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerConnectTelegram1(v, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disconnected social account
     * @param {AuthControllerDisconnect1VEnum} v Version
     * @param {AuthControllerDisconnect1LanguageEnum} language Current language
     * @param {number} socialId Social id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerDisconnect1(v: AuthControllerDisconnect1VEnum, language: AuthControllerDisconnect1LanguageEnum, socialId: number, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerDisconnect1(v, language, socialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Code exchange
     * @param {SiteAuthExchangeRequest} siteAuthExchangeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerExchange1(siteAuthExchangeRequest: SiteAuthExchangeRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerExchange1(siteAuthExchangeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get url for start oauth
     * @param {AuthControllerGetAuthUrl1VEnum} v Version
     * @param {AuthControllerGetAuthUrl1LanguageEnum} language Current language
     * @param {AuthControllerGetAuthUrl1ProviderEnum} provider Provider oauth
     * @param {AuthControllerGetAuthUrl1AppEnum} [app] App oauth
     * @param {string} [redirect] Redirect url
     * @param {string} [refId] Referal id
     * @param {string} [country] Country code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetAuthUrl1(v: AuthControllerGetAuthUrl1VEnum, language: AuthControllerGetAuthUrl1LanguageEnum, provider: AuthControllerGetAuthUrl1ProviderEnum, app?: AuthControllerGetAuthUrl1AppEnum, redirect?: string, refId?: string, country?: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetAuthUrl1(v, language, provider, app, redirect, refId, country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get basic data for auth user
     * @param {AuthControllerGetProfile1VEnum} v Version
     * @param {AuthControllerGetProfile1LanguageEnum} language Current language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetProfile1(v: AuthControllerGetProfile1VEnum, language: AuthControllerGetProfile1LanguageEnum, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetProfile1(v, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Guest request of auth
     * @param {string} refId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGuest1(refId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGuest1(refId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout
     * @param {SiteLogoutAuthRequest} siteLogoutAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogout1(siteLogoutAuthRequest: SiteLogoutAuthRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogout1(siteLogoutAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update access token
     * @param {string} userAgent 
     * @param {SiteRefreshAuthBodyRequest} siteRefreshAuthBodyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRefreshAccess1(userAgent: string, siteRefreshAuthBodyRequest: SiteRefreshAuthBodyRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRefreshAccess1(userAgent, siteRefreshAuthBodyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AuthControllerAuthTelegram1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type AuthControllerAuthTelegram1VEnum = typeof AuthControllerAuthTelegram1VEnum[keyof typeof AuthControllerAuthTelegram1VEnum];
/**
 * @export
 */
export const AuthControllerAuthTelegram1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type AuthControllerAuthTelegram1LanguageEnum = typeof AuthControllerAuthTelegram1LanguageEnum[keyof typeof AuthControllerAuthTelegram1LanguageEnum];
/**
 * @export
 */
export const AuthControllerAuthTelegram1AppEnum = {
    Site: 'site',
    Admin: 'admin',
    Mobile: 'mobile',
    Desktop: 'desktop'
} as const;
export type AuthControllerAuthTelegram1AppEnum = typeof AuthControllerAuthTelegram1AppEnum[keyof typeof AuthControllerAuthTelegram1AppEnum];
/**
 * @export
 */
export const AuthControllerCode1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type AuthControllerCode1VEnum = typeof AuthControllerCode1VEnum[keyof typeof AuthControllerCode1VEnum];
/**
 * @export
 */
export const AuthControllerCode1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type AuthControllerCode1LanguageEnum = typeof AuthControllerCode1LanguageEnum[keyof typeof AuthControllerCode1LanguageEnum];
/**
 * @export
 */
export const AuthControllerCode1AppEnum = {
    Site: 'site',
    Admin: 'admin',
    Mobile: 'mobile',
    Desktop: 'desktop'
} as const;
export type AuthControllerCode1AppEnum = typeof AuthControllerCode1AppEnum[keyof typeof AuthControllerCode1AppEnum];
/**
 * @export
 */
export const AuthControllerConnect1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type AuthControllerConnect1VEnum = typeof AuthControllerConnect1VEnum[keyof typeof AuthControllerConnect1VEnum];
/**
 * @export
 */
export const AuthControllerConnect1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type AuthControllerConnect1LanguageEnum = typeof AuthControllerConnect1LanguageEnum[keyof typeof AuthControllerConnect1LanguageEnum];
/**
 * @export
 */
export const AuthControllerConnect1ProviderEnum = {
    Google: 'google',
    Vk: 'vk',
    VkId: 'vk-id',
    Telegram: 'telegram'
} as const;
export type AuthControllerConnect1ProviderEnum = typeof AuthControllerConnect1ProviderEnum[keyof typeof AuthControllerConnect1ProviderEnum];
/**
 * @export
 */
export const AuthControllerConnect1AppEnum = {
    Site: 'site',
    Admin: 'admin',
    Mobile: 'mobile',
    Desktop: 'desktop'
} as const;
export type AuthControllerConnect1AppEnum = typeof AuthControllerConnect1AppEnum[keyof typeof AuthControllerConnect1AppEnum];
/**
 * @export
 */
export const AuthControllerConnectResult1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type AuthControllerConnectResult1VEnum = typeof AuthControllerConnectResult1VEnum[keyof typeof AuthControllerConnectResult1VEnum];
/**
 * @export
 */
export const AuthControllerConnectResult1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type AuthControllerConnectResult1LanguageEnum = typeof AuthControllerConnectResult1LanguageEnum[keyof typeof AuthControllerConnectResult1LanguageEnum];
/**
 * @export
 */
export const AuthControllerConnectTelegram1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type AuthControllerConnectTelegram1VEnum = typeof AuthControllerConnectTelegram1VEnum[keyof typeof AuthControllerConnectTelegram1VEnum];
/**
 * @export
 */
export const AuthControllerConnectTelegram1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type AuthControllerConnectTelegram1LanguageEnum = typeof AuthControllerConnectTelegram1LanguageEnum[keyof typeof AuthControllerConnectTelegram1LanguageEnum];
/**
 * @export
 */
export const AuthControllerDisconnect1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type AuthControllerDisconnect1VEnum = typeof AuthControllerDisconnect1VEnum[keyof typeof AuthControllerDisconnect1VEnum];
/**
 * @export
 */
export const AuthControllerDisconnect1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type AuthControllerDisconnect1LanguageEnum = typeof AuthControllerDisconnect1LanguageEnum[keyof typeof AuthControllerDisconnect1LanguageEnum];
/**
 * @export
 */
export const AuthControllerGetAuthUrl1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type AuthControllerGetAuthUrl1VEnum = typeof AuthControllerGetAuthUrl1VEnum[keyof typeof AuthControllerGetAuthUrl1VEnum];
/**
 * @export
 */
export const AuthControllerGetAuthUrl1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type AuthControllerGetAuthUrl1LanguageEnum = typeof AuthControllerGetAuthUrl1LanguageEnum[keyof typeof AuthControllerGetAuthUrl1LanguageEnum];
/**
 * @export
 */
export const AuthControllerGetAuthUrl1ProviderEnum = {
    Google: 'google',
    Vk: 'vk',
    VkId: 'vk-id',
    Telegram: 'telegram'
} as const;
export type AuthControllerGetAuthUrl1ProviderEnum = typeof AuthControllerGetAuthUrl1ProviderEnum[keyof typeof AuthControllerGetAuthUrl1ProviderEnum];
/**
 * @export
 */
export const AuthControllerGetAuthUrl1AppEnum = {
    Site: 'site',
    Admin: 'admin',
    Mobile: 'mobile',
    Desktop: 'desktop'
} as const;
export type AuthControllerGetAuthUrl1AppEnum = typeof AuthControllerGetAuthUrl1AppEnum[keyof typeof AuthControllerGetAuthUrl1AppEnum];
/**
 * @export
 */
export const AuthControllerGetProfile1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type AuthControllerGetProfile1VEnum = typeof AuthControllerGetProfile1VEnum[keyof typeof AuthControllerGetProfile1VEnum];
/**
 * @export
 */
export const AuthControllerGetProfile1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type AuthControllerGetProfile1LanguageEnum = typeof AuthControllerGetProfile1LanguageEnum[keyof typeof AuthControllerGetProfile1LanguageEnum];


/**
 * BlogPageApi - axios parameter creator
 * @export
 */
export const BlogPageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get blog page
         * @param {SiteBlogPageControllerGet1VEnum} v Version
         * @param {SiteBlogPageControllerGet1LanguageEnum} language Current language
         * @param {string} url Url of page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteBlogPageControllerGet1: async (v: SiteBlogPageControllerGet1VEnum, language: SiteBlogPageControllerGet1LanguageEnum, url: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteBlogPageControllerGet1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteBlogPageControllerGet1', 'language', language)
            // verify required parameter 'url' is not null or undefined
            assertParamExists('siteBlogPageControllerGet1', 'url', url)
            const localVarPath = `/method/blog/page/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of blog pages
         * @param {SiteBlogPageControllerList1VEnum} v Version
         * @param {SiteBlogPageControllerList1LanguageEnum} language Current language
         * @param {string} [s] String for search
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteBlogPageControllerList1: async (v: SiteBlogPageControllerList1VEnum, language: SiteBlogPageControllerList1LanguageEnum, s?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteBlogPageControllerList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteBlogPageControllerList1', 'language', language)
            const localVarPath = `/method/blog/page/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (s !== undefined) {
                localVarQueryParameter['s'] = s;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlogPageApi - functional programming interface
 * @export
 */
export const BlogPageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlogPageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get blog page
         * @param {SiteBlogPageControllerGet1VEnum} v Version
         * @param {SiteBlogPageControllerGet1LanguageEnum} language Current language
         * @param {string} url Url of page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteBlogPageControllerGet1(v: SiteBlogPageControllerGet1VEnum, language: SiteBlogPageControllerGet1LanguageEnum, url: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseOfBlogPageSiteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteBlogPageControllerGet1(v, language, url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlogPageApi.siteBlogPageControllerGet1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get list of blog pages
         * @param {SiteBlogPageControllerList1VEnum} v Version
         * @param {SiteBlogPageControllerList1LanguageEnum} language Current language
         * @param {string} [s] String for search
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteBlogPageControllerList1(v: SiteBlogPageControllerList1VEnum, language: SiteBlogPageControllerList1LanguageEnum, s?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseOfBlogPageSiteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteBlogPageControllerList1(v, language, s, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlogPageApi.siteBlogPageControllerList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BlogPageApi - factory interface
 * @export
 */
export const BlogPageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlogPageApiFp(configuration)
    return {
        /**
         * 
         * @summary Get blog page
         * @param {SiteBlogPageControllerGet1VEnum} v Version
         * @param {SiteBlogPageControllerGet1LanguageEnum} language Current language
         * @param {string} url Url of page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteBlogPageControllerGet1(v: SiteBlogPageControllerGet1VEnum, language: SiteBlogPageControllerGet1LanguageEnum, url: string, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseOfBlogPageSiteResponse> {
            return localVarFp.siteBlogPageControllerGet1(v, language, url, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of blog pages
         * @param {SiteBlogPageControllerList1VEnum} v Version
         * @param {SiteBlogPageControllerList1LanguageEnum} language Current language
         * @param {string} [s] String for search
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteBlogPageControllerList1(v: SiteBlogPageControllerList1VEnum, language: SiteBlogPageControllerList1LanguageEnum, s?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseOfBlogPageSiteResponse> {
            return localVarFp.siteBlogPageControllerList1(v, language, s, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlogPageApi - object-oriented interface
 * @export
 * @class BlogPageApi
 * @extends {BaseAPI}
 */
export class BlogPageApi extends BaseAPI {
    /**
     * 
     * @summary Get blog page
     * @param {SiteBlogPageControllerGet1VEnum} v Version
     * @param {SiteBlogPageControllerGet1LanguageEnum} language Current language
     * @param {string} url Url of page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogPageApi
     */
    public siteBlogPageControllerGet1(v: SiteBlogPageControllerGet1VEnum, language: SiteBlogPageControllerGet1LanguageEnum, url: string, options?: RawAxiosRequestConfig) {
        return BlogPageApiFp(this.configuration).siteBlogPageControllerGet1(v, language, url, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of blog pages
     * @param {SiteBlogPageControllerList1VEnum} v Version
     * @param {SiteBlogPageControllerList1LanguageEnum} language Current language
     * @param {string} [s] String for search
     * @param {number} [limit] Number of results
     * @param {number} [offset] Page offset number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogPageApi
     */
    public siteBlogPageControllerList1(v: SiteBlogPageControllerList1VEnum, language: SiteBlogPageControllerList1LanguageEnum, s?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return BlogPageApiFp(this.configuration).siteBlogPageControllerList1(v, language, s, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SiteBlogPageControllerGet1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteBlogPageControllerGet1VEnum = typeof SiteBlogPageControllerGet1VEnum[keyof typeof SiteBlogPageControllerGet1VEnum];
/**
 * @export
 */
export const SiteBlogPageControllerGet1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteBlogPageControllerGet1LanguageEnum = typeof SiteBlogPageControllerGet1LanguageEnum[keyof typeof SiteBlogPageControllerGet1LanguageEnum];
/**
 * @export
 */
export const SiteBlogPageControllerList1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteBlogPageControllerList1VEnum = typeof SiteBlogPageControllerList1VEnum[keyof typeof SiteBlogPageControllerList1VEnum];
/**
 * @export
 */
export const SiteBlogPageControllerList1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteBlogPageControllerList1LanguageEnum = typeof SiteBlogPageControllerList1LanguageEnum[keyof typeof SiteBlogPageControllerList1LanguageEnum];


/**
 * BlogPageTagApi - axios parameter creator
 * @export
 */
export const BlogPageTagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get list of blog pages
         * @param {SiteBlogPageTagControllerList1VEnum} v Version
         * @param {SiteBlogPageTagControllerList1LanguageEnum} language Current language
         * @param {string} [s] String for search
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteBlogPageTagControllerList1: async (v: SiteBlogPageTagControllerList1VEnum, language: SiteBlogPageTagControllerList1LanguageEnum, s?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteBlogPageTagControllerList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteBlogPageTagControllerList1', 'language', language)
            const localVarPath = `/method/blog/tag/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (s !== undefined) {
                localVarQueryParameter['s'] = s;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlogPageTagApi - functional programming interface
 * @export
 */
export const BlogPageTagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlogPageTagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get list of blog pages
         * @param {SiteBlogPageTagControllerList1VEnum} v Version
         * @param {SiteBlogPageTagControllerList1LanguageEnum} language Current language
         * @param {string} [s] String for search
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteBlogPageTagControllerList1(v: SiteBlogPageTagControllerList1VEnum, language: SiteBlogPageTagControllerList1LanguageEnum, s?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseOfSiteBlogPageTagResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteBlogPageTagControllerList1(v, language, s, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlogPageTagApi.siteBlogPageTagControllerList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BlogPageTagApi - factory interface
 * @export
 */
export const BlogPageTagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlogPageTagApiFp(configuration)
    return {
        /**
         * 
         * @summary Get list of blog pages
         * @param {SiteBlogPageTagControllerList1VEnum} v Version
         * @param {SiteBlogPageTagControllerList1LanguageEnum} language Current language
         * @param {string} [s] String for search
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteBlogPageTagControllerList1(v: SiteBlogPageTagControllerList1VEnum, language: SiteBlogPageTagControllerList1LanguageEnum, s?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseOfSiteBlogPageTagResponse> {
            return localVarFp.siteBlogPageTagControllerList1(v, language, s, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlogPageTagApi - object-oriented interface
 * @export
 * @class BlogPageTagApi
 * @extends {BaseAPI}
 */
export class BlogPageTagApi extends BaseAPI {
    /**
     * 
     * @summary Get list of blog pages
     * @param {SiteBlogPageTagControllerList1VEnum} v Version
     * @param {SiteBlogPageTagControllerList1LanguageEnum} language Current language
     * @param {string} [s] String for search
     * @param {number} [limit] Number of results
     * @param {number} [offset] Page offset number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogPageTagApi
     */
    public siteBlogPageTagControllerList1(v: SiteBlogPageTagControllerList1VEnum, language: SiteBlogPageTagControllerList1LanguageEnum, s?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return BlogPageTagApiFp(this.configuration).siteBlogPageTagControllerList1(v, language, s, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SiteBlogPageTagControllerList1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteBlogPageTagControllerList1VEnum = typeof SiteBlogPageTagControllerList1VEnum[keyof typeof SiteBlogPageTagControllerList1VEnum];
/**
 * @export
 */
export const SiteBlogPageTagControllerList1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteBlogPageTagControllerList1LanguageEnum = typeof SiteBlogPageTagControllerList1LanguageEnum[keyof typeof SiteBlogPageTagControllerList1LanguageEnum];


/**
 * BroadcastApi - axios parameter creator
 * @export
 */
export const BroadcastApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get restreams
         * @param {MethodBroadcastControllerRestreamsVEnum} v Version
         * @param {MethodBroadcastControllerRestreamsLanguageEnum} language Current language
         * @param {number} broadcastId broadcast id
         * @param {string} key Chat token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodBroadcastControllerRestreams: async (v: MethodBroadcastControllerRestreamsVEnum, language: MethodBroadcastControllerRestreamsLanguageEnum, broadcastId: number, key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('methodBroadcastControllerRestreams', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('methodBroadcastControllerRestreams', 'language', language)
            // verify required parameter 'broadcastId' is not null or undefined
            assertParamExists('methodBroadcastControllerRestreams', 'broadcastId', broadcastId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('methodBroadcastControllerRestreams', 'key', key)
            const localVarPath = `/method/broadcast/restreams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (broadcastId !== undefined) {
                localVarQueryParameter['broadcast_id'] = broadcastId;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Connect channel, long polling
         * @param {MethodBroadcastControllerTokenChannelVEnum} v Version
         * @param {MethodBroadcastControllerTokenChannelLanguageEnum} language Current language
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodBroadcastControllerTokenChannel: async (v: MethodBroadcastControllerTokenChannelVEnum, language: MethodBroadcastControllerTokenChannelLanguageEnum, key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('methodBroadcastControllerTokenChannel', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('methodBroadcastControllerTokenChannel', 'language', language)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('methodBroadcastControllerTokenChannel', 'key', key)
            const localVarPath = `/method/broadcast/longpoll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BroadcastApi - functional programming interface
 * @export
 */
export const BroadcastApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BroadcastApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get restreams
         * @param {MethodBroadcastControllerRestreamsVEnum} v Version
         * @param {MethodBroadcastControllerRestreamsLanguageEnum} language Current language
         * @param {number} broadcastId broadcast id
         * @param {string} key Chat token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async methodBroadcastControllerRestreams(v: MethodBroadcastControllerRestreamsVEnum, language: MethodBroadcastControllerRestreamsLanguageEnum, broadcastId: number, key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MethodBroadcastRestreamsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.methodBroadcastControllerRestreams(v, language, broadcastId, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.methodBroadcastControllerRestreams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Connect channel, long polling
         * @param {MethodBroadcastControllerTokenChannelVEnum} v Version
         * @param {MethodBroadcastControllerTokenChannelLanguageEnum} language Current language
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async methodBroadcastControllerTokenChannel(v: MethodBroadcastControllerTokenChannelVEnum, language: MethodBroadcastControllerTokenChannelLanguageEnum, key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MethodCurrentBroadcastResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.methodBroadcastControllerTokenChannel(v, language, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.methodBroadcastControllerTokenChannel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BroadcastApi - factory interface
 * @export
 */
export const BroadcastApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BroadcastApiFp(configuration)
    return {
        /**
         * 
         * @summary Get restreams
         * @param {MethodBroadcastControllerRestreamsVEnum} v Version
         * @param {MethodBroadcastControllerRestreamsLanguageEnum} language Current language
         * @param {number} broadcastId broadcast id
         * @param {string} key Chat token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodBroadcastControllerRestreams(v: MethodBroadcastControllerRestreamsVEnum, language: MethodBroadcastControllerRestreamsLanguageEnum, broadcastId: number, key: string, options?: RawAxiosRequestConfig): AxiosPromise<MethodBroadcastRestreamsResponse> {
            return localVarFp.methodBroadcastControllerRestreams(v, language, broadcastId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Connect channel, long polling
         * @param {MethodBroadcastControllerTokenChannelVEnum} v Version
         * @param {MethodBroadcastControllerTokenChannelLanguageEnum} language Current language
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodBroadcastControllerTokenChannel(v: MethodBroadcastControllerTokenChannelVEnum, language: MethodBroadcastControllerTokenChannelLanguageEnum, key: string, options?: RawAxiosRequestConfig): AxiosPromise<MethodCurrentBroadcastResponse> {
            return localVarFp.methodBroadcastControllerTokenChannel(v, language, key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BroadcastApi - object-oriented interface
 * @export
 * @class BroadcastApi
 * @extends {BaseAPI}
 */
export class BroadcastApi extends BaseAPI {
    /**
     * 
     * @summary Get restreams
     * @param {MethodBroadcastControllerRestreamsVEnum} v Version
     * @param {MethodBroadcastControllerRestreamsLanguageEnum} language Current language
     * @param {number} broadcastId broadcast id
     * @param {string} key Chat token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public methodBroadcastControllerRestreams(v: MethodBroadcastControllerRestreamsVEnum, language: MethodBroadcastControllerRestreamsLanguageEnum, broadcastId: number, key: string, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).methodBroadcastControllerRestreams(v, language, broadcastId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Connect channel, long polling
     * @param {MethodBroadcastControllerTokenChannelVEnum} v Version
     * @param {MethodBroadcastControllerTokenChannelLanguageEnum} language Current language
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public methodBroadcastControllerTokenChannel(v: MethodBroadcastControllerTokenChannelVEnum, language: MethodBroadcastControllerTokenChannelLanguageEnum, key: string, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).methodBroadcastControllerTokenChannel(v, language, key, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MethodBroadcastControllerRestreamsVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type MethodBroadcastControllerRestreamsVEnum = typeof MethodBroadcastControllerRestreamsVEnum[keyof typeof MethodBroadcastControllerRestreamsVEnum];
/**
 * @export
 */
export const MethodBroadcastControllerRestreamsLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type MethodBroadcastControllerRestreamsLanguageEnum = typeof MethodBroadcastControllerRestreamsLanguageEnum[keyof typeof MethodBroadcastControllerRestreamsLanguageEnum];
/**
 * @export
 */
export const MethodBroadcastControllerTokenChannelVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type MethodBroadcastControllerTokenChannelVEnum = typeof MethodBroadcastControllerTokenChannelVEnum[keyof typeof MethodBroadcastControllerTokenChannelVEnum];
/**
 * @export
 */
export const MethodBroadcastControllerTokenChannelLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type MethodBroadcastControllerTokenChannelLanguageEnum = typeof MethodBroadcastControllerTokenChannelLanguageEnum[keyof typeof MethodBroadcastControllerTokenChannelLanguageEnum];


/**
 * CentrifugeApi - axios parameter creator
 * @export
 */
export const CentrifugeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *        channel - \"$broadcast:{broadcast_id}\"       expiresIn - 30min     
         * @summary Auth token for broadcast
         * @param {number} broadcastId 
         * @param {GetTokenBroadcastVEnum} v Version
         * @param {GetTokenBroadcastLanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenBroadcast: async (broadcastId: number, v: GetTokenBroadcastVEnum, language: GetTokenBroadcastLanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'broadcastId' is not null or undefined
            assertParamExists('getTokenBroadcast', 'broadcastId', broadcastId)
            // verify required parameter 'v' is not null or undefined
            assertParamExists('getTokenBroadcast', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getTokenBroadcast', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getTokenBroadcast', 'projectId', projectId)
            const localVarPath = `/method/centrifuge/token/broadcast`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (broadcastId !== undefined) {
                localVarQueryParameter['broadcast_id'] = broadcastId;
            }

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Auth centrifuge
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteCentrifugeControllerAuthV21: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteCentrifugeControllerAuthV21', 'projectId', projectId)
            const localVarPath = `/method/centrifuge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *        channel - \"$project_channels:{project_id}\"       expiresIn - 30min       project access min - editor     
         * @summary Auth token for project
         * @param {SiteCentrifugeControllerProject1VEnum} v Version
         * @param {SiteCentrifugeControllerProject1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteCentrifugeControllerProject1: async (v: SiteCentrifugeControllerProject1VEnum, language: SiteCentrifugeControllerProject1LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteCentrifugeControllerProject1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteCentrifugeControllerProject1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteCentrifugeControllerProject1', 'projectId', projectId)
            const localVarPath = `/method/centrifuge/auth/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CentrifugeApi - functional programming interface
 * @export
 */
export const CentrifugeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CentrifugeApiAxiosParamCreator(configuration)
    return {
        /**
         *        channel - \"$broadcast:{broadcast_id}\"       expiresIn - 30min     
         * @summary Auth token for broadcast
         * @param {number} broadcastId 
         * @param {GetTokenBroadcastVEnum} v Version
         * @param {GetTokenBroadcastLanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenBroadcast(broadcastId: number, v: GetTokenBroadcastVEnum, language: GetTokenBroadcastLanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteAuthCentrifugeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenBroadcast(broadcastId, v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CentrifugeApi.getTokenBroadcast']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Auth centrifuge
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteCentrifugeControllerAuthV21(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteAuthCentrifugeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteCentrifugeControllerAuthV21(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CentrifugeApi.siteCentrifugeControllerAuthV21']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *        channel - \"$project_channels:{project_id}\"       expiresIn - 30min       project access min - editor     
         * @summary Auth token for project
         * @param {SiteCentrifugeControllerProject1VEnum} v Version
         * @param {SiteCentrifugeControllerProject1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteCentrifugeControllerProject1(v: SiteCentrifugeControllerProject1VEnum, language: SiteCentrifugeControllerProject1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteAuthCentrifugeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteCentrifugeControllerProject1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CentrifugeApi.siteCentrifugeControllerProject1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CentrifugeApi - factory interface
 * @export
 */
export const CentrifugeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CentrifugeApiFp(configuration)
    return {
        /**
         *        channel - \"$broadcast:{broadcast_id}\"       expiresIn - 30min     
         * @summary Auth token for broadcast
         * @param {number} broadcastId 
         * @param {GetTokenBroadcastVEnum} v Version
         * @param {GetTokenBroadcastLanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenBroadcast(broadcastId: number, v: GetTokenBroadcastVEnum, language: GetTokenBroadcastLanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<SiteAuthCentrifugeResponse> {
            return localVarFp.getTokenBroadcast(broadcastId, v, language, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Auth centrifuge
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteCentrifugeControllerAuthV21(projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<SiteAuthCentrifugeResponse> {
            return localVarFp.siteCentrifugeControllerAuthV21(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         *        channel - \"$project_channels:{project_id}\"       expiresIn - 30min       project access min - editor     
         * @summary Auth token for project
         * @param {SiteCentrifugeControllerProject1VEnum} v Version
         * @param {SiteCentrifugeControllerProject1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteCentrifugeControllerProject1(v: SiteCentrifugeControllerProject1VEnum, language: SiteCentrifugeControllerProject1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<SiteAuthCentrifugeResponse> {
            return localVarFp.siteCentrifugeControllerProject1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CentrifugeApi - object-oriented interface
 * @export
 * @class CentrifugeApi
 * @extends {BaseAPI}
 */
export class CentrifugeApi extends BaseAPI {
    /**
     *        channel - \"$broadcast:{broadcast_id}\"       expiresIn - 30min     
     * @summary Auth token for broadcast
     * @param {number} broadcastId 
     * @param {GetTokenBroadcastVEnum} v Version
     * @param {GetTokenBroadcastLanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CentrifugeApi
     */
    public getTokenBroadcast(broadcastId: number, v: GetTokenBroadcastVEnum, language: GetTokenBroadcastLanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return CentrifugeApiFp(this.configuration).getTokenBroadcast(broadcastId, v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Auth centrifuge
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CentrifugeApi
     */
    public siteCentrifugeControllerAuthV21(projectId: number, options?: RawAxiosRequestConfig) {
        return CentrifugeApiFp(this.configuration).siteCentrifugeControllerAuthV21(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *        channel - \"$project_channels:{project_id}\"       expiresIn - 30min       project access min - editor     
     * @summary Auth token for project
     * @param {SiteCentrifugeControllerProject1VEnum} v Version
     * @param {SiteCentrifugeControllerProject1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CentrifugeApi
     */
    public siteCentrifugeControllerProject1(v: SiteCentrifugeControllerProject1VEnum, language: SiteCentrifugeControllerProject1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return CentrifugeApiFp(this.configuration).siteCentrifugeControllerProject1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetTokenBroadcastVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type GetTokenBroadcastVEnum = typeof GetTokenBroadcastVEnum[keyof typeof GetTokenBroadcastVEnum];
/**
 * @export
 */
export const GetTokenBroadcastLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type GetTokenBroadcastLanguageEnum = typeof GetTokenBroadcastLanguageEnum[keyof typeof GetTokenBroadcastLanguageEnum];
/**
 * @export
 */
export const SiteCentrifugeControllerProject1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteCentrifugeControllerProject1VEnum = typeof SiteCentrifugeControllerProject1VEnum[keyof typeof SiteCentrifugeControllerProject1VEnum];
/**
 * @export
 */
export const SiteCentrifugeControllerProject1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteCentrifugeControllerProject1LanguageEnum = typeof SiteCentrifugeControllerProject1LanguageEnum[keyof typeof SiteCentrifugeControllerProject1LanguageEnum];


/**
 * ChannelApi - axios parameter creator
 * @export
 */
export const ChannelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Search channel list
         * @param {MethodControllerSearchVEnum} v Version
         * @param {MethodControllerSearchLanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {MethodControllerSearchTypeEnum} [type] 
         * @param {string} [platform] platform type
         * @param {string} [name] name
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodControllerSearch: async (v: MethodControllerSearchVEnum, language: MethodControllerSearchLanguageEnum, projectId: number, type?: MethodControllerSearchTypeEnum, platform?: string, name?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('methodControllerSearch', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('methodControllerSearch', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('methodControllerSearch', 'projectId', projectId)
            const localVarPath = `/method/channel/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get live status
         * @param {MethodSetStatusChannelRequest} methodSetStatusChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodControllerSetStatus: async (methodSetStatusChannelRequest: MethodSetStatusChannelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'methodSetStatusChannelRequest' is not null or undefined
            assertParamExists('methodControllerSetStatus', 'methodSetStatusChannelRequest', methodSetStatusChannelRequest)
            const localVarPath = `/method/channel/set-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(methodSetStatusChannelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Minimal channel list
         * @param {SiteChannelControllerShortChannelList1VEnum} v Version
         * @param {SiteChannelControllerShortChannelList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelControllerShortChannelList1: async (v: SiteChannelControllerShortChannelList1VEnum, language: SiteChannelControllerShortChannelList1LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteChannelControllerShortChannelList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteChannelControllerShortChannelList1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteChannelControllerShortChannelList1', 'projectId', projectId)
            const localVarPath = `/method/channel/short`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelApi - functional programming interface
 * @export
 */
export const ChannelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChannelApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Search channel list
         * @param {MethodControllerSearchVEnum} v Version
         * @param {MethodControllerSearchLanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {MethodControllerSearchTypeEnum} [type] 
         * @param {string} [platform] platform type
         * @param {string} [name] name
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async methodControllerSearch(v: MethodControllerSearchVEnum, language: MethodControllerSearchLanguageEnum, projectId: number, type?: MethodControllerSearchTypeEnum, platform?: string, name?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteSearchChannelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.methodControllerSearch(v, language, projectId, type, platform, name, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelApi.methodControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get live status
         * @param {MethodSetStatusChannelRequest} methodSetStatusChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async methodControllerSetStatus(methodSetStatusChannelRequest: MethodSetStatusChannelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.methodControllerSetStatus(methodSetStatusChannelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelApi.methodControllerSetStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Minimal channel list
         * @param {SiteChannelControllerShortChannelList1VEnum} v Version
         * @param {SiteChannelControllerShortChannelList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelControllerShortChannelList1(v: SiteChannelControllerShortChannelList1VEnum, language: SiteChannelControllerShortChannelList1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteGetShortChannelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelControllerShortChannelList1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelApi.siteChannelControllerShortChannelList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChannelApi - factory interface
 * @export
 */
export const ChannelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChannelApiFp(configuration)
    return {
        /**
         * 
         * @summary Search channel list
         * @param {MethodControllerSearchVEnum} v Version
         * @param {MethodControllerSearchLanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {MethodControllerSearchTypeEnum} [type] 
         * @param {string} [platform] platform type
         * @param {string} [name] name
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodControllerSearch(v: MethodControllerSearchVEnum, language: MethodControllerSearchLanguageEnum, projectId: number, type?: MethodControllerSearchTypeEnum, platform?: string, name?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<SiteSearchChannelResponse> {
            return localVarFp.methodControllerSearch(v, language, projectId, type, platform, name, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get live status
         * @param {MethodSetStatusChannelRequest} methodSetStatusChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodControllerSetStatus(methodSetStatusChannelRequest: MethodSetStatusChannelRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.methodControllerSetStatus(methodSetStatusChannelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Minimal channel list
         * @param {SiteChannelControllerShortChannelList1VEnum} v Version
         * @param {SiteChannelControllerShortChannelList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelControllerShortChannelList1(v: SiteChannelControllerShortChannelList1VEnum, language: SiteChannelControllerShortChannelList1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<SiteGetShortChannelResponse> {
            return localVarFp.siteChannelControllerShortChannelList1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChannelApi - object-oriented interface
 * @export
 * @class ChannelApi
 * @extends {BaseAPI}
 */
export class ChannelApi extends BaseAPI {
    /**
     * 
     * @summary Search channel list
     * @param {MethodControllerSearchVEnum} v Version
     * @param {MethodControllerSearchLanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {MethodControllerSearchTypeEnum} [type] 
     * @param {string} [platform] platform type
     * @param {string} [name] name
     * @param {number} [limit] Number of results
     * @param {number} [offset] Page offset number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public methodControllerSearch(v: MethodControllerSearchVEnum, language: MethodControllerSearchLanguageEnum, projectId: number, type?: MethodControllerSearchTypeEnum, platform?: string, name?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ChannelApiFp(this.configuration).methodControllerSearch(v, language, projectId, type, platform, name, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get live status
     * @param {MethodSetStatusChannelRequest} methodSetStatusChannelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public methodControllerSetStatus(methodSetStatusChannelRequest: MethodSetStatusChannelRequest, options?: RawAxiosRequestConfig) {
        return ChannelApiFp(this.configuration).methodControllerSetStatus(methodSetStatusChannelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Minimal channel list
     * @param {SiteChannelControllerShortChannelList1VEnum} v Version
     * @param {SiteChannelControllerShortChannelList1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public siteChannelControllerShortChannelList1(v: SiteChannelControllerShortChannelList1VEnum, language: SiteChannelControllerShortChannelList1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return ChannelApiFp(this.configuration).siteChannelControllerShortChannelList1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MethodControllerSearchVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type MethodControllerSearchVEnum = typeof MethodControllerSearchVEnum[keyof typeof MethodControllerSearchVEnum];
/**
 * @export
 */
export const MethodControllerSearchLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type MethodControllerSearchLanguageEnum = typeof MethodControllerSearchLanguageEnum[keyof typeof MethodControllerSearchLanguageEnum];
/**
 * @export
 */
export const MethodControllerSearchTypeEnum = {
    All: 'all',
    My: 'my',
    Available: 'available',
    Active: 'active'
} as const;
export type MethodControllerSearchTypeEnum = typeof MethodControllerSearchTypeEnum[keyof typeof MethodControllerSearchTypeEnum];
/**
 * @export
 */
export const SiteChannelControllerShortChannelList1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteChannelControllerShortChannelList1VEnum = typeof SiteChannelControllerShortChannelList1VEnum[keyof typeof SiteChannelControllerShortChannelList1VEnum];
/**
 * @export
 */
export const SiteChannelControllerShortChannelList1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteChannelControllerShortChannelList1LanguageEnum = typeof SiteChannelControllerShortChannelList1LanguageEnum[keyof typeof SiteChannelControllerShortChannelList1LanguageEnum];


/**
 * ChannelSettingsApi - axios parameter creator
 * @export
 */
export const ChannelSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get telegram settings
         * @param {SiteChannelChatControllerGetTelegramSetting1VEnum} v Version
         * @param {SiteChannelChatControllerGetTelegramSetting1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelChatControllerGetTelegramSetting1: async (v: SiteChannelChatControllerGetTelegramSetting1VEnum, language: SiteChannelChatControllerGetTelegramSetting1LanguageEnum, projectId: number, channelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteChannelChatControllerGetTelegramSetting1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteChannelChatControllerGetTelegramSetting1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteChannelChatControllerGetTelegramSetting1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteChannelChatControllerGetTelegramSetting1', 'channelId', channelId)
            const localVarPath = `/method/channel_settings/chat/telegram/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get code for connected chat
         * @param {SiteChannelChatControllerInitTelegramChatConnect1VEnum} v Version
         * @param {SiteChannelChatControllerInitTelegramChatConnect1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelChatControllerInitTelegramChatConnect1: async (v: SiteChannelChatControllerInitTelegramChatConnect1VEnum, language: SiteChannelChatControllerInitTelegramChatConnect1LanguageEnum, projectId: number, channelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteChannelChatControllerInitTelegramChatConnect1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteChannelChatControllerInitTelegramChatConnect1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteChannelChatControllerInitTelegramChatConnect1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteChannelChatControllerInitTelegramChatConnect1', 'channelId', channelId)
            const localVarPath = `/method/channel_settings/chat/telegram/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disconnect telegram chat
         * @param {SiteChannelChatControllerRemoveTelegramChat1VEnum} v Version
         * @param {SiteChannelChatControllerRemoveTelegramChat1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelChatControllerRemoveTelegramChat1: async (v: SiteChannelChatControllerRemoveTelegramChat1VEnum, language: SiteChannelChatControllerRemoveTelegramChat1LanguageEnum, projectId: number, channelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteChannelChatControllerRemoveTelegramChat1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteChannelChatControllerRemoveTelegramChat1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteChannelChatControllerRemoveTelegramChat1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteChannelChatControllerRemoveTelegramChat1', 'channelId', channelId)
            const localVarPath = `/method/channel_settings/chat/telegram/disconnect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set telegram settings
         * @param {SiteChannelChatControllerSetTelegramSetting1VEnum} v Version
         * @param {SiteChannelChatControllerSetTelegramSetting1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {SiteTelegramSetSettingsRequestDto} siteTelegramSetSettingsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelChatControllerSetTelegramSetting1: async (v: SiteChannelChatControllerSetTelegramSetting1VEnum, language: SiteChannelChatControllerSetTelegramSetting1LanguageEnum, projectId: number, channelId: number, siteTelegramSetSettingsRequestDto: SiteTelegramSetSettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteChannelChatControllerSetTelegramSetting1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteChannelChatControllerSetTelegramSetting1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteChannelChatControllerSetTelegramSetting1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteChannelChatControllerSetTelegramSetting1', 'channelId', channelId)
            // verify required parameter 'siteTelegramSetSettingsRequestDto' is not null or undefined
            assertParamExists('siteChannelChatControllerSetTelegramSetting1', 'siteTelegramSetSettingsRequestDto', siteTelegramSetSettingsRequestDto)
            const localVarPath = `/method/channel_settings/chat/telegram/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteTelegramSetSettingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get telegram post list
         * @param {SiteChannelChatControllerTelegramPosts1VEnum} v Version
         * @param {SiteChannelChatControllerTelegramPosts1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelChatControllerTelegramPosts1: async (v: SiteChannelChatControllerTelegramPosts1VEnum, language: SiteChannelChatControllerTelegramPosts1LanguageEnum, projectId: number, channelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteChannelChatControllerTelegramPosts1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteChannelChatControllerTelegramPosts1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteChannelChatControllerTelegramPosts1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteChannelChatControllerTelegramPosts1', 'channelId', channelId)
            const localVarPath = `/method/channel_settings/chat/telegram/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Optional settings for telegram
         * @param {SiteUpdateChatTelegramRequest} siteUpdateChatTelegramRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelChatControllerUpdateOptionsTelegram1: async (siteUpdateChatTelegramRequest: SiteUpdateChatTelegramRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteUpdateChatTelegramRequest' is not null or undefined
            assertParamExists('siteChannelChatControllerUpdateOptionsTelegram1', 'siteUpdateChatTelegramRequest', siteUpdateChatTelegramRequest)
            const localVarPath = `/method/channel_settings/chat/setTelegram`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteUpdateChatTelegramRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get planned list
         * @param {SiteChannelOptionsControllerGetPlanned1VEnum} v Version
         * @param {SiteChannelOptionsControllerGetPlanned1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelOptionsControllerGetPlanned1: async (v: SiteChannelOptionsControllerGetPlanned1VEnum, language: SiteChannelOptionsControllerGetPlanned1LanguageEnum, projectId: number, channelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteChannelOptionsControllerGetPlanned1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteChannelOptionsControllerGetPlanned1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteChannelOptionsControllerGetPlanned1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteChannelOptionsControllerGetPlanned1', 'channelId', channelId)
            const localVarPath = `/method/channel_settings/options/getPlanned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get playlists from the platform
         * @param {SiteChannelOptionsControllerGetPlayList1VEnum} v Version
         * @param {SiteChannelOptionsControllerGetPlayList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelOptionsControllerGetPlayList1: async (v: SiteChannelOptionsControllerGetPlayList1VEnum, language: SiteChannelOptionsControllerGetPlayList1LanguageEnum, projectId: number, channelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteChannelOptionsControllerGetPlayList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteChannelOptionsControllerGetPlayList1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteChannelOptionsControllerGetPlayList1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteChannelOptionsControllerGetPlayList1', 'channelId', channelId)
            const localVarPath = `/method/channel_settings/options/getPlaylist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Optional settings for ok. Depends on the tariff.
         * @param {SiteUpdateOptionsOkRequest} siteUpdateOptionsOkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelOptionsControllerUpdateOptionsOk1: async (siteUpdateOptionsOkRequest: SiteUpdateOptionsOkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteUpdateOptionsOkRequest' is not null or undefined
            assertParamExists('siteChannelOptionsControllerUpdateOptionsOk1', 'siteUpdateOptionsOkRequest', siteUpdateOptionsOkRequest)
            const localVarPath = `/method/channel_settings/options/setOk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteUpdateOptionsOkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Optional settings for trovo. Depends on the tariff.
         * @param {SiteUpdateOptionsTrovoRequest} siteUpdateOptionsTrovoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelOptionsControllerUpdateOptionsTrovo1: async (siteUpdateOptionsTrovoRequest: SiteUpdateOptionsTrovoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteUpdateOptionsTrovoRequest' is not null or undefined
            assertParamExists('siteChannelOptionsControllerUpdateOptionsTrovo1', 'siteUpdateOptionsTrovoRequest', siteUpdateOptionsTrovoRequest)
            const localVarPath = `/method/channel_settings/options/setTrovo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteUpdateOptionsTrovoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Optional settings for twitch. Depends on the tariff.
         * @param {SiteUpdateOptionsTwitchRequest} siteUpdateOptionsTwitchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelOptionsControllerUpdateOptionsTwitch1: async (siteUpdateOptionsTwitchRequest: SiteUpdateOptionsTwitchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteUpdateOptionsTwitchRequest' is not null or undefined
            assertParamExists('siteChannelOptionsControllerUpdateOptionsTwitch1', 'siteUpdateOptionsTwitchRequest', siteUpdateOptionsTwitchRequest)
            const localVarPath = `/method/channel_settings/options/setTwitch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteUpdateOptionsTwitchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Optional settings for vk. Depends on the tariff.
         * @param {SiteUpdateOptionsVkRequest} siteUpdateOptionsVkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelOptionsControllerUpdateOptionsVk1: async (siteUpdateOptionsVkRequest: SiteUpdateOptionsVkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteUpdateOptionsVkRequest' is not null or undefined
            assertParamExists('siteChannelOptionsControllerUpdateOptionsVk1', 'siteUpdateOptionsVkRequest', siteUpdateOptionsVkRequest)
            const localVarPath = `/method/channel_settings/options/setVk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteUpdateOptionsVkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Optional settings for vk video live. Depends on the tariff.
         * @param {SiteUpdateOptionsVkVideoLiveRequest} siteUpdateOptionsVkVideoLiveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelOptionsControllerUpdateOptionsVkVideoLive1: async (siteUpdateOptionsVkVideoLiveRequest: SiteUpdateOptionsVkVideoLiveRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteUpdateOptionsVkVideoLiveRequest' is not null or undefined
            assertParamExists('siteChannelOptionsControllerUpdateOptionsVkVideoLive1', 'siteUpdateOptionsVkVideoLiveRequest', siteUpdateOptionsVkVideoLiveRequest)
            const localVarPath = `/method/channel_settings/options/setVkVideoLive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteUpdateOptionsVkVideoLiveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Optional settings for youtube. Depends on the tariff.
         * @param {SiteUpdateOptionsYoutubeRequest} siteUpdateOptionsYoutubeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelOptionsControllerUpdateOptionsYoutube1: async (siteUpdateOptionsYoutubeRequest: SiteUpdateOptionsYoutubeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteUpdateOptionsYoutubeRequest' is not null or undefined
            assertParamExists('siteChannelOptionsControllerUpdateOptionsYoutube1', 'siteUpdateOptionsYoutubeRequest', siteUpdateOptionsYoutubeRequest)
            const localVarPath = `/method/channel_settings/options/setYoutube`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteUpdateOptionsYoutubeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set planned id. Depends on the tariff.
         * @param {SiteSetPlannedRequest} siteSetPlannedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelOptionsControllerUpdatePlanned1: async (siteSetPlannedRequest: SiteSetPlannedRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteSetPlannedRequest' is not null or undefined
            assertParamExists('siteChannelOptionsControllerUpdatePlanned1', 'siteSetPlannedRequest', siteSetPlannedRequest)
            const localVarPath = `/method/channel_settings/options/setPlanned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteSetPlannedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get status platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelSettingControllerGetStatus1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/method/channel_settings/getStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set name from custom channel. Global settings.
         * @param {SiteSetNameRequest} siteSetNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelSettingControllerSetName1: async (siteSetNameRequest: SiteSetNameRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteSetNameRequest' is not null or undefined
            assertParamExists('siteChannelSettingControllerSetName1', 'siteSetNameRequest', siteSetNameRequest)
            const localVarPath = `/method/channel_settings/setName`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteSetNameRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set rtmp url from channel. Global settings.
         * @param {SiteSetUrlRequest} siteSetUrlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelSettingControllerUpdateRtmp1: async (siteSetUrlRequest: SiteSetUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteSetUrlRequest' is not null or undefined
            assertParamExists('siteChannelSettingControllerUpdateRtmp1', 'siteSetUrlRequest', siteSetUrlRequest)
            const localVarPath = `/method/channel_settings/setRtmp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteSetUrlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get status platform
         * @param {SiteChannelSettingControllerUpdateToken1VEnum} v Version
         * @param {SiteChannelSettingControllerUpdateToken1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {SiteChannelSettingControllerUpdateToken1RoleEnum} role Token role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelSettingControllerUpdateToken1: async (v: SiteChannelSettingControllerUpdateToken1VEnum, language: SiteChannelSettingControllerUpdateToken1LanguageEnum, projectId: number, channelId: number, role: SiteChannelSettingControllerUpdateToken1RoleEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteChannelSettingControllerUpdateToken1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteChannelSettingControllerUpdateToken1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteChannelSettingControllerUpdateToken1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteChannelSettingControllerUpdateToken1', 'channelId', channelId)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('siteChannelSettingControllerUpdateToken1', 'role', role)
            const localVarPath = `/method/channel_settings/update-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set transcoder from channel. Personal settings.
         * @param {SiteSetTranscoderRequest} siteSetTranscoderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelSettingControllerUpdateTranscoder1: async (siteSetTranscoderRequest: SiteSetTranscoderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteSetTranscoderRequest' is not null or undefined
            assertParamExists('siteChannelSettingControllerUpdateTranscoder1', 'siteSetTranscoderRequest', siteSetTranscoderRequest)
            const localVarPath = `/method/channel_settings/setTranscoder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteSetTranscoderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get telegram post by filter
         * @param {TelegramGetPostByFilterVEnum} v Version
         * @param {TelegramGetPostByFilterLanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {number} filterMode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegramGetPostByFilter: async (v: TelegramGetPostByFilterVEnum, language: TelegramGetPostByFilterLanguageEnum, projectId: number, channelId: number, filterMode: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('telegramGetPostByFilter', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('telegramGetPostByFilter', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('telegramGetPostByFilter', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('telegramGetPostByFilter', 'channelId', channelId)
            // verify required parameter 'filterMode' is not null or undefined
            assertParamExists('telegramGetPostByFilter', 'filterMode', filterMode)
            const localVarPath = `/method/channel_settings/chat/telegram/posts/get-by-filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }

            if (filterMode !== undefined) {
                localVarQueryParameter['filter_mode'] = filterMode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelSettingsApi - functional programming interface
 * @export
 */
export const ChannelSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChannelSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get telegram settings
         * @param {SiteChannelChatControllerGetTelegramSetting1VEnum} v Version
         * @param {SiteChannelChatControllerGetTelegramSetting1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelChatControllerGetTelegramSetting1(v: SiteChannelChatControllerGetTelegramSetting1VEnum, language: SiteChannelChatControllerGetTelegramSetting1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TelegramSettingsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelChatControllerGetTelegramSetting1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelChatControllerGetTelegramSetting1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get code for connected chat
         * @param {SiteChannelChatControllerInitTelegramChatConnect1VEnum} v Version
         * @param {SiteChannelChatControllerInitTelegramChatConnect1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelChatControllerInitTelegramChatConnect1(v: SiteChannelChatControllerInitTelegramChatConnect1VEnum, language: SiteChannelChatControllerInitTelegramChatConnect1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TelegramInitConnectResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelChatControllerInitTelegramChatConnect1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelChatControllerInitTelegramChatConnect1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Disconnect telegram chat
         * @param {SiteChannelChatControllerRemoveTelegramChat1VEnum} v Version
         * @param {SiteChannelChatControllerRemoveTelegramChat1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelChatControllerRemoveTelegramChat1(v: SiteChannelChatControllerRemoveTelegramChat1VEnum, language: SiteChannelChatControllerRemoveTelegramChat1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelChatControllerRemoveTelegramChat1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelChatControllerRemoveTelegramChat1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set telegram settings
         * @param {SiteChannelChatControllerSetTelegramSetting1VEnum} v Version
         * @param {SiteChannelChatControllerSetTelegramSetting1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {SiteTelegramSetSettingsRequestDto} siteTelegramSetSettingsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelChatControllerSetTelegramSetting1(v: SiteChannelChatControllerSetTelegramSetting1VEnum, language: SiteChannelChatControllerSetTelegramSetting1LanguageEnum, projectId: number, channelId: number, siteTelegramSetSettingsRequestDto: SiteTelegramSetSettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelChatControllerSetTelegramSetting1(v, language, projectId, channelId, siteTelegramSetSettingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelChatControllerSetTelegramSetting1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get telegram post list
         * @param {SiteChannelChatControllerTelegramPosts1VEnum} v Version
         * @param {SiteChannelChatControllerTelegramPosts1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelChatControllerTelegramPosts1(v: SiteChannelChatControllerTelegramPosts1VEnum, language: SiteChannelChatControllerTelegramPosts1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteTelegramChatPostsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelChatControllerTelegramPosts1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelChatControllerTelegramPosts1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Optional settings for telegram
         * @param {SiteUpdateChatTelegramRequest} siteUpdateChatTelegramRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelChatControllerUpdateOptionsTelegram1(siteUpdateChatTelegramRequest: SiteUpdateChatTelegramRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelChatControllerUpdateOptionsTelegram1(siteUpdateChatTelegramRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelChatControllerUpdateOptionsTelegram1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get planned list
         * @param {SiteChannelOptionsControllerGetPlanned1VEnum} v Version
         * @param {SiteChannelOptionsControllerGetPlanned1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelOptionsControllerGetPlanned1(v: SiteChannelOptionsControllerGetPlanned1VEnum, language: SiteChannelOptionsControllerGetPlanned1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOfSitePlannedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelOptionsControllerGetPlanned1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelOptionsControllerGetPlanned1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get playlists from the platform
         * @param {SiteChannelOptionsControllerGetPlayList1VEnum} v Version
         * @param {SiteChannelOptionsControllerGetPlayList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelOptionsControllerGetPlayList1(v: SiteChannelOptionsControllerGetPlayList1VEnum, language: SiteChannelOptionsControllerGetPlayList1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOfPlaylistItemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelOptionsControllerGetPlayList1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelOptionsControllerGetPlayList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Optional settings for ok. Depends on the tariff.
         * @param {SiteUpdateOptionsOkRequest} siteUpdateOptionsOkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelOptionsControllerUpdateOptionsOk1(siteUpdateOptionsOkRequest: SiteUpdateOptionsOkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelOptionsControllerUpdateOptionsOk1(siteUpdateOptionsOkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelOptionsControllerUpdateOptionsOk1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Optional settings for trovo. Depends on the tariff.
         * @param {SiteUpdateOptionsTrovoRequest} siteUpdateOptionsTrovoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelOptionsControllerUpdateOptionsTrovo1(siteUpdateOptionsTrovoRequest: SiteUpdateOptionsTrovoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelOptionsControllerUpdateOptionsTrovo1(siteUpdateOptionsTrovoRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelOptionsControllerUpdateOptionsTrovo1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Optional settings for twitch. Depends on the tariff.
         * @param {SiteUpdateOptionsTwitchRequest} siteUpdateOptionsTwitchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelOptionsControllerUpdateOptionsTwitch1(siteUpdateOptionsTwitchRequest: SiteUpdateOptionsTwitchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelOptionsControllerUpdateOptionsTwitch1(siteUpdateOptionsTwitchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelOptionsControllerUpdateOptionsTwitch1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Optional settings for vk. Depends on the tariff.
         * @param {SiteUpdateOptionsVkRequest} siteUpdateOptionsVkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelOptionsControllerUpdateOptionsVk1(siteUpdateOptionsVkRequest: SiteUpdateOptionsVkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelOptionsControllerUpdateOptionsVk1(siteUpdateOptionsVkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelOptionsControllerUpdateOptionsVk1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Optional settings for vk video live. Depends on the tariff.
         * @param {SiteUpdateOptionsVkVideoLiveRequest} siteUpdateOptionsVkVideoLiveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelOptionsControllerUpdateOptionsVkVideoLive1(siteUpdateOptionsVkVideoLiveRequest: SiteUpdateOptionsVkVideoLiveRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelOptionsControllerUpdateOptionsVkVideoLive1(siteUpdateOptionsVkVideoLiveRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelOptionsControllerUpdateOptionsVkVideoLive1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Optional settings for youtube. Depends on the tariff.
         * @param {SiteUpdateOptionsYoutubeRequest} siteUpdateOptionsYoutubeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelOptionsControllerUpdateOptionsYoutube1(siteUpdateOptionsYoutubeRequest: SiteUpdateOptionsYoutubeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelOptionsControllerUpdateOptionsYoutube1(siteUpdateOptionsYoutubeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelOptionsControllerUpdateOptionsYoutube1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set planned id. Depends on the tariff.
         * @param {SiteSetPlannedRequest} siteSetPlannedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelOptionsControllerUpdatePlanned1(siteSetPlannedRequest: SiteSetPlannedRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SitePlannedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelOptionsControllerUpdatePlanned1(siteSetPlannedRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelOptionsControllerUpdatePlanned1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get status platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelSettingControllerGetStatus1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteChannelStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelSettingControllerGetStatus1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelSettingControllerGetStatus1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set name from custom channel. Global settings.
         * @param {SiteSetNameRequest} siteSetNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelSettingControllerSetName1(siteSetNameRequest: SiteSetNameRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelSettingControllerSetName1(siteSetNameRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelSettingControllerSetName1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set rtmp url from channel. Global settings.
         * @param {SiteSetUrlRequest} siteSetUrlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelSettingControllerUpdateRtmp1(siteSetUrlRequest: SiteSetUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelSettingControllerUpdateRtmp1(siteSetUrlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelSettingControllerUpdateRtmp1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get status platform
         * @param {SiteChannelSettingControllerUpdateToken1VEnum} v Version
         * @param {SiteChannelSettingControllerUpdateToken1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {SiteChannelSettingControllerUpdateToken1RoleEnum} role Token role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelSettingControllerUpdateToken1(v: SiteChannelSettingControllerUpdateToken1VEnum, language: SiteChannelSettingControllerUpdateToken1LanguageEnum, projectId: number, channelId: number, role: SiteChannelSettingControllerUpdateToken1RoleEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelSettingControllerUpdateToken1(v, language, projectId, channelId, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelSettingControllerUpdateToken1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set transcoder from channel. Personal settings.
         * @param {SiteSetTranscoderRequest} siteSetTranscoderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteChannelSettingControllerUpdateTranscoder1(siteSetTranscoderRequest: SiteSetTranscoderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteChannelSettingControllerUpdateTranscoder1(siteSetTranscoderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.siteChannelSettingControllerUpdateTranscoder1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get telegram post by filter
         * @param {TelegramGetPostByFilterVEnum} v Version
         * @param {TelegramGetPostByFilterLanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {number} filterMode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async telegramGetPostByFilter(v: TelegramGetPostByFilterVEnum, language: TelegramGetPostByFilterLanguageEnum, projectId: number, channelId: number, filterMode: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteTelegramChatPostsItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.telegramGetPostByFilter(v, language, projectId, channelId, filterMode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.telegramGetPostByFilter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChannelSettingsApi - factory interface
 * @export
 */
export const ChannelSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChannelSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get telegram settings
         * @param {SiteChannelChatControllerGetTelegramSetting1VEnum} v Version
         * @param {SiteChannelChatControllerGetTelegramSetting1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelChatControllerGetTelegramSetting1(v: SiteChannelChatControllerGetTelegramSetting1VEnum, language: SiteChannelChatControllerGetTelegramSetting1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): AxiosPromise<TelegramSettingsResponseDto> {
            return localVarFp.siteChannelChatControllerGetTelegramSetting1(v, language, projectId, channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get code for connected chat
         * @param {SiteChannelChatControllerInitTelegramChatConnect1VEnum} v Version
         * @param {SiteChannelChatControllerInitTelegramChatConnect1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelChatControllerInitTelegramChatConnect1(v: SiteChannelChatControllerInitTelegramChatConnect1VEnum, language: SiteChannelChatControllerInitTelegramChatConnect1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): AxiosPromise<TelegramInitConnectResponseDto> {
            return localVarFp.siteChannelChatControllerInitTelegramChatConnect1(v, language, projectId, channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disconnect telegram chat
         * @param {SiteChannelChatControllerRemoveTelegramChat1VEnum} v Version
         * @param {SiteChannelChatControllerRemoveTelegramChat1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelChatControllerRemoveTelegramChat1(v: SiteChannelChatControllerRemoveTelegramChat1VEnum, language: SiteChannelChatControllerRemoveTelegramChat1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteChannelChatControllerRemoveTelegramChat1(v, language, projectId, channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set telegram settings
         * @param {SiteChannelChatControllerSetTelegramSetting1VEnum} v Version
         * @param {SiteChannelChatControllerSetTelegramSetting1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {SiteTelegramSetSettingsRequestDto} siteTelegramSetSettingsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelChatControllerSetTelegramSetting1(v: SiteChannelChatControllerSetTelegramSetting1VEnum, language: SiteChannelChatControllerSetTelegramSetting1LanguageEnum, projectId: number, channelId: number, siteTelegramSetSettingsRequestDto: SiteTelegramSetSettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteChannelChatControllerSetTelegramSetting1(v, language, projectId, channelId, siteTelegramSetSettingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get telegram post list
         * @param {SiteChannelChatControllerTelegramPosts1VEnum} v Version
         * @param {SiteChannelChatControllerTelegramPosts1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelChatControllerTelegramPosts1(v: SiteChannelChatControllerTelegramPosts1VEnum, language: SiteChannelChatControllerTelegramPosts1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): AxiosPromise<SiteTelegramChatPostsResponseDto> {
            return localVarFp.siteChannelChatControllerTelegramPosts1(v, language, projectId, channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Optional settings for telegram
         * @param {SiteUpdateChatTelegramRequest} siteUpdateChatTelegramRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelChatControllerUpdateOptionsTelegram1(siteUpdateChatTelegramRequest: SiteUpdateChatTelegramRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteChannelChatControllerUpdateOptionsTelegram1(siteUpdateChatTelegramRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get planned list
         * @param {SiteChannelOptionsControllerGetPlanned1VEnum} v Version
         * @param {SiteChannelOptionsControllerGetPlanned1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelOptionsControllerGetPlanned1(v: SiteChannelOptionsControllerGetPlanned1VEnum, language: SiteChannelOptionsControllerGetPlanned1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): AxiosPromise<ListOfSitePlannedResponse> {
            return localVarFp.siteChannelOptionsControllerGetPlanned1(v, language, projectId, channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get playlists from the platform
         * @param {SiteChannelOptionsControllerGetPlayList1VEnum} v Version
         * @param {SiteChannelOptionsControllerGetPlayList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelOptionsControllerGetPlayList1(v: SiteChannelOptionsControllerGetPlayList1VEnum, language: SiteChannelOptionsControllerGetPlayList1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): AxiosPromise<ListOfPlaylistItemResponse> {
            return localVarFp.siteChannelOptionsControllerGetPlayList1(v, language, projectId, channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Optional settings for ok. Depends on the tariff.
         * @param {SiteUpdateOptionsOkRequest} siteUpdateOptionsOkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelOptionsControllerUpdateOptionsOk1(siteUpdateOptionsOkRequest: SiteUpdateOptionsOkRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteChannelOptionsControllerUpdateOptionsOk1(siteUpdateOptionsOkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Optional settings for trovo. Depends on the tariff.
         * @param {SiteUpdateOptionsTrovoRequest} siteUpdateOptionsTrovoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelOptionsControllerUpdateOptionsTrovo1(siteUpdateOptionsTrovoRequest: SiteUpdateOptionsTrovoRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteChannelOptionsControllerUpdateOptionsTrovo1(siteUpdateOptionsTrovoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Optional settings for twitch. Depends on the tariff.
         * @param {SiteUpdateOptionsTwitchRequest} siteUpdateOptionsTwitchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelOptionsControllerUpdateOptionsTwitch1(siteUpdateOptionsTwitchRequest: SiteUpdateOptionsTwitchRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteChannelOptionsControllerUpdateOptionsTwitch1(siteUpdateOptionsTwitchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Optional settings for vk. Depends on the tariff.
         * @param {SiteUpdateOptionsVkRequest} siteUpdateOptionsVkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelOptionsControllerUpdateOptionsVk1(siteUpdateOptionsVkRequest: SiteUpdateOptionsVkRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteChannelOptionsControllerUpdateOptionsVk1(siteUpdateOptionsVkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Optional settings for vk video live. Depends on the tariff.
         * @param {SiteUpdateOptionsVkVideoLiveRequest} siteUpdateOptionsVkVideoLiveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelOptionsControllerUpdateOptionsVkVideoLive1(siteUpdateOptionsVkVideoLiveRequest: SiteUpdateOptionsVkVideoLiveRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteChannelOptionsControllerUpdateOptionsVkVideoLive1(siteUpdateOptionsVkVideoLiveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Optional settings for youtube. Depends on the tariff.
         * @param {SiteUpdateOptionsYoutubeRequest} siteUpdateOptionsYoutubeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelOptionsControllerUpdateOptionsYoutube1(siteUpdateOptionsYoutubeRequest: SiteUpdateOptionsYoutubeRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteChannelOptionsControllerUpdateOptionsYoutube1(siteUpdateOptionsYoutubeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set planned id. Depends on the tariff.
         * @param {SiteSetPlannedRequest} siteSetPlannedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelOptionsControllerUpdatePlanned1(siteSetPlannedRequest: SiteSetPlannedRequest, options?: RawAxiosRequestConfig): AxiosPromise<SitePlannedResponse> {
            return localVarFp.siteChannelOptionsControllerUpdatePlanned1(siteSetPlannedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get status platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelSettingControllerGetStatus1(options?: RawAxiosRequestConfig): AxiosPromise<SiteChannelStatusResponse> {
            return localVarFp.siteChannelSettingControllerGetStatus1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set name from custom channel. Global settings.
         * @param {SiteSetNameRequest} siteSetNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelSettingControllerSetName1(siteSetNameRequest: SiteSetNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteChannelSettingControllerSetName1(siteSetNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set rtmp url from channel. Global settings.
         * @param {SiteSetUrlRequest} siteSetUrlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelSettingControllerUpdateRtmp1(siteSetUrlRequest: SiteSetUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteChannelSettingControllerUpdateRtmp1(siteSetUrlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get status platform
         * @param {SiteChannelSettingControllerUpdateToken1VEnum} v Version
         * @param {SiteChannelSettingControllerUpdateToken1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {SiteChannelSettingControllerUpdateToken1RoleEnum} role Token role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelSettingControllerUpdateToken1(v: SiteChannelSettingControllerUpdateToken1VEnum, language: SiteChannelSettingControllerUpdateToken1LanguageEnum, projectId: number, channelId: number, role: SiteChannelSettingControllerUpdateToken1RoleEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.siteChannelSettingControllerUpdateToken1(v, language, projectId, channelId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set transcoder from channel. Personal settings.
         * @param {SiteSetTranscoderRequest} siteSetTranscoderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteChannelSettingControllerUpdateTranscoder1(siteSetTranscoderRequest: SiteSetTranscoderRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteChannelSettingControllerUpdateTranscoder1(siteSetTranscoderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get telegram post by filter
         * @param {TelegramGetPostByFilterVEnum} v Version
         * @param {TelegramGetPostByFilterLanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {number} filterMode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegramGetPostByFilter(v: TelegramGetPostByFilterVEnum, language: TelegramGetPostByFilterLanguageEnum, projectId: number, channelId: number, filterMode: number, options?: RawAxiosRequestConfig): AxiosPromise<SiteTelegramChatPostsItem> {
            return localVarFp.telegramGetPostByFilter(v, language, projectId, channelId, filterMode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChannelSettingsApi - object-oriented interface
 * @export
 * @class ChannelSettingsApi
 * @extends {BaseAPI}
 */
export class ChannelSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get telegram settings
     * @param {SiteChannelChatControllerGetTelegramSetting1VEnum} v Version
     * @param {SiteChannelChatControllerGetTelegramSetting1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} channelId Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelChatControllerGetTelegramSetting1(v: SiteChannelChatControllerGetTelegramSetting1VEnum, language: SiteChannelChatControllerGetTelegramSetting1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelChatControllerGetTelegramSetting1(v, language, projectId, channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get code for connected chat
     * @param {SiteChannelChatControllerInitTelegramChatConnect1VEnum} v Version
     * @param {SiteChannelChatControllerInitTelegramChatConnect1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} channelId Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelChatControllerInitTelegramChatConnect1(v: SiteChannelChatControllerInitTelegramChatConnect1VEnum, language: SiteChannelChatControllerInitTelegramChatConnect1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelChatControllerInitTelegramChatConnect1(v, language, projectId, channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disconnect telegram chat
     * @param {SiteChannelChatControllerRemoveTelegramChat1VEnum} v Version
     * @param {SiteChannelChatControllerRemoveTelegramChat1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} channelId Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelChatControllerRemoveTelegramChat1(v: SiteChannelChatControllerRemoveTelegramChat1VEnum, language: SiteChannelChatControllerRemoveTelegramChat1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelChatControllerRemoveTelegramChat1(v, language, projectId, channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set telegram settings
     * @param {SiteChannelChatControllerSetTelegramSetting1VEnum} v Version
     * @param {SiteChannelChatControllerSetTelegramSetting1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} channelId Channel id
     * @param {SiteTelegramSetSettingsRequestDto} siteTelegramSetSettingsRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelChatControllerSetTelegramSetting1(v: SiteChannelChatControllerSetTelegramSetting1VEnum, language: SiteChannelChatControllerSetTelegramSetting1LanguageEnum, projectId: number, channelId: number, siteTelegramSetSettingsRequestDto: SiteTelegramSetSettingsRequestDto, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelChatControllerSetTelegramSetting1(v, language, projectId, channelId, siteTelegramSetSettingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get telegram post list
     * @param {SiteChannelChatControllerTelegramPosts1VEnum} v Version
     * @param {SiteChannelChatControllerTelegramPosts1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} channelId Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelChatControllerTelegramPosts1(v: SiteChannelChatControllerTelegramPosts1VEnum, language: SiteChannelChatControllerTelegramPosts1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelChatControllerTelegramPosts1(v, language, projectId, channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Optional settings for telegram
     * @param {SiteUpdateChatTelegramRequest} siteUpdateChatTelegramRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelChatControllerUpdateOptionsTelegram1(siteUpdateChatTelegramRequest: SiteUpdateChatTelegramRequest, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelChatControllerUpdateOptionsTelegram1(siteUpdateChatTelegramRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get planned list
     * @param {SiteChannelOptionsControllerGetPlanned1VEnum} v Version
     * @param {SiteChannelOptionsControllerGetPlanned1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} channelId Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelOptionsControllerGetPlanned1(v: SiteChannelOptionsControllerGetPlanned1VEnum, language: SiteChannelOptionsControllerGetPlanned1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelOptionsControllerGetPlanned1(v, language, projectId, channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get playlists from the platform
     * @param {SiteChannelOptionsControllerGetPlayList1VEnum} v Version
     * @param {SiteChannelOptionsControllerGetPlayList1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} channelId Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelOptionsControllerGetPlayList1(v: SiteChannelOptionsControllerGetPlayList1VEnum, language: SiteChannelOptionsControllerGetPlayList1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelOptionsControllerGetPlayList1(v, language, projectId, channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Optional settings for ok. Depends on the tariff.
     * @param {SiteUpdateOptionsOkRequest} siteUpdateOptionsOkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelOptionsControllerUpdateOptionsOk1(siteUpdateOptionsOkRequest: SiteUpdateOptionsOkRequest, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelOptionsControllerUpdateOptionsOk1(siteUpdateOptionsOkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Optional settings for trovo. Depends on the tariff.
     * @param {SiteUpdateOptionsTrovoRequest} siteUpdateOptionsTrovoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelOptionsControllerUpdateOptionsTrovo1(siteUpdateOptionsTrovoRequest: SiteUpdateOptionsTrovoRequest, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelOptionsControllerUpdateOptionsTrovo1(siteUpdateOptionsTrovoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Optional settings for twitch. Depends on the tariff.
     * @param {SiteUpdateOptionsTwitchRequest} siteUpdateOptionsTwitchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelOptionsControllerUpdateOptionsTwitch1(siteUpdateOptionsTwitchRequest: SiteUpdateOptionsTwitchRequest, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelOptionsControllerUpdateOptionsTwitch1(siteUpdateOptionsTwitchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Optional settings for vk. Depends on the tariff.
     * @param {SiteUpdateOptionsVkRequest} siteUpdateOptionsVkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelOptionsControllerUpdateOptionsVk1(siteUpdateOptionsVkRequest: SiteUpdateOptionsVkRequest, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelOptionsControllerUpdateOptionsVk1(siteUpdateOptionsVkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Optional settings for vk video live. Depends on the tariff.
     * @param {SiteUpdateOptionsVkVideoLiveRequest} siteUpdateOptionsVkVideoLiveRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelOptionsControllerUpdateOptionsVkVideoLive1(siteUpdateOptionsVkVideoLiveRequest: SiteUpdateOptionsVkVideoLiveRequest, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelOptionsControllerUpdateOptionsVkVideoLive1(siteUpdateOptionsVkVideoLiveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Optional settings for youtube. Depends on the tariff.
     * @param {SiteUpdateOptionsYoutubeRequest} siteUpdateOptionsYoutubeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelOptionsControllerUpdateOptionsYoutube1(siteUpdateOptionsYoutubeRequest: SiteUpdateOptionsYoutubeRequest, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelOptionsControllerUpdateOptionsYoutube1(siteUpdateOptionsYoutubeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set planned id. Depends on the tariff.
     * @param {SiteSetPlannedRequest} siteSetPlannedRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelOptionsControllerUpdatePlanned1(siteSetPlannedRequest: SiteSetPlannedRequest, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelOptionsControllerUpdatePlanned1(siteSetPlannedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get status platform
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelSettingControllerGetStatus1(options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelSettingControllerGetStatus1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set name from custom channel. Global settings.
     * @param {SiteSetNameRequest} siteSetNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelSettingControllerSetName1(siteSetNameRequest: SiteSetNameRequest, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelSettingControllerSetName1(siteSetNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set rtmp url from channel. Global settings.
     * @param {SiteSetUrlRequest} siteSetUrlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelSettingControllerUpdateRtmp1(siteSetUrlRequest: SiteSetUrlRequest, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelSettingControllerUpdateRtmp1(siteSetUrlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get status platform
     * @param {SiteChannelSettingControllerUpdateToken1VEnum} v Version
     * @param {SiteChannelSettingControllerUpdateToken1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} channelId Channel id
     * @param {SiteChannelSettingControllerUpdateToken1RoleEnum} role Token role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelSettingControllerUpdateToken1(v: SiteChannelSettingControllerUpdateToken1VEnum, language: SiteChannelSettingControllerUpdateToken1LanguageEnum, projectId: number, channelId: number, role: SiteChannelSettingControllerUpdateToken1RoleEnum, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelSettingControllerUpdateToken1(v, language, projectId, channelId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set transcoder from channel. Personal settings.
     * @param {SiteSetTranscoderRequest} siteSetTranscoderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public siteChannelSettingControllerUpdateTranscoder1(siteSetTranscoderRequest: SiteSetTranscoderRequest, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).siteChannelSettingControllerUpdateTranscoder1(siteSetTranscoderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get telegram post by filter
     * @param {TelegramGetPostByFilterVEnum} v Version
     * @param {TelegramGetPostByFilterLanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} channelId Channel id
     * @param {number} filterMode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public telegramGetPostByFilter(v: TelegramGetPostByFilterVEnum, language: TelegramGetPostByFilterLanguageEnum, projectId: number, channelId: number, filterMode: number, options?: RawAxiosRequestConfig) {
        return ChannelSettingsApiFp(this.configuration).telegramGetPostByFilter(v, language, projectId, channelId, filterMode, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SiteChannelChatControllerGetTelegramSetting1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteChannelChatControllerGetTelegramSetting1VEnum = typeof SiteChannelChatControllerGetTelegramSetting1VEnum[keyof typeof SiteChannelChatControllerGetTelegramSetting1VEnum];
/**
 * @export
 */
export const SiteChannelChatControllerGetTelegramSetting1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteChannelChatControllerGetTelegramSetting1LanguageEnum = typeof SiteChannelChatControllerGetTelegramSetting1LanguageEnum[keyof typeof SiteChannelChatControllerGetTelegramSetting1LanguageEnum];
/**
 * @export
 */
export const SiteChannelChatControllerInitTelegramChatConnect1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteChannelChatControllerInitTelegramChatConnect1VEnum = typeof SiteChannelChatControllerInitTelegramChatConnect1VEnum[keyof typeof SiteChannelChatControllerInitTelegramChatConnect1VEnum];
/**
 * @export
 */
export const SiteChannelChatControllerInitTelegramChatConnect1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteChannelChatControllerInitTelegramChatConnect1LanguageEnum = typeof SiteChannelChatControllerInitTelegramChatConnect1LanguageEnum[keyof typeof SiteChannelChatControllerInitTelegramChatConnect1LanguageEnum];
/**
 * @export
 */
export const SiteChannelChatControllerRemoveTelegramChat1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteChannelChatControllerRemoveTelegramChat1VEnum = typeof SiteChannelChatControllerRemoveTelegramChat1VEnum[keyof typeof SiteChannelChatControllerRemoveTelegramChat1VEnum];
/**
 * @export
 */
export const SiteChannelChatControllerRemoveTelegramChat1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteChannelChatControllerRemoveTelegramChat1LanguageEnum = typeof SiteChannelChatControllerRemoveTelegramChat1LanguageEnum[keyof typeof SiteChannelChatControllerRemoveTelegramChat1LanguageEnum];
/**
 * @export
 */
export const SiteChannelChatControllerSetTelegramSetting1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteChannelChatControllerSetTelegramSetting1VEnum = typeof SiteChannelChatControllerSetTelegramSetting1VEnum[keyof typeof SiteChannelChatControllerSetTelegramSetting1VEnum];
/**
 * @export
 */
export const SiteChannelChatControllerSetTelegramSetting1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteChannelChatControllerSetTelegramSetting1LanguageEnum = typeof SiteChannelChatControllerSetTelegramSetting1LanguageEnum[keyof typeof SiteChannelChatControllerSetTelegramSetting1LanguageEnum];
/**
 * @export
 */
export const SiteChannelChatControllerTelegramPosts1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteChannelChatControllerTelegramPosts1VEnum = typeof SiteChannelChatControllerTelegramPosts1VEnum[keyof typeof SiteChannelChatControllerTelegramPosts1VEnum];
/**
 * @export
 */
export const SiteChannelChatControllerTelegramPosts1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteChannelChatControllerTelegramPosts1LanguageEnum = typeof SiteChannelChatControllerTelegramPosts1LanguageEnum[keyof typeof SiteChannelChatControllerTelegramPosts1LanguageEnum];
/**
 * @export
 */
export const SiteChannelOptionsControllerGetPlanned1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteChannelOptionsControllerGetPlanned1VEnum = typeof SiteChannelOptionsControllerGetPlanned1VEnum[keyof typeof SiteChannelOptionsControllerGetPlanned1VEnum];
/**
 * @export
 */
export const SiteChannelOptionsControllerGetPlanned1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteChannelOptionsControllerGetPlanned1LanguageEnum = typeof SiteChannelOptionsControllerGetPlanned1LanguageEnum[keyof typeof SiteChannelOptionsControllerGetPlanned1LanguageEnum];
/**
 * @export
 */
export const SiteChannelOptionsControllerGetPlayList1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteChannelOptionsControllerGetPlayList1VEnum = typeof SiteChannelOptionsControllerGetPlayList1VEnum[keyof typeof SiteChannelOptionsControllerGetPlayList1VEnum];
/**
 * @export
 */
export const SiteChannelOptionsControllerGetPlayList1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteChannelOptionsControllerGetPlayList1LanguageEnum = typeof SiteChannelOptionsControllerGetPlayList1LanguageEnum[keyof typeof SiteChannelOptionsControllerGetPlayList1LanguageEnum];
/**
 * @export
 */
export const SiteChannelSettingControllerUpdateToken1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteChannelSettingControllerUpdateToken1VEnum = typeof SiteChannelSettingControllerUpdateToken1VEnum[keyof typeof SiteChannelSettingControllerUpdateToken1VEnum];
/**
 * @export
 */
export const SiteChannelSettingControllerUpdateToken1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteChannelSettingControllerUpdateToken1LanguageEnum = typeof SiteChannelSettingControllerUpdateToken1LanguageEnum[keyof typeof SiteChannelSettingControllerUpdateToken1LanguageEnum];
/**
 * @export
 */
export const SiteChannelSettingControllerUpdateToken1RoleEnum = {
    Account: 'account',
    Group: 'group'
} as const;
export type SiteChannelSettingControllerUpdateToken1RoleEnum = typeof SiteChannelSettingControllerUpdateToken1RoleEnum[keyof typeof SiteChannelSettingControllerUpdateToken1RoleEnum];
/**
 * @export
 */
export const TelegramGetPostByFilterVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type TelegramGetPostByFilterVEnum = typeof TelegramGetPostByFilterVEnum[keyof typeof TelegramGetPostByFilterVEnum];
/**
 * @export
 */
export const TelegramGetPostByFilterLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type TelegramGetPostByFilterLanguageEnum = typeof TelegramGetPostByFilterLanguageEnum[keyof typeof TelegramGetPostByFilterLanguageEnum];


/**
 * ChatGatewayApi - axios parameter creator
 * @export
 */
export const ChatGatewayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove message
         * @param {MethodChatGatewayControllerDeleteVEnum} v Version
         * @param {MethodChatGatewayControllerDeleteLanguageEnum} language Current language
         * @param {string} key Key
         * @param {number} broadcastId broadcast id
         * @param {string} eventId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodChatGatewayControllerDelete: async (v: MethodChatGatewayControllerDeleteVEnum, language: MethodChatGatewayControllerDeleteLanguageEnum, key: string, broadcastId: number, eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('methodChatGatewayControllerDelete', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('methodChatGatewayControllerDelete', 'language', language)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('methodChatGatewayControllerDelete', 'key', key)
            // verify required parameter 'broadcastId' is not null or undefined
            assertParamExists('methodChatGatewayControllerDelete', 'broadcastId', broadcastId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('methodChatGatewayControllerDelete', 'eventId', eventId)
            const localVarPath = `/method/chat/messages/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (broadcastId !== undefined) {
                localVarQueryParameter['broadcast_id'] = broadcastId;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['event_id'] = eventId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get one message
         * @param {MethodChatGatewayControllerGetMessageVEnum} v Version
         * @param {MethodChatGatewayControllerGetMessageLanguageEnum} language Current language
         * @param {string} key Key
         * @param {number} broadcastId broadcast id
         * @param {string} eventId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodChatGatewayControllerGetMessage: async (v: MethodChatGatewayControllerGetMessageVEnum, language: MethodChatGatewayControllerGetMessageLanguageEnum, key: string, broadcastId: number, eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('methodChatGatewayControllerGetMessage', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('methodChatGatewayControllerGetMessage', 'language', language)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('methodChatGatewayControllerGetMessage', 'key', key)
            // verify required parameter 'broadcastId' is not null or undefined
            assertParamExists('methodChatGatewayControllerGetMessage', 'broadcastId', broadcastId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('methodChatGatewayControllerGetMessage', 'eventId', eventId)
            const localVarPath = `/method/chat/messages/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (broadcastId !== undefined) {
                localVarQueryParameter['broadcast_id'] = broadcastId;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['event_id'] = eventId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List history message
         * @param {MethodChatGatewayControllerHistoryVEnum} v Version
         * @param {MethodChatGatewayControllerHistoryLanguageEnum} language Current language
         * @param {string} key Key
         * @param {number} broadcastId broadcast id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodChatGatewayControllerHistory: async (v: MethodChatGatewayControllerHistoryVEnum, language: MethodChatGatewayControllerHistoryLanguageEnum, key: string, broadcastId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('methodChatGatewayControllerHistory', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('methodChatGatewayControllerHistory', 'language', language)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('methodChatGatewayControllerHistory', 'key', key)
            // verify required parameter 'broadcastId' is not null or undefined
            assertParamExists('methodChatGatewayControllerHistory', 'broadcastId', broadcastId)
            const localVarPath = `/method/chat/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (broadcastId !== undefined) {
                localVarQueryParameter['broadcast_id'] = broadcastId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send message
         * @param {MethodChatGatewayControllerSendVEnum} v Version
         * @param {MethodChatGatewayControllerSendLanguageEnum} language Current language
         * @param {string} key Key
         * @param {number} broadcastId 
         * @param {MethodChatSendMessageRequestDto} methodChatSendMessageRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodChatGatewayControllerSend: async (v: MethodChatGatewayControllerSendVEnum, language: MethodChatGatewayControllerSendLanguageEnum, key: string, broadcastId: number, methodChatSendMessageRequestDto: MethodChatSendMessageRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('methodChatGatewayControllerSend', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('methodChatGatewayControllerSend', 'language', language)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('methodChatGatewayControllerSend', 'key', key)
            // verify required parameter 'broadcastId' is not null or undefined
            assertParamExists('methodChatGatewayControllerSend', 'broadcastId', broadcastId)
            // verify required parameter 'methodChatSendMessageRequestDto' is not null or undefined
            assertParamExists('methodChatGatewayControllerSend', 'methodChatSendMessageRequestDto', methodChatSendMessageRequestDto)
            const localVarPath = `/method/chat/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (broadcastId !== undefined) {
                localVarQueryParameter['broadcast_id'] = broadcastId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(methodChatSendMessageRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatGatewayApi - functional programming interface
 * @export
 */
export const ChatGatewayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatGatewayApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove message
         * @param {MethodChatGatewayControllerDeleteVEnum} v Version
         * @param {MethodChatGatewayControllerDeleteLanguageEnum} language Current language
         * @param {string} key Key
         * @param {number} broadcastId broadcast id
         * @param {string} eventId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async methodChatGatewayControllerDelete(v: MethodChatGatewayControllerDeleteVEnum, language: MethodChatGatewayControllerDeleteLanguageEnum, key: string, broadcastId: number, eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.methodChatGatewayControllerDelete(v, language, key, broadcastId, eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatGatewayApi.methodChatGatewayControllerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get one message
         * @param {MethodChatGatewayControllerGetMessageVEnum} v Version
         * @param {MethodChatGatewayControllerGetMessageLanguageEnum} language Current language
         * @param {string} key Key
         * @param {number} broadcastId broadcast id
         * @param {string} eventId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async methodChatGatewayControllerGetMessage(v: MethodChatGatewayControllerGetMessageVEnum, language: MethodChatGatewayControllerGetMessageLanguageEnum, key: string, broadcastId: number, eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.methodChatGatewayControllerGetMessage(v, language, key, broadcastId, eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatGatewayApi.methodChatGatewayControllerGetMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List history message
         * @param {MethodChatGatewayControllerHistoryVEnum} v Version
         * @param {MethodChatGatewayControllerHistoryLanguageEnum} language Current language
         * @param {string} key Key
         * @param {number} broadcastId broadcast id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async methodChatGatewayControllerHistory(v: MethodChatGatewayControllerHistoryVEnum, language: MethodChatGatewayControllerHistoryLanguageEnum, key: string, broadcastId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MethodChatHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.methodChatGatewayControllerHistory(v, language, key, broadcastId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatGatewayApi.methodChatGatewayControllerHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send message
         * @param {MethodChatGatewayControllerSendVEnum} v Version
         * @param {MethodChatGatewayControllerSendLanguageEnum} language Current language
         * @param {string} key Key
         * @param {number} broadcastId 
         * @param {MethodChatSendMessageRequestDto} methodChatSendMessageRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async methodChatGatewayControllerSend(v: MethodChatGatewayControllerSendVEnum, language: MethodChatGatewayControllerSendLanguageEnum, key: string, broadcastId: number, methodChatSendMessageRequestDto: MethodChatSendMessageRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.methodChatGatewayControllerSend(v, language, key, broadcastId, methodChatSendMessageRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatGatewayApi.methodChatGatewayControllerSend']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatGatewayApi - factory interface
 * @export
 */
export const ChatGatewayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatGatewayApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove message
         * @param {MethodChatGatewayControllerDeleteVEnum} v Version
         * @param {MethodChatGatewayControllerDeleteLanguageEnum} language Current language
         * @param {string} key Key
         * @param {number} broadcastId broadcast id
         * @param {string} eventId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodChatGatewayControllerDelete(v: MethodChatGatewayControllerDeleteVEnum, language: MethodChatGatewayControllerDeleteLanguageEnum, key: string, broadcastId: number, eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.methodChatGatewayControllerDelete(v, language, key, broadcastId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get one message
         * @param {MethodChatGatewayControllerGetMessageVEnum} v Version
         * @param {MethodChatGatewayControllerGetMessageLanguageEnum} language Current language
         * @param {string} key Key
         * @param {number} broadcastId broadcast id
         * @param {string} eventId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodChatGatewayControllerGetMessage(v: MethodChatGatewayControllerGetMessageVEnum, language: MethodChatGatewayControllerGetMessageLanguageEnum, key: string, broadcastId: number, eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDto> {
            return localVarFp.methodChatGatewayControllerGetMessage(v, language, key, broadcastId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List history message
         * @param {MethodChatGatewayControllerHistoryVEnum} v Version
         * @param {MethodChatGatewayControllerHistoryLanguageEnum} language Current language
         * @param {string} key Key
         * @param {number} broadcastId broadcast id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodChatGatewayControllerHistory(v: MethodChatGatewayControllerHistoryVEnum, language: MethodChatGatewayControllerHistoryLanguageEnum, key: string, broadcastId: number, options?: RawAxiosRequestConfig): AxiosPromise<MethodChatHistoryResponse> {
            return localVarFp.methodChatGatewayControllerHistory(v, language, key, broadcastId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send message
         * @param {MethodChatGatewayControllerSendVEnum} v Version
         * @param {MethodChatGatewayControllerSendLanguageEnum} language Current language
         * @param {string} key Key
         * @param {number} broadcastId 
         * @param {MethodChatSendMessageRequestDto} methodChatSendMessageRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodChatGatewayControllerSend(v: MethodChatGatewayControllerSendVEnum, language: MethodChatGatewayControllerSendLanguageEnum, key: string, broadcastId: number, methodChatSendMessageRequestDto: MethodChatSendMessageRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDto> {
            return localVarFp.methodChatGatewayControllerSend(v, language, key, broadcastId, methodChatSendMessageRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatGatewayApi - object-oriented interface
 * @export
 * @class ChatGatewayApi
 * @extends {BaseAPI}
 */
export class ChatGatewayApi extends BaseAPI {
    /**
     * 
     * @summary Remove message
     * @param {MethodChatGatewayControllerDeleteVEnum} v Version
     * @param {MethodChatGatewayControllerDeleteLanguageEnum} language Current language
     * @param {string} key Key
     * @param {number} broadcastId broadcast id
     * @param {string} eventId Event id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatGatewayApi
     */
    public methodChatGatewayControllerDelete(v: MethodChatGatewayControllerDeleteVEnum, language: MethodChatGatewayControllerDeleteLanguageEnum, key: string, broadcastId: number, eventId: string, options?: RawAxiosRequestConfig) {
        return ChatGatewayApiFp(this.configuration).methodChatGatewayControllerDelete(v, language, key, broadcastId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get one message
     * @param {MethodChatGatewayControllerGetMessageVEnum} v Version
     * @param {MethodChatGatewayControllerGetMessageLanguageEnum} language Current language
     * @param {string} key Key
     * @param {number} broadcastId broadcast id
     * @param {string} eventId Event id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatGatewayApi
     */
    public methodChatGatewayControllerGetMessage(v: MethodChatGatewayControllerGetMessageVEnum, language: MethodChatGatewayControllerGetMessageLanguageEnum, key: string, broadcastId: number, eventId: string, options?: RawAxiosRequestConfig) {
        return ChatGatewayApiFp(this.configuration).methodChatGatewayControllerGetMessage(v, language, key, broadcastId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List history message
     * @param {MethodChatGatewayControllerHistoryVEnum} v Version
     * @param {MethodChatGatewayControllerHistoryLanguageEnum} language Current language
     * @param {string} key Key
     * @param {number} broadcastId broadcast id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatGatewayApi
     */
    public methodChatGatewayControllerHistory(v: MethodChatGatewayControllerHistoryVEnum, language: MethodChatGatewayControllerHistoryLanguageEnum, key: string, broadcastId: number, options?: RawAxiosRequestConfig) {
        return ChatGatewayApiFp(this.configuration).methodChatGatewayControllerHistory(v, language, key, broadcastId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send message
     * @param {MethodChatGatewayControllerSendVEnum} v Version
     * @param {MethodChatGatewayControllerSendLanguageEnum} language Current language
     * @param {string} key Key
     * @param {number} broadcastId 
     * @param {MethodChatSendMessageRequestDto} methodChatSendMessageRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatGatewayApi
     */
    public methodChatGatewayControllerSend(v: MethodChatGatewayControllerSendVEnum, language: MethodChatGatewayControllerSendLanguageEnum, key: string, broadcastId: number, methodChatSendMessageRequestDto: MethodChatSendMessageRequestDto, options?: RawAxiosRequestConfig) {
        return ChatGatewayApiFp(this.configuration).methodChatGatewayControllerSend(v, language, key, broadcastId, methodChatSendMessageRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MethodChatGatewayControllerDeleteVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type MethodChatGatewayControllerDeleteVEnum = typeof MethodChatGatewayControllerDeleteVEnum[keyof typeof MethodChatGatewayControllerDeleteVEnum];
/**
 * @export
 */
export const MethodChatGatewayControllerDeleteLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type MethodChatGatewayControllerDeleteLanguageEnum = typeof MethodChatGatewayControllerDeleteLanguageEnum[keyof typeof MethodChatGatewayControllerDeleteLanguageEnum];
/**
 * @export
 */
export const MethodChatGatewayControllerGetMessageVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type MethodChatGatewayControllerGetMessageVEnum = typeof MethodChatGatewayControllerGetMessageVEnum[keyof typeof MethodChatGatewayControllerGetMessageVEnum];
/**
 * @export
 */
export const MethodChatGatewayControllerGetMessageLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type MethodChatGatewayControllerGetMessageLanguageEnum = typeof MethodChatGatewayControllerGetMessageLanguageEnum[keyof typeof MethodChatGatewayControllerGetMessageLanguageEnum];
/**
 * @export
 */
export const MethodChatGatewayControllerHistoryVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type MethodChatGatewayControllerHistoryVEnum = typeof MethodChatGatewayControllerHistoryVEnum[keyof typeof MethodChatGatewayControllerHistoryVEnum];
/**
 * @export
 */
export const MethodChatGatewayControllerHistoryLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type MethodChatGatewayControllerHistoryLanguageEnum = typeof MethodChatGatewayControllerHistoryLanguageEnum[keyof typeof MethodChatGatewayControllerHistoryLanguageEnum];
/**
 * @export
 */
export const MethodChatGatewayControllerSendVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type MethodChatGatewayControllerSendVEnum = typeof MethodChatGatewayControllerSendVEnum[keyof typeof MethodChatGatewayControllerSendVEnum];
/**
 * @export
 */
export const MethodChatGatewayControllerSendLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type MethodChatGatewayControllerSendLanguageEnum = typeof MethodChatGatewayControllerSendLanguageEnum[keyof typeof MethodChatGatewayControllerSendLanguageEnum];


/**
 * HelpPageApi - axios parameter creator
 * @export
 */
export const HelpPageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get help page
         * @param {SiteHelpPageControllerGet1VEnum} v Version
         * @param {SiteHelpPageControllerGet1LanguageEnum} language Current language
         * @param {string} url Url of page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteHelpPageControllerGet1: async (v: SiteHelpPageControllerGet1VEnum, language: SiteHelpPageControllerGet1LanguageEnum, url: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteHelpPageControllerGet1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteHelpPageControllerGet1', 'language', language)
            // verify required parameter 'url' is not null or undefined
            assertParamExists('siteHelpPageControllerGet1', 'url', url)
            const localVarPath = `/method/help/page/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of help pages
         * @param {SiteHelpPageControllerList1VEnum} v Version
         * @param {SiteHelpPageControllerList1LanguageEnum} language Current language
         * @param {string} [s] String for search
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteHelpPageControllerList1: async (v: SiteHelpPageControllerList1VEnum, language: SiteHelpPageControllerList1LanguageEnum, s?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteHelpPageControllerList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteHelpPageControllerList1', 'language', language)
            const localVarPath = `/method/help/page/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (s !== undefined) {
                localVarQueryParameter['s'] = s;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get structure of help pages
         * @param {SiteHelpPageControllerStructure1VEnum} v Version
         * @param {SiteHelpPageControllerStructure1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteHelpPageControllerStructure1: async (v: SiteHelpPageControllerStructure1VEnum, language: SiteHelpPageControllerStructure1LanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteHelpPageControllerStructure1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteHelpPageControllerStructure1', 'language', language)
            const localVarPath = `/method/help/page/structure`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelpPageApi - functional programming interface
 * @export
 */
export const HelpPageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelpPageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get help page
         * @param {SiteHelpPageControllerGet1VEnum} v Version
         * @param {SiteHelpPageControllerGet1LanguageEnum} language Current language
         * @param {string} url Url of page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteHelpPageControllerGet1(v: SiteHelpPageControllerGet1VEnum, language: SiteHelpPageControllerGet1LanguageEnum, url: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetHelpPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteHelpPageControllerGet1(v, language, url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelpPageApi.siteHelpPageControllerGet1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get list of help pages
         * @param {SiteHelpPageControllerList1VEnum} v Version
         * @param {SiteHelpPageControllerList1LanguageEnum} language Current language
         * @param {string} [s] String for search
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteHelpPageControllerList1(v: SiteHelpPageControllerList1VEnum, language: SiteHelpPageControllerList1LanguageEnum, s?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseOfHelpPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteHelpPageControllerList1(v, language, s, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelpPageApi.siteHelpPageControllerList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get structure of help pages
         * @param {SiteHelpPageControllerStructure1VEnum} v Version
         * @param {SiteHelpPageControllerStructure1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteHelpPageControllerStructure1(v: SiteHelpPageControllerStructure1VEnum, language: SiteHelpPageControllerStructure1LanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StructureHelpPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteHelpPageControllerStructure1(v, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelpPageApi.siteHelpPageControllerStructure1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HelpPageApi - factory interface
 * @export
 */
export const HelpPageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelpPageApiFp(configuration)
    return {
        /**
         * 
         * @summary Get help page
         * @param {SiteHelpPageControllerGet1VEnum} v Version
         * @param {SiteHelpPageControllerGet1LanguageEnum} language Current language
         * @param {string} url Url of page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteHelpPageControllerGet1(v: SiteHelpPageControllerGet1VEnum, language: SiteHelpPageControllerGet1LanguageEnum, url: string, options?: RawAxiosRequestConfig): AxiosPromise<GetHelpPageResponse> {
            return localVarFp.siteHelpPageControllerGet1(v, language, url, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of help pages
         * @param {SiteHelpPageControllerList1VEnum} v Version
         * @param {SiteHelpPageControllerList1LanguageEnum} language Current language
         * @param {string} [s] String for search
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteHelpPageControllerList1(v: SiteHelpPageControllerList1VEnum, language: SiteHelpPageControllerList1LanguageEnum, s?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseOfHelpPageResponse> {
            return localVarFp.siteHelpPageControllerList1(v, language, s, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get structure of help pages
         * @param {SiteHelpPageControllerStructure1VEnum} v Version
         * @param {SiteHelpPageControllerStructure1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteHelpPageControllerStructure1(v: SiteHelpPageControllerStructure1VEnum, language: SiteHelpPageControllerStructure1LanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<StructureHelpPageResponse> {
            return localVarFp.siteHelpPageControllerStructure1(v, language, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelpPageApi - object-oriented interface
 * @export
 * @class HelpPageApi
 * @extends {BaseAPI}
 */
export class HelpPageApi extends BaseAPI {
    /**
     * 
     * @summary Get help page
     * @param {SiteHelpPageControllerGet1VEnum} v Version
     * @param {SiteHelpPageControllerGet1LanguageEnum} language Current language
     * @param {string} url Url of page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpPageApi
     */
    public siteHelpPageControllerGet1(v: SiteHelpPageControllerGet1VEnum, language: SiteHelpPageControllerGet1LanguageEnum, url: string, options?: RawAxiosRequestConfig) {
        return HelpPageApiFp(this.configuration).siteHelpPageControllerGet1(v, language, url, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of help pages
     * @param {SiteHelpPageControllerList1VEnum} v Version
     * @param {SiteHelpPageControllerList1LanguageEnum} language Current language
     * @param {string} [s] String for search
     * @param {number} [limit] Number of results
     * @param {number} [offset] Page offset number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpPageApi
     */
    public siteHelpPageControllerList1(v: SiteHelpPageControllerList1VEnum, language: SiteHelpPageControllerList1LanguageEnum, s?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return HelpPageApiFp(this.configuration).siteHelpPageControllerList1(v, language, s, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get structure of help pages
     * @param {SiteHelpPageControllerStructure1VEnum} v Version
     * @param {SiteHelpPageControllerStructure1LanguageEnum} language Current language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpPageApi
     */
    public siteHelpPageControllerStructure1(v: SiteHelpPageControllerStructure1VEnum, language: SiteHelpPageControllerStructure1LanguageEnum, options?: RawAxiosRequestConfig) {
        return HelpPageApiFp(this.configuration).siteHelpPageControllerStructure1(v, language, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SiteHelpPageControllerGet1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteHelpPageControllerGet1VEnum = typeof SiteHelpPageControllerGet1VEnum[keyof typeof SiteHelpPageControllerGet1VEnum];
/**
 * @export
 */
export const SiteHelpPageControllerGet1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteHelpPageControllerGet1LanguageEnum = typeof SiteHelpPageControllerGet1LanguageEnum[keyof typeof SiteHelpPageControllerGet1LanguageEnum];
/**
 * @export
 */
export const SiteHelpPageControllerList1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteHelpPageControllerList1VEnum = typeof SiteHelpPageControllerList1VEnum[keyof typeof SiteHelpPageControllerList1VEnum];
/**
 * @export
 */
export const SiteHelpPageControllerList1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteHelpPageControllerList1LanguageEnum = typeof SiteHelpPageControllerList1LanguageEnum[keyof typeof SiteHelpPageControllerList1LanguageEnum];
/**
 * @export
 */
export const SiteHelpPageControllerStructure1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteHelpPageControllerStructure1VEnum = typeof SiteHelpPageControllerStructure1VEnum[keyof typeof SiteHelpPageControllerStructure1VEnum];
/**
 * @export
 */
export const SiteHelpPageControllerStructure1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteHelpPageControllerStructure1LanguageEnum = typeof SiteHelpPageControllerStructure1LanguageEnum[keyof typeof SiteHelpPageControllerStructure1LanguageEnum];


/**
 * LiveApi - axios parameter creator
 * @export
 */
export const LiveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View live info
         * @param {ControllersControllerRestreams1VEnum} v Version
         * @param {ControllersControllerRestreams1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} broadcastId Broadcast id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        controllersControllerRestreams1: async (v: ControllersControllerRestreams1VEnum, language: ControllersControllerRestreams1LanguageEnum, projectId: number, broadcastId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('controllersControllerRestreams1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('controllersControllerRestreams1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('controllersControllerRestreams1', 'projectId', projectId)
            // verify required parameter 'broadcastId' is not null or undefined
            assertParamExists('controllersControllerRestreams1', 'broadcastId', broadcastId)
            const localVarPath = `/method/live/restreams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (broadcastId !== undefined) {
                localVarQueryParameter['broadcast_id'] = broadcastId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LiveApi - functional programming interface
 * @export
 */
export const LiveApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LiveApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary View live info
         * @param {ControllersControllerRestreams1VEnum} v Version
         * @param {ControllersControllerRestreams1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} broadcastId Broadcast id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async controllersControllerRestreams1(v: ControllersControllerRestreams1VEnum, language: ControllersControllerRestreams1LanguageEnum, projectId: number, broadcastId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteLiveRestreamsInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.controllersControllerRestreams1(v, language, projectId, broadcastId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveApi.controllersControllerRestreams1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LiveApi - factory interface
 * @export
 */
export const LiveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LiveApiFp(configuration)
    return {
        /**
         * 
         * @summary View live info
         * @param {ControllersControllerRestreams1VEnum} v Version
         * @param {ControllersControllerRestreams1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} broadcastId Broadcast id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        controllersControllerRestreams1(v: ControllersControllerRestreams1VEnum, language: ControllersControllerRestreams1LanguageEnum, projectId: number, broadcastId: number, options?: RawAxiosRequestConfig): AxiosPromise<SiteLiveRestreamsInfoResponse> {
            return localVarFp.controllersControllerRestreams1(v, language, projectId, broadcastId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LiveApi - object-oriented interface
 * @export
 * @class LiveApi
 * @extends {BaseAPI}
 */
export class LiveApi extends BaseAPI {
    /**
     * 
     * @summary View live info
     * @param {ControllersControllerRestreams1VEnum} v Version
     * @param {ControllersControllerRestreams1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} broadcastId Broadcast id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveApi
     */
    public controllersControllerRestreams1(v: ControllersControllerRestreams1VEnum, language: ControllersControllerRestreams1LanguageEnum, projectId: number, broadcastId: number, options?: RawAxiosRequestConfig) {
        return LiveApiFp(this.configuration).controllersControllerRestreams1(v, language, projectId, broadcastId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ControllersControllerRestreams1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type ControllersControllerRestreams1VEnum = typeof ControllersControllerRestreams1VEnum[keyof typeof ControllersControllerRestreams1VEnum];
/**
 * @export
 */
export const ControllersControllerRestreams1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type ControllersControllerRestreams1LanguageEnum = typeof ControllersControllerRestreams1LanguageEnum[keyof typeof ControllersControllerRestreams1LanguageEnum];


/**
 * MoneyFlowApi - axios parameter creator
 * @export
 */
export const MoneyFlowApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Transaction list for frontend
         * @param {SiteMoneyFlowControllerList1VEnum} v Version
         * @param {SiteMoneyFlowControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {string} [dateFrom] Date from
         * @param {string} [dateTo] Date to
         * @param {string} [type] Filter code transaction. example 1 or 1,2,3
         * @param {string} [balanceType] Filter code transaction. example 1 or 1,2,3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteMoneyFlowControllerList1: async (v: SiteMoneyFlowControllerList1VEnum, language: SiteMoneyFlowControllerList1LanguageEnum, projectId: number, limit?: number, offset?: number, dateFrom?: string, dateTo?: string, type?: string, balanceType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteMoneyFlowControllerList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteMoneyFlowControllerList1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteMoneyFlowControllerList1', 'projectId', projectId)
            const localVarPath = `/method/money_flow/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString() :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString() :
                    dateTo;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (balanceType !== undefined) {
                localVarQueryParameter['balance_type'] = balanceType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MoneyFlowApi - functional programming interface
 * @export
 */
export const MoneyFlowApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MoneyFlowApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Transaction list for frontend
         * @param {SiteMoneyFlowControllerList1VEnum} v Version
         * @param {SiteMoneyFlowControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {string} [dateFrom] Date from
         * @param {string} [dateTo] Date to
         * @param {string} [type] Filter code transaction. example 1 or 1,2,3
         * @param {string} [balanceType] Filter code transaction. example 1 or 1,2,3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteMoneyFlowControllerList1(v: SiteMoneyFlowControllerList1VEnum, language: SiteMoneyFlowControllerList1LanguageEnum, projectId: number, limit?: number, offset?: number, dateFrom?: string, dateTo?: string, type?: string, balanceType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseOfMoneyFlowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteMoneyFlowControllerList1(v, language, projectId, limit, offset, dateFrom, dateTo, type, balanceType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MoneyFlowApi.siteMoneyFlowControllerList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MoneyFlowApi - factory interface
 * @export
 */
export const MoneyFlowApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MoneyFlowApiFp(configuration)
    return {
        /**
         * 
         * @summary Transaction list for frontend
         * @param {SiteMoneyFlowControllerList1VEnum} v Version
         * @param {SiteMoneyFlowControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {string} [dateFrom] Date from
         * @param {string} [dateTo] Date to
         * @param {string} [type] Filter code transaction. example 1 or 1,2,3
         * @param {string} [balanceType] Filter code transaction. example 1 or 1,2,3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteMoneyFlowControllerList1(v: SiteMoneyFlowControllerList1VEnum, language: SiteMoneyFlowControllerList1LanguageEnum, projectId: number, limit?: number, offset?: number, dateFrom?: string, dateTo?: string, type?: string, balanceType?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseOfMoneyFlowResponse> {
            return localVarFp.siteMoneyFlowControllerList1(v, language, projectId, limit, offset, dateFrom, dateTo, type, balanceType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MoneyFlowApi - object-oriented interface
 * @export
 * @class MoneyFlowApi
 * @extends {BaseAPI}
 */
export class MoneyFlowApi extends BaseAPI {
    /**
     * 
     * @summary Transaction list for frontend
     * @param {SiteMoneyFlowControllerList1VEnum} v Version
     * @param {SiteMoneyFlowControllerList1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} [limit] Number of results
     * @param {number} [offset] Page offset number
     * @param {string} [dateFrom] Date from
     * @param {string} [dateTo] Date to
     * @param {string} [type] Filter code transaction. example 1 or 1,2,3
     * @param {string} [balanceType] Filter code transaction. example 1 or 1,2,3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoneyFlowApi
     */
    public siteMoneyFlowControllerList1(v: SiteMoneyFlowControllerList1VEnum, language: SiteMoneyFlowControllerList1LanguageEnum, projectId: number, limit?: number, offset?: number, dateFrom?: string, dateTo?: string, type?: string, balanceType?: string, options?: RawAxiosRequestConfig) {
        return MoneyFlowApiFp(this.configuration).siteMoneyFlowControllerList1(v, language, projectId, limit, offset, dateFrom, dateTo, type, balanceType, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SiteMoneyFlowControllerList1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteMoneyFlowControllerList1VEnum = typeof SiteMoneyFlowControllerList1VEnum[keyof typeof SiteMoneyFlowControllerList1VEnum];
/**
 * @export
 */
export const SiteMoneyFlowControllerList1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteMoneyFlowControllerList1LanguageEnum = typeof SiteMoneyFlowControllerList1LanguageEnum[keyof typeof SiteMoneyFlowControllerList1LanguageEnum];


/**
 * NotifyHistoryApi - axios parameter creator
 * @export
 */
export const NotifyHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get my NotifyHistory item by id
         * @param {SiteNotifyHistoryControllerGet1VEnum} v Version
         * @param {string} id Id of page in mongodb
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyHistoryControllerGet1: async (v: SiteNotifyHistoryControllerGet1VEnum, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteNotifyHistoryControllerGet1', 'v', v)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('siteNotifyHistoryControllerGet1', 'id', id)
            const localVarPath = `/method/notify_history/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (id !== undefined) {
                localVarQueryParameter['_id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of my notifications
         * @param {SiteNotifyHistoryControllerGetListMy1VEnum} v Version
         * @param {SiteNotifyHistoryControllerGetListMy1LanguageEnum} language Current language
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {number} [projectId] Project id
         * @param {SiteNotifyHistoryControllerGetListMy1NameEnum} [name] Name
         * @param {SiteNotifyHistoryControllerGetListMy1ChannelEnum} [channel] Channel
         * @param {string} [dateFrom] Date from
         * @param {string} [dateTo] Date to
         * @param {SiteNotifyHistoryControllerGetListMy1StatusReadEnum} [statusRead] Status read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyHistoryControllerGetListMy1: async (v: SiteNotifyHistoryControllerGetListMy1VEnum, language: SiteNotifyHistoryControllerGetListMy1LanguageEnum, limit?: number, offset?: number, projectId?: number, name?: SiteNotifyHistoryControllerGetListMy1NameEnum, channel?: SiteNotifyHistoryControllerGetListMy1ChannelEnum, dateFrom?: string, dateTo?: string, statusRead?: SiteNotifyHistoryControllerGetListMy1StatusReadEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteNotifyHistoryControllerGetListMy1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteNotifyHistoryControllerGetListMy1', 'language', language)
            const localVarPath = `/method/notify_history/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString() :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString() :
                    dateTo;
            }

            if (statusRead !== undefined) {
                localVarQueryParameter['status_read'] = statusRead;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get my status unread message for user
         * @param {SiteNotifyHistoryControllerGetStatusMy1VEnum} v Version
         * @param {SiteNotifyHistoryControllerGetStatusMy1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyHistoryControllerGetStatusMy1: async (v: SiteNotifyHistoryControllerGetStatusMy1VEnum, language: SiteNotifyHistoryControllerGetStatusMy1LanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteNotifyHistoryControllerGetStatusMy1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteNotifyHistoryControllerGetStatusMy1', 'language', language)
            const localVarPath = `/method/notify_history/get_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set notification in cabinet as read
         * @param {SiteNotifyHistoryControllerMarkOfRead1VEnum} v Version
         * @param {SiteNotifyHistoryControllerMarkOfRead1LanguageEnum} language Current language
         * @param {SiteMarkReadHistoryRequest} siteMarkReadHistoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyHistoryControllerMarkOfRead1: async (v: SiteNotifyHistoryControllerMarkOfRead1VEnum, language: SiteNotifyHistoryControllerMarkOfRead1LanguageEnum, siteMarkReadHistoryRequest: SiteMarkReadHistoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteNotifyHistoryControllerMarkOfRead1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteNotifyHistoryControllerMarkOfRead1', 'language', language)
            // verify required parameter 'siteMarkReadHistoryRequest' is not null or undefined
            assertParamExists('siteNotifyHistoryControllerMarkOfRead1', 'siteMarkReadHistoryRequest', siteMarkReadHistoryRequest)
            const localVarPath = `/method/notify_history/read`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteMarkReadHistoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run action in my notify item
         * @param {SiteNotifyHistoryControllerRunAction1VEnum} v Version
         * @param {string} notifyHistoryId Id of page in mongodb
         * @param {string} actionName Action name
         * @param {string} groupId Group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyHistoryControllerRunAction1: async (v: SiteNotifyHistoryControllerRunAction1VEnum, notifyHistoryId: string, actionName: string, groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteNotifyHistoryControllerRunAction1', 'v', v)
            // verify required parameter 'notifyHistoryId' is not null or undefined
            assertParamExists('siteNotifyHistoryControllerRunAction1', 'notifyHistoryId', notifyHistoryId)
            // verify required parameter 'actionName' is not null or undefined
            assertParamExists('siteNotifyHistoryControllerRunAction1', 'actionName', actionName)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('siteNotifyHistoryControllerRunAction1', 'groupId', groupId)
            const localVarPath = `/method/notify_history/run_action`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (notifyHistoryId !== undefined) {
                localVarQueryParameter['notify_history_id'] = notifyHistoryId;
            }

            if (actionName !== undefined) {
                localVarQueryParameter['action_name'] = actionName;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set all notification in cabinet as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyHistoryControllerSetAllCabinetRead1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/method/notify_history/set_all_cabinet_read`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotifyHistoryApi - functional programming interface
 * @export
 */
export const NotifyHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotifyHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get my NotifyHistory item by id
         * @param {SiteNotifyHistoryControllerGet1VEnum} v Version
         * @param {string} id Id of page in mongodb
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteNotifyHistoryControllerGet1(v: SiteNotifyHistoryControllerGet1VEnum, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotifyHistorySiteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteNotifyHistoryControllerGet1(v, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotifyHistoryApi.siteNotifyHistoryControllerGet1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get list of my notifications
         * @param {SiteNotifyHistoryControllerGetListMy1VEnum} v Version
         * @param {SiteNotifyHistoryControllerGetListMy1LanguageEnum} language Current language
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {number} [projectId] Project id
         * @param {SiteNotifyHistoryControllerGetListMy1NameEnum} [name] Name
         * @param {SiteNotifyHistoryControllerGetListMy1ChannelEnum} [channel] Channel
         * @param {string} [dateFrom] Date from
         * @param {string} [dateTo] Date to
         * @param {SiteNotifyHistoryControllerGetListMy1StatusReadEnum} [statusRead] Status read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteNotifyHistoryControllerGetListMy1(v: SiteNotifyHistoryControllerGetListMy1VEnum, language: SiteNotifyHistoryControllerGetListMy1LanguageEnum, limit?: number, offset?: number, projectId?: number, name?: SiteNotifyHistoryControllerGetListMy1NameEnum, channel?: SiteNotifyHistoryControllerGetListMy1ChannelEnum, dateFrom?: string, dateTo?: string, statusRead?: SiteNotifyHistoryControllerGetListMy1StatusReadEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseOfNotifyHistorySiteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteNotifyHistoryControllerGetListMy1(v, language, limit, offset, projectId, name, channel, dateFrom, dateTo, statusRead, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotifyHistoryApi.siteNotifyHistoryControllerGetListMy1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get my status unread message for user
         * @param {SiteNotifyHistoryControllerGetStatusMy1VEnum} v Version
         * @param {SiteNotifyHistoryControllerGetStatusMy1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteNotifyHistoryControllerGetStatusMy1(v: SiteNotifyHistoryControllerGetStatusMy1VEnum, language: SiteNotifyHistoryControllerGetStatusMy1LanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotifyHistoryStatusUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteNotifyHistoryControllerGetStatusMy1(v, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotifyHistoryApi.siteNotifyHistoryControllerGetStatusMy1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set notification in cabinet as read
         * @param {SiteNotifyHistoryControllerMarkOfRead1VEnum} v Version
         * @param {SiteNotifyHistoryControllerMarkOfRead1LanguageEnum} language Current language
         * @param {SiteMarkReadHistoryRequest} siteMarkReadHistoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteNotifyHistoryControllerMarkOfRead1(v: SiteNotifyHistoryControllerMarkOfRead1VEnum, language: SiteNotifyHistoryControllerMarkOfRead1LanguageEnum, siteMarkReadHistoryRequest: SiteMarkReadHistoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteMarkReadHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteNotifyHistoryControllerMarkOfRead1(v, language, siteMarkReadHistoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotifyHistoryApi.siteNotifyHistoryControllerMarkOfRead1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Run action in my notify item
         * @param {SiteNotifyHistoryControllerRunAction1VEnum} v Version
         * @param {string} notifyHistoryId Id of page in mongodb
         * @param {string} actionName Action name
         * @param {string} groupId Group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteNotifyHistoryControllerRunAction1(v: SiteNotifyHistoryControllerRunAction1VEnum, notifyHistoryId: string, actionName: string, groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotifyHistorySiteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteNotifyHistoryControllerRunAction1(v, notifyHistoryId, actionName, groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotifyHistoryApi.siteNotifyHistoryControllerRunAction1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set all notification in cabinet as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteNotifyHistoryControllerSetAllCabinetRead1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteNotifyHistoryControllerSetAllCabinetRead1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotifyHistoryApi.siteNotifyHistoryControllerSetAllCabinetRead1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotifyHistoryApi - factory interface
 * @export
 */
export const NotifyHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotifyHistoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Get my NotifyHistory item by id
         * @param {SiteNotifyHistoryControllerGet1VEnum} v Version
         * @param {string} id Id of page in mongodb
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyHistoryControllerGet1(v: SiteNotifyHistoryControllerGet1VEnum, id: string, options?: RawAxiosRequestConfig): AxiosPromise<NotifyHistorySiteResponse> {
            return localVarFp.siteNotifyHistoryControllerGet1(v, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of my notifications
         * @param {SiteNotifyHistoryControllerGetListMy1VEnum} v Version
         * @param {SiteNotifyHistoryControllerGetListMy1LanguageEnum} language Current language
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {number} [projectId] Project id
         * @param {SiteNotifyHistoryControllerGetListMy1NameEnum} [name] Name
         * @param {SiteNotifyHistoryControllerGetListMy1ChannelEnum} [channel] Channel
         * @param {string} [dateFrom] Date from
         * @param {string} [dateTo] Date to
         * @param {SiteNotifyHistoryControllerGetListMy1StatusReadEnum} [statusRead] Status read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyHistoryControllerGetListMy1(v: SiteNotifyHistoryControllerGetListMy1VEnum, language: SiteNotifyHistoryControllerGetListMy1LanguageEnum, limit?: number, offset?: number, projectId?: number, name?: SiteNotifyHistoryControllerGetListMy1NameEnum, channel?: SiteNotifyHistoryControllerGetListMy1ChannelEnum, dateFrom?: string, dateTo?: string, statusRead?: SiteNotifyHistoryControllerGetListMy1StatusReadEnum, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseOfNotifyHistorySiteResponse> {
            return localVarFp.siteNotifyHistoryControllerGetListMy1(v, language, limit, offset, projectId, name, channel, dateFrom, dateTo, statusRead, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get my status unread message for user
         * @param {SiteNotifyHistoryControllerGetStatusMy1VEnum} v Version
         * @param {SiteNotifyHistoryControllerGetStatusMy1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyHistoryControllerGetStatusMy1(v: SiteNotifyHistoryControllerGetStatusMy1VEnum, language: SiteNotifyHistoryControllerGetStatusMy1LanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<NotifyHistoryStatusUserResponse> {
            return localVarFp.siteNotifyHistoryControllerGetStatusMy1(v, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set notification in cabinet as read
         * @param {SiteNotifyHistoryControllerMarkOfRead1VEnum} v Version
         * @param {SiteNotifyHistoryControllerMarkOfRead1LanguageEnum} language Current language
         * @param {SiteMarkReadHistoryRequest} siteMarkReadHistoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyHistoryControllerMarkOfRead1(v: SiteNotifyHistoryControllerMarkOfRead1VEnum, language: SiteNotifyHistoryControllerMarkOfRead1LanguageEnum, siteMarkReadHistoryRequest: SiteMarkReadHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<SiteMarkReadHistoryResponse> {
            return localVarFp.siteNotifyHistoryControllerMarkOfRead1(v, language, siteMarkReadHistoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run action in my notify item
         * @param {SiteNotifyHistoryControllerRunAction1VEnum} v Version
         * @param {string} notifyHistoryId Id of page in mongodb
         * @param {string} actionName Action name
         * @param {string} groupId Group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyHistoryControllerRunAction1(v: SiteNotifyHistoryControllerRunAction1VEnum, notifyHistoryId: string, actionName: string, groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<NotifyHistorySiteResponse> {
            return localVarFp.siteNotifyHistoryControllerRunAction1(v, notifyHistoryId, actionName, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set all notification in cabinet as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyHistoryControllerSetAllCabinetRead1(options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteNotifyHistoryControllerSetAllCabinetRead1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotifyHistoryApi - object-oriented interface
 * @export
 * @class NotifyHistoryApi
 * @extends {BaseAPI}
 */
export class NotifyHistoryApi extends BaseAPI {
    /**
     * 
     * @summary Get my NotifyHistory item by id
     * @param {SiteNotifyHistoryControllerGet1VEnum} v Version
     * @param {string} id Id of page in mongodb
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApi
     */
    public siteNotifyHistoryControllerGet1(v: SiteNotifyHistoryControllerGet1VEnum, id: string, options?: RawAxiosRequestConfig) {
        return NotifyHistoryApiFp(this.configuration).siteNotifyHistoryControllerGet1(v, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of my notifications
     * @param {SiteNotifyHistoryControllerGetListMy1VEnum} v Version
     * @param {SiteNotifyHistoryControllerGetListMy1LanguageEnum} language Current language
     * @param {number} [limit] Number of results
     * @param {number} [offset] Page offset number
     * @param {number} [projectId] Project id
     * @param {SiteNotifyHistoryControllerGetListMy1NameEnum} [name] Name
     * @param {SiteNotifyHistoryControllerGetListMy1ChannelEnum} [channel] Channel
     * @param {string} [dateFrom] Date from
     * @param {string} [dateTo] Date to
     * @param {SiteNotifyHistoryControllerGetListMy1StatusReadEnum} [statusRead] Status read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApi
     */
    public siteNotifyHistoryControllerGetListMy1(v: SiteNotifyHistoryControllerGetListMy1VEnum, language: SiteNotifyHistoryControllerGetListMy1LanguageEnum, limit?: number, offset?: number, projectId?: number, name?: SiteNotifyHistoryControllerGetListMy1NameEnum, channel?: SiteNotifyHistoryControllerGetListMy1ChannelEnum, dateFrom?: string, dateTo?: string, statusRead?: SiteNotifyHistoryControllerGetListMy1StatusReadEnum, options?: RawAxiosRequestConfig) {
        return NotifyHistoryApiFp(this.configuration).siteNotifyHistoryControllerGetListMy1(v, language, limit, offset, projectId, name, channel, dateFrom, dateTo, statusRead, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get my status unread message for user
     * @param {SiteNotifyHistoryControllerGetStatusMy1VEnum} v Version
     * @param {SiteNotifyHistoryControllerGetStatusMy1LanguageEnum} language Current language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApi
     */
    public siteNotifyHistoryControllerGetStatusMy1(v: SiteNotifyHistoryControllerGetStatusMy1VEnum, language: SiteNotifyHistoryControllerGetStatusMy1LanguageEnum, options?: RawAxiosRequestConfig) {
        return NotifyHistoryApiFp(this.configuration).siteNotifyHistoryControllerGetStatusMy1(v, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set notification in cabinet as read
     * @param {SiteNotifyHistoryControllerMarkOfRead1VEnum} v Version
     * @param {SiteNotifyHistoryControllerMarkOfRead1LanguageEnum} language Current language
     * @param {SiteMarkReadHistoryRequest} siteMarkReadHistoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApi
     */
    public siteNotifyHistoryControllerMarkOfRead1(v: SiteNotifyHistoryControllerMarkOfRead1VEnum, language: SiteNotifyHistoryControllerMarkOfRead1LanguageEnum, siteMarkReadHistoryRequest: SiteMarkReadHistoryRequest, options?: RawAxiosRequestConfig) {
        return NotifyHistoryApiFp(this.configuration).siteNotifyHistoryControllerMarkOfRead1(v, language, siteMarkReadHistoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run action in my notify item
     * @param {SiteNotifyHistoryControllerRunAction1VEnum} v Version
     * @param {string} notifyHistoryId Id of page in mongodb
     * @param {string} actionName Action name
     * @param {string} groupId Group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApi
     */
    public siteNotifyHistoryControllerRunAction1(v: SiteNotifyHistoryControllerRunAction1VEnum, notifyHistoryId: string, actionName: string, groupId: string, options?: RawAxiosRequestConfig) {
        return NotifyHistoryApiFp(this.configuration).siteNotifyHistoryControllerRunAction1(v, notifyHistoryId, actionName, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set all notification in cabinet as read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApi
     */
    public siteNotifyHistoryControllerSetAllCabinetRead1(options?: RawAxiosRequestConfig) {
        return NotifyHistoryApiFp(this.configuration).siteNotifyHistoryControllerSetAllCabinetRead1(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SiteNotifyHistoryControllerGet1VEnum = {
    _1: '1'
} as const;
export type SiteNotifyHistoryControllerGet1VEnum = typeof SiteNotifyHistoryControllerGet1VEnum[keyof typeof SiteNotifyHistoryControllerGet1VEnum];
/**
 * @export
 */
export const SiteNotifyHistoryControllerGetListMy1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteNotifyHistoryControllerGetListMy1VEnum = typeof SiteNotifyHistoryControllerGetListMy1VEnum[keyof typeof SiteNotifyHistoryControllerGetListMy1VEnum];
/**
 * @export
 */
export const SiteNotifyHistoryControllerGetListMy1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteNotifyHistoryControllerGetListMy1LanguageEnum = typeof SiteNotifyHistoryControllerGetListMy1LanguageEnum[keyof typeof SiteNotifyHistoryControllerGetListMy1LanguageEnum];
/**
 * @export
 */
export const SiteNotifyHistoryControllerGetListMy1NameEnum = {
    HighBitrate: 'high_bitrate',
    RequestAccessChannel: 'request_access_channel',
    RequestAccessProject: 'request_access_project',
    PromocodeTest: 'promocode_test',
    StreamTest: 'stream_test',
    PlanRestreamExpires: 'plan_restream_expires',
    PlanRestreamExpired: 'plan_restream_expired',
    PlanRestreamRenewed: 'plan_restream_renewed',
    PlanTranscoderExpires: 'plan_transcoder_expires',
    PlanTranscoderExpired: 'plan_transcoder_expired',
    PlanTranscoderRenewed: 'plan_transcoder_renewed',
    PlanStorageExpires: 'plan_storage_expires',
    PlanStorageExpired: 'plan_storage_expired',
    PlanStorageRenewed: 'plan_storage_renewed',
    BroadcastUnsupportedCodec: 'broadcast_unsupported_codec',
    BroadcastUnsupportedCodecScreen: 'broadcast_unsupported_codec_screen',
    BroadcastBitrateExceededScreen: 'broadcast_bitrate_exceeded_screen',
    RtmpConnectOldServerScreen: 'rtmp_connect_old_server_screen',
    BroadcastNotAudio: 'broadcast_not_audio',
    BroadcastBitrateExceeded: 'broadcast_bitrate_exceeded',
    BroadcastStarted: 'broadcast_started',
    BroadcastStopped: 'broadcast_stopped',
    RestreamCheckTwitchBitrate1: 'restream_check_twitch_bitrate_1',
    ApiPauseStart: 'api_pause_start',
    ApiPauseEnd: 'api_pause_end',
    ApiWaitEdit: 'api_wait_edit',
    ApiRestreamStart: 'api_restream_start',
    ApiRestreamStop: 'api_restream_stop',
    ApiDropBroadcast: 'api_drop_broadcast',
    ApiDropBroadcastRemoveCompany: 'api_drop_broadcast_remove_company',
    ApiDropBroadcastUpdateKey: 'api_drop_broadcast_update_key',
    PublisherDisconnected: 'publisher_disconnected',
    PublisherConnected: 'publisher_connected',
    PublisherInitializing: 'publisher_initializing',
    PublisherClose: 'publisher_close',
    BroadcastConnectedStart: 'broadcast_connected_start',
    BroadcastConnectedEnd: 'broadcast_connected_end',
    BroadcastConnectingStream: 'broadcast_connecting_stream',
    BroadcastStartedNewStream: 'broadcast_started_new_stream',
    BroadcastConnectingLost: 'broadcast_connecting_lost',
    BroadcastVideoLostStart: 'broadcast_video_lost_start',
    BroadcastVideoLostEnd: 'broadcast_video_lost_end',
    BroadcastVideoPauseStart: 'broadcast_video_pause_start',
    BroadcastVideoPauseEnd: 'broadcast_video_pause_end',
    BroadcastInitRestream: 'broadcast_init_restream',
    StartStream: 'start_stream',
    CreateReader: 'create_reader',
    StartChannel: 'start_channel',
    StopChannel: 'stop_channel',
    StopStreamVideoTimeout: 'stop_stream_video_timeout',
    StopStreamNoStartVideo: 'stop_stream_no_start_video',
    StopStream: 'stop_stream',
    DeleteReader: 'delete_reader',
    TranscoderStart: 'transcoder_start',
    TranscoderStop: 'transcoder_stop',
    StartChannelFailed: 'start_channel_failed',
    StartChannelSuccess: 'start_channel_success',
    ApiChannelInitializingStart: 'api_channel_initializing_start',
    ApiChannelInitializingFailed: 'api_channel_initializing_failed',
    ApiChannelInitializingSuccess: 'api_channel_initializing_success',
    ChannelApiUpdateSettingsSuccess: 'channel_api_update_settings_success',
    ChannelApiUpdateSettingsError: 'channel_api_update_settings_error',
    ChannelApiUpdatePlaylistSuccess: 'channel_api_update_playlist_success',
    ChannelApiUpdatePlaylistError: 'channel_api_update_playlist_error',
    ChannelApiUpdateChatError: 'channel_api_update_chat_error',
    ChannelApiStreamKeySuccess: 'channel_api_stream_key_success',
    ChannelApiStreamKeyError: 'channel_api_stream_key_error',
    ChannelApiAutoStopDisableSuccess: 'channel_api_auto_stop_disable_success',
    ChannelApiAutoStopDisableError: 'channel_api_auto_stop_disable_error',
    ChannelApiUnbindingStreamKeyError: 'channel_api_unbinding_stream_key_error',
    ChannelApiCreateBroadcastSuccess: 'channel_api_create_broadcast_success',
    ChannelApiCreateBroadcastError: 'channel_api_create_broadcast_error',
    ChannelApiSetPlannedSuccess: 'channel_api_set_planned_success',
    ChannelApiSetPlannedError: 'channel_api_set_planned_error',
    ChannelApiSetThumbnailSuccess: 'channel_api_set_thumbnail_success',
    ChannelApiSetThumbnailError: 'channel_api_set_thumbnail_error',
    ChannelTokenError: 'channel_token_error',
    ChannelApiGroupFailed: 'channel_api_group_failed',
    NoAudioReader: 'no_audio_reader',
    RestreamCheckTwitchBitrate2: 'restream_check_twitch_bitrate_2',
    TranscoderSupportErrorScreen: 'transcoder_support_error_screen',
    TranscoderTariffEndScreen: 'transcoder_tariff_end_screen',
    TranscoderCountFlowScreen: 'transcoder_count_flow_screen',
    TranscoderResolutionScreen: 'transcoder_resolution_screen',
    StreamKeyBanned: 'stream_key_banned',
    BroadcastChangeCodec: 'broadcast_change_codec',
    BroadcastChangeRegion: 'broadcast_change_region',
    VideoUploadError: 'video_upload_error',
    StopChannelError: 'stop_channel_error',
    BroadcastUserActionStop: 'broadcast_user_action_stop'
} as const;
export type SiteNotifyHistoryControllerGetListMy1NameEnum = typeof SiteNotifyHistoryControllerGetListMy1NameEnum[keyof typeof SiteNotifyHistoryControllerGetListMy1NameEnum];
/**
 * @export
 */
export const SiteNotifyHistoryControllerGetListMy1ChannelEnum = {
    Telegram: 'telegram',
    Cabinet: 'cabinet',
    Mobile: 'mobile'
} as const;
export type SiteNotifyHistoryControllerGetListMy1ChannelEnum = typeof SiteNotifyHistoryControllerGetListMy1ChannelEnum[keyof typeof SiteNotifyHistoryControllerGetListMy1ChannelEnum];
/**
 * @export
 */
export const SiteNotifyHistoryControllerGetListMy1StatusReadEnum = {
    Unread: 'unread',
    Read: 'read'
} as const;
export type SiteNotifyHistoryControllerGetListMy1StatusReadEnum = typeof SiteNotifyHistoryControllerGetListMy1StatusReadEnum[keyof typeof SiteNotifyHistoryControllerGetListMy1StatusReadEnum];
/**
 * @export
 */
export const SiteNotifyHistoryControllerGetStatusMy1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteNotifyHistoryControllerGetStatusMy1VEnum = typeof SiteNotifyHistoryControllerGetStatusMy1VEnum[keyof typeof SiteNotifyHistoryControllerGetStatusMy1VEnum];
/**
 * @export
 */
export const SiteNotifyHistoryControllerGetStatusMy1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteNotifyHistoryControllerGetStatusMy1LanguageEnum = typeof SiteNotifyHistoryControllerGetStatusMy1LanguageEnum[keyof typeof SiteNotifyHistoryControllerGetStatusMy1LanguageEnum];
/**
 * @export
 */
export const SiteNotifyHistoryControllerMarkOfRead1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteNotifyHistoryControllerMarkOfRead1VEnum = typeof SiteNotifyHistoryControllerMarkOfRead1VEnum[keyof typeof SiteNotifyHistoryControllerMarkOfRead1VEnum];
/**
 * @export
 */
export const SiteNotifyHistoryControllerMarkOfRead1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteNotifyHistoryControllerMarkOfRead1LanguageEnum = typeof SiteNotifyHistoryControllerMarkOfRead1LanguageEnum[keyof typeof SiteNotifyHistoryControllerMarkOfRead1LanguageEnum];
/**
 * @export
 */
export const SiteNotifyHistoryControllerRunAction1VEnum = {
    _1: '1'
} as const;
export type SiteNotifyHistoryControllerRunAction1VEnum = typeof SiteNotifyHistoryControllerRunAction1VEnum[keyof typeof SiteNotifyHistoryControllerRunAction1VEnum];


/**
 * NotifyUserApi - axios parameter creator
 * @export
 */
export const NotifyUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete mobile token from user
         * @param {SiteNotifyUserControllerDelMobileToken1VEnum} v Version
         * @param {SiteNotifyUserControllerDelMobileToken1LanguageEnum} language Current language
         * @param {string} token Token in mobile app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyUserControllerDelMobileToken1: async (v: SiteNotifyUserControllerDelMobileToken1VEnum, language: SiteNotifyUserControllerDelMobileToken1LanguageEnum, token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteNotifyUserControllerDelMobileToken1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteNotifyUserControllerDelMobileToken1', 'language', language)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('siteNotifyUserControllerDelMobileToken1', 'token', token)
            const localVarPath = `/method/notify_user/del_mobile_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user notify settings
         * @param {SiteNotifyUserControllerGet1VEnum} v Version
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyUserControllerGet1: async (v: SiteNotifyUserControllerGet1VEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteNotifyUserControllerGet1', 'v', v)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteNotifyUserControllerGet1', 'projectId', projectId)
            const localVarPath = `/method/notify_user/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user screen notify
         * @param {SiteNotifyUserControllerGetScreen1VEnum} v Version
         * @param {SiteNotifyUserControllerGetScreen1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyUserControllerGetScreen1: async (v: SiteNotifyUserControllerGetScreen1VEnum, language: SiteNotifyUserControllerGetScreen1LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteNotifyUserControllerGetScreen1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteNotifyUserControllerGetScreen1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteNotifyUserControllerGetScreen1', 'projectId', projectId)
            const localVarPath = `/method/notify_user/screen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove user screen notify
         * @param {SiteNotifyUserControllerRemoveScreen1VEnum} v Version
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyUserControllerRemoveScreen1: async (v: SiteNotifyUserControllerRemoveScreen1VEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteNotifyUserControllerRemoveScreen1', 'v', v)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteNotifyUserControllerRemoveScreen1', 'projectId', projectId)
            const localVarPath = `/method/notify_user/screen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set user notify settings
         * @param {SiteNotifyUserControllerSet1VEnum} v Version
         * @param {SiteSetNotifyUserRequest} siteSetNotifyUserRequest Set user notify settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyUserControllerSet1: async (v: SiteNotifyUserControllerSet1VEnum, siteSetNotifyUserRequest: SiteSetNotifyUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteNotifyUserControllerSet1', 'v', v)
            // verify required parameter 'siteSetNotifyUserRequest' is not null or undefined
            assertParamExists('siteNotifyUserControllerSet1', 'siteSetNotifyUserRequest', siteSetNotifyUserRequest)
            const localVarPath = `/method/notify_user/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteSetNotifyUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotifyUserApi - functional programming interface
 * @export
 */
export const NotifyUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotifyUserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete mobile token from user
         * @param {SiteNotifyUserControllerDelMobileToken1VEnum} v Version
         * @param {SiteNotifyUserControllerDelMobileToken1LanguageEnum} language Current language
         * @param {string} token Token in mobile app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteNotifyUserControllerDelMobileToken1(v: SiteNotifyUserControllerDelMobileToken1VEnum, language: SiteNotifyUserControllerDelMobileToken1LanguageEnum, token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteNotifyUserControllerDelMobileToken1(v, language, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotifyUserApi.siteNotifyUserControllerDelMobileToken1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user notify settings
         * @param {SiteNotifyUserControllerGet1VEnum} v Version
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteNotifyUserControllerGet1(v: SiteNotifyUserControllerGet1VEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteNotifyUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteNotifyUserControllerGet1(v, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotifyUserApi.siteNotifyUserControllerGet1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user screen notify
         * @param {SiteNotifyUserControllerGetScreen1VEnum} v Version
         * @param {SiteNotifyUserControllerGetScreen1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteNotifyUserControllerGetScreen1(v: SiteNotifyUserControllerGetScreen1VEnum, language: SiteNotifyUserControllerGetScreen1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteScreenNotifyUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteNotifyUserControllerGetScreen1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotifyUserApi.siteNotifyUserControllerGetScreen1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove user screen notify
         * @param {SiteNotifyUserControllerRemoveScreen1VEnum} v Version
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteNotifyUserControllerRemoveScreen1(v: SiteNotifyUserControllerRemoveScreen1VEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteNotifyUserControllerRemoveScreen1(v, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotifyUserApi.siteNotifyUserControllerRemoveScreen1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set user notify settings
         * @param {SiteNotifyUserControllerSet1VEnum} v Version
         * @param {SiteSetNotifyUserRequest} siteSetNotifyUserRequest Set user notify settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteNotifyUserControllerSet1(v: SiteNotifyUserControllerSet1VEnum, siteSetNotifyUserRequest: SiteSetNotifyUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteNotifyUserControllerSet1(v, siteSetNotifyUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotifyUserApi.siteNotifyUserControllerSet1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotifyUserApi - factory interface
 * @export
 */
export const NotifyUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotifyUserApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete mobile token from user
         * @param {SiteNotifyUserControllerDelMobileToken1VEnum} v Version
         * @param {SiteNotifyUserControllerDelMobileToken1LanguageEnum} language Current language
         * @param {string} token Token in mobile app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyUserControllerDelMobileToken1(v: SiteNotifyUserControllerDelMobileToken1VEnum, language: SiteNotifyUserControllerDelMobileToken1LanguageEnum, token: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteNotifyUserControllerDelMobileToken1(v, language, token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user notify settings
         * @param {SiteNotifyUserControllerGet1VEnum} v Version
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyUserControllerGet1(v: SiteNotifyUserControllerGet1VEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<SiteNotifyUserResponse> {
            return localVarFp.siteNotifyUserControllerGet1(v, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user screen notify
         * @param {SiteNotifyUserControllerGetScreen1VEnum} v Version
         * @param {SiteNotifyUserControllerGetScreen1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyUserControllerGetScreen1(v: SiteNotifyUserControllerGetScreen1VEnum, language: SiteNotifyUserControllerGetScreen1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<SiteScreenNotifyUserResponse> {
            return localVarFp.siteNotifyUserControllerGetScreen1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove user screen notify
         * @param {SiteNotifyUserControllerRemoveScreen1VEnum} v Version
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyUserControllerRemoveScreen1(v: SiteNotifyUserControllerRemoveScreen1VEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteNotifyUserControllerRemoveScreen1(v, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set user notify settings
         * @param {SiteNotifyUserControllerSet1VEnum} v Version
         * @param {SiteSetNotifyUserRequest} siteSetNotifyUserRequest Set user notify settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteNotifyUserControllerSet1(v: SiteNotifyUserControllerSet1VEnum, siteSetNotifyUserRequest: SiteSetNotifyUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteNotifyUserControllerSet1(v, siteSetNotifyUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotifyUserApi - object-oriented interface
 * @export
 * @class NotifyUserApi
 * @extends {BaseAPI}
 */
export class NotifyUserApi extends BaseAPI {
    /**
     * 
     * @summary Delete mobile token from user
     * @param {SiteNotifyUserControllerDelMobileToken1VEnum} v Version
     * @param {SiteNotifyUserControllerDelMobileToken1LanguageEnum} language Current language
     * @param {string} token Token in mobile app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyUserApi
     */
    public siteNotifyUserControllerDelMobileToken1(v: SiteNotifyUserControllerDelMobileToken1VEnum, language: SiteNotifyUserControllerDelMobileToken1LanguageEnum, token: string, options?: RawAxiosRequestConfig) {
        return NotifyUserApiFp(this.configuration).siteNotifyUserControllerDelMobileToken1(v, language, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user notify settings
     * @param {SiteNotifyUserControllerGet1VEnum} v Version
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyUserApi
     */
    public siteNotifyUserControllerGet1(v: SiteNotifyUserControllerGet1VEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return NotifyUserApiFp(this.configuration).siteNotifyUserControllerGet1(v, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user screen notify
     * @param {SiteNotifyUserControllerGetScreen1VEnum} v Version
     * @param {SiteNotifyUserControllerGetScreen1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyUserApi
     */
    public siteNotifyUserControllerGetScreen1(v: SiteNotifyUserControllerGetScreen1VEnum, language: SiteNotifyUserControllerGetScreen1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return NotifyUserApiFp(this.configuration).siteNotifyUserControllerGetScreen1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove user screen notify
     * @param {SiteNotifyUserControllerRemoveScreen1VEnum} v Version
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyUserApi
     */
    public siteNotifyUserControllerRemoveScreen1(v: SiteNotifyUserControllerRemoveScreen1VEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return NotifyUserApiFp(this.configuration).siteNotifyUserControllerRemoveScreen1(v, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set user notify settings
     * @param {SiteNotifyUserControllerSet1VEnum} v Version
     * @param {SiteSetNotifyUserRequest} siteSetNotifyUserRequest Set user notify settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyUserApi
     */
    public siteNotifyUserControllerSet1(v: SiteNotifyUserControllerSet1VEnum, siteSetNotifyUserRequest: SiteSetNotifyUserRequest, options?: RawAxiosRequestConfig) {
        return NotifyUserApiFp(this.configuration).siteNotifyUserControllerSet1(v, siteSetNotifyUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SiteNotifyUserControllerDelMobileToken1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteNotifyUserControllerDelMobileToken1VEnum = typeof SiteNotifyUserControllerDelMobileToken1VEnum[keyof typeof SiteNotifyUserControllerDelMobileToken1VEnum];
/**
 * @export
 */
export const SiteNotifyUserControllerDelMobileToken1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteNotifyUserControllerDelMobileToken1LanguageEnum = typeof SiteNotifyUserControllerDelMobileToken1LanguageEnum[keyof typeof SiteNotifyUserControllerDelMobileToken1LanguageEnum];
/**
 * @export
 */
export const SiteNotifyUserControllerGet1VEnum = {
    _1: '1'
} as const;
export type SiteNotifyUserControllerGet1VEnum = typeof SiteNotifyUserControllerGet1VEnum[keyof typeof SiteNotifyUserControllerGet1VEnum];
/**
 * @export
 */
export const SiteNotifyUserControllerGetScreen1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteNotifyUserControllerGetScreen1VEnum = typeof SiteNotifyUserControllerGetScreen1VEnum[keyof typeof SiteNotifyUserControllerGetScreen1VEnum];
/**
 * @export
 */
export const SiteNotifyUserControllerGetScreen1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteNotifyUserControllerGetScreen1LanguageEnum = typeof SiteNotifyUserControllerGetScreen1LanguageEnum[keyof typeof SiteNotifyUserControllerGetScreen1LanguageEnum];
/**
 * @export
 */
export const SiteNotifyUserControllerRemoveScreen1VEnum = {
    _1: '1'
} as const;
export type SiteNotifyUserControllerRemoveScreen1VEnum = typeof SiteNotifyUserControllerRemoveScreen1VEnum[keyof typeof SiteNotifyUserControllerRemoveScreen1VEnum];
/**
 * @export
 */
export const SiteNotifyUserControllerSet1VEnum = {
    _1: '1'
} as const;
export type SiteNotifyUserControllerSet1VEnum = typeof SiteNotifyUserControllerSet1VEnum[keyof typeof SiteNotifyUserControllerSet1VEnum];


/**
 * PaySettingApi - axios parameter creator
 * @export
 */
export const PaySettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check country after update user
         * @param {PaySettingControllerCheckCountry1VEnum} v Version
         * @param {PaySettingControllerCheckCountry1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} countryId country id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paySettingControllerCheckCountry1: async (v: PaySettingControllerCheckCountry1VEnum, language: PaySettingControllerCheckCountry1LanguageEnum, projectId: number, countryId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('paySettingControllerCheckCountry1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('paySettingControllerCheckCountry1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('paySettingControllerCheckCountry1', 'projectId', projectId)
            // verify required parameter 'countryId' is not null or undefined
            assertParamExists('paySettingControllerCheckCountry1', 'countryId', countryId)
            const localVarPath = `/method/pay-setting/check-country`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['country_id'] = countryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get pay settings for profile v3
         * @param {PaySettingControllerGetSettingV31VEnum} v Version
         * @param {PaySettingControllerGetSettingV31LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paySettingControllerGetSettingV31: async (v: PaySettingControllerGetSettingV31VEnum, language: PaySettingControllerGetSettingV31LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('paySettingControllerGetSettingV31', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('paySettingControllerGetSettingV31', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('paySettingControllerGetSettingV31', 'projectId', projectId)
            const localVarPath = `/method/pay-setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set pay settings for profile
         * @param {PaySettingBodyDto} paySettingBodyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paySettingControllerSetSetting1: async (paySettingBodyDto: PaySettingBodyDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paySettingBodyDto' is not null or undefined
            assertParamExists('paySettingControllerSetSetting1', 'paySettingBodyDto', paySettingBodyDto)
            const localVarPath = `/method/pay-setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paySettingBodyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaySettingApi - functional programming interface
 * @export
 */
export const PaySettingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaySettingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check country after update user
         * @param {PaySettingControllerCheckCountry1VEnum} v Version
         * @param {PaySettingControllerCheckCountry1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} countryId country id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paySettingControllerCheckCountry1(v: PaySettingControllerCheckCountry1VEnum, language: PaySettingControllerCheckCountry1LanguageEnum, projectId: number, countryId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayCheckCountryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paySettingControllerCheckCountry1(v, language, projectId, countryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaySettingApi.paySettingControllerCheckCountry1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get pay settings for profile v3
         * @param {PaySettingControllerGetSettingV31VEnum} v Version
         * @param {PaySettingControllerGetSettingV31LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paySettingControllerGetSettingV31(v: PaySettingControllerGetSettingV31VEnum, language: PaySettingControllerGetSettingV31LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaySettingResponseV3>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paySettingControllerGetSettingV31(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaySettingApi.paySettingControllerGetSettingV31']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set pay settings for profile
         * @param {PaySettingBodyDto} paySettingBodyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paySettingControllerSetSetting1(paySettingBodyDto: PaySettingBodyDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paySettingControllerSetSetting1(paySettingBodyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaySettingApi.paySettingControllerSetSetting1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaySettingApi - factory interface
 * @export
 */
export const PaySettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaySettingApiFp(configuration)
    return {
        /**
         * 
         * @summary Check country after update user
         * @param {PaySettingControllerCheckCountry1VEnum} v Version
         * @param {PaySettingControllerCheckCountry1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} countryId country id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paySettingControllerCheckCountry1(v: PaySettingControllerCheckCountry1VEnum, language: PaySettingControllerCheckCountry1LanguageEnum, projectId: number, countryId: number, options?: RawAxiosRequestConfig): AxiosPromise<PayCheckCountryResponse> {
            return localVarFp.paySettingControllerCheckCountry1(v, language, projectId, countryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get pay settings for profile v3
         * @param {PaySettingControllerGetSettingV31VEnum} v Version
         * @param {PaySettingControllerGetSettingV31LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paySettingControllerGetSettingV31(v: PaySettingControllerGetSettingV31VEnum, language: PaySettingControllerGetSettingV31LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<GetPaySettingResponseV3> {
            return localVarFp.paySettingControllerGetSettingV31(v, language, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set pay settings for profile
         * @param {PaySettingBodyDto} paySettingBodyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paySettingControllerSetSetting1(paySettingBodyDto: PaySettingBodyDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.paySettingControllerSetSetting1(paySettingBodyDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaySettingApi - object-oriented interface
 * @export
 * @class PaySettingApi
 * @extends {BaseAPI}
 */
export class PaySettingApi extends BaseAPI {
    /**
     * 
     * @summary Check country after update user
     * @param {PaySettingControllerCheckCountry1VEnum} v Version
     * @param {PaySettingControllerCheckCountry1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} countryId country id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaySettingApi
     */
    public paySettingControllerCheckCountry1(v: PaySettingControllerCheckCountry1VEnum, language: PaySettingControllerCheckCountry1LanguageEnum, projectId: number, countryId: number, options?: RawAxiosRequestConfig) {
        return PaySettingApiFp(this.configuration).paySettingControllerCheckCountry1(v, language, projectId, countryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get pay settings for profile v3
     * @param {PaySettingControllerGetSettingV31VEnum} v Version
     * @param {PaySettingControllerGetSettingV31LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaySettingApi
     */
    public paySettingControllerGetSettingV31(v: PaySettingControllerGetSettingV31VEnum, language: PaySettingControllerGetSettingV31LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return PaySettingApiFp(this.configuration).paySettingControllerGetSettingV31(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set pay settings for profile
     * @param {PaySettingBodyDto} paySettingBodyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaySettingApi
     */
    public paySettingControllerSetSetting1(paySettingBodyDto: PaySettingBodyDto, options?: RawAxiosRequestConfig) {
        return PaySettingApiFp(this.configuration).paySettingControllerSetSetting1(paySettingBodyDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PaySettingControllerCheckCountry1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type PaySettingControllerCheckCountry1VEnum = typeof PaySettingControllerCheckCountry1VEnum[keyof typeof PaySettingControllerCheckCountry1VEnum];
/**
 * @export
 */
export const PaySettingControllerCheckCountry1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type PaySettingControllerCheckCountry1LanguageEnum = typeof PaySettingControllerCheckCountry1LanguageEnum[keyof typeof PaySettingControllerCheckCountry1LanguageEnum];
/**
 * @export
 */
export const PaySettingControllerGetSettingV31VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type PaySettingControllerGetSettingV31VEnum = typeof PaySettingControllerGetSettingV31VEnum[keyof typeof PaySettingControllerGetSettingV31VEnum];
/**
 * @export
 */
export const PaySettingControllerGetSettingV31LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type PaySettingControllerGetSettingV31LanguageEnum = typeof PaySettingControllerGetSettingV31LanguageEnum[keyof typeof PaySettingControllerGetSettingV31LanguageEnum];


/**
 * PaySystemApi - axios parameter creator
 * @export
 */
export const PaySystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PaySystemControllerCreateChallenge1VEnum} v Version
         * @param {PaySystemControllerCreateChallenge1LanguageEnum} language Current language
         * @param {number} paymentId Payment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paySystemControllerCreateChallenge1: async (v: PaySystemControllerCreateChallenge1VEnum, language: PaySystemControllerCreateChallenge1LanguageEnum, paymentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('paySystemControllerCreateChallenge1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('paySystemControllerCreateChallenge1', 'language', language)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('paySystemControllerCreateChallenge1', 'paymentId', paymentId)
            const localVarPath = `/method/pay-system/payoneer/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (paymentId !== undefined) {
                localVarQueryParameter['payment_id'] = paymentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PaySystemControllerCreateUnitpay1VEnum} v Version
         * @param {PaySystemControllerCreateUnitpay1LanguageEnum} language Current language
         * @param {number} paymentId Payment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paySystemControllerCreateUnitpay1: async (v: PaySystemControllerCreateUnitpay1VEnum, language: PaySystemControllerCreateUnitpay1LanguageEnum, paymentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('paySystemControllerCreateUnitpay1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('paySystemControllerCreateUnitpay1', 'language', language)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('paySystemControllerCreateUnitpay1', 'paymentId', paymentId)
            const localVarPath = `/method/pay-system/unitpay/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (paymentId !== undefined) {
                localVarQueryParameter['payment_id'] = paymentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Load available pay systems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paySystemControllerList1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/method/pay-system/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaySystemApi - functional programming interface
 * @export
 */
export const PaySystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaySystemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PaySystemControllerCreateChallenge1VEnum} v Version
         * @param {PaySystemControllerCreateChallenge1LanguageEnum} language Current language
         * @param {number} paymentId Payment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paySystemControllerCreateChallenge1(v: PaySystemControllerCreateChallenge1VEnum, language: PaySystemControllerCreateChallenge1LanguageEnum, paymentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paySystemControllerCreateChallenge1(v, language, paymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaySystemApi.paySystemControllerCreateChallenge1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PaySystemControllerCreateUnitpay1VEnum} v Version
         * @param {PaySystemControllerCreateUnitpay1LanguageEnum} language Current language
         * @param {number} paymentId Payment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paySystemControllerCreateUnitpay1(v: PaySystemControllerCreateUnitpay1VEnum, language: PaySystemControllerCreateUnitpay1LanguageEnum, paymentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paySystemControllerCreateUnitpay1(v, language, paymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaySystemApi.paySystemControllerCreateUnitpay1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Load available pay systems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paySystemControllerList1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOfPaySystemListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paySystemControllerList1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaySystemApi.paySystemControllerList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaySystemApi - factory interface
 * @export
 */
export const PaySystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaySystemApiFp(configuration)
    return {
        /**
         * 
         * @param {PaySystemControllerCreateChallenge1VEnum} v Version
         * @param {PaySystemControllerCreateChallenge1LanguageEnum} language Current language
         * @param {number} paymentId Payment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paySystemControllerCreateChallenge1(v: PaySystemControllerCreateChallenge1VEnum, language: PaySystemControllerCreateChallenge1LanguageEnum, paymentId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.paySystemControllerCreateChallenge1(v, language, paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PaySystemControllerCreateUnitpay1VEnum} v Version
         * @param {PaySystemControllerCreateUnitpay1LanguageEnum} language Current language
         * @param {number} paymentId Payment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paySystemControllerCreateUnitpay1(v: PaySystemControllerCreateUnitpay1VEnum, language: PaySystemControllerCreateUnitpay1LanguageEnum, paymentId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.paySystemControllerCreateUnitpay1(v, language, paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Load available pay systems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paySystemControllerList1(options?: RawAxiosRequestConfig): AxiosPromise<ListOfPaySystemListResponse> {
            return localVarFp.paySystemControllerList1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaySystemApi - object-oriented interface
 * @export
 * @class PaySystemApi
 * @extends {BaseAPI}
 */
export class PaySystemApi extends BaseAPI {
    /**
     * 
     * @param {PaySystemControllerCreateChallenge1VEnum} v Version
     * @param {PaySystemControllerCreateChallenge1LanguageEnum} language Current language
     * @param {number} paymentId Payment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaySystemApi
     */
    public paySystemControllerCreateChallenge1(v: PaySystemControllerCreateChallenge1VEnum, language: PaySystemControllerCreateChallenge1LanguageEnum, paymentId: number, options?: RawAxiosRequestConfig) {
        return PaySystemApiFp(this.configuration).paySystemControllerCreateChallenge1(v, language, paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PaySystemControllerCreateUnitpay1VEnum} v Version
     * @param {PaySystemControllerCreateUnitpay1LanguageEnum} language Current language
     * @param {number} paymentId Payment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaySystemApi
     */
    public paySystemControllerCreateUnitpay1(v: PaySystemControllerCreateUnitpay1VEnum, language: PaySystemControllerCreateUnitpay1LanguageEnum, paymentId: number, options?: RawAxiosRequestConfig) {
        return PaySystemApiFp(this.configuration).paySystemControllerCreateUnitpay1(v, language, paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Load available pay systems
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaySystemApi
     */
    public paySystemControllerList1(options?: RawAxiosRequestConfig) {
        return PaySystemApiFp(this.configuration).paySystemControllerList1(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PaySystemControllerCreateChallenge1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type PaySystemControllerCreateChallenge1VEnum = typeof PaySystemControllerCreateChallenge1VEnum[keyof typeof PaySystemControllerCreateChallenge1VEnum];
/**
 * @export
 */
export const PaySystemControllerCreateChallenge1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type PaySystemControllerCreateChallenge1LanguageEnum = typeof PaySystemControllerCreateChallenge1LanguageEnum[keyof typeof PaySystemControllerCreateChallenge1LanguageEnum];
/**
 * @export
 */
export const PaySystemControllerCreateUnitpay1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type PaySystemControllerCreateUnitpay1VEnum = typeof PaySystemControllerCreateUnitpay1VEnum[keyof typeof PaySystemControllerCreateUnitpay1VEnum];
/**
 * @export
 */
export const PaySystemControllerCreateUnitpay1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type PaySystemControllerCreateUnitpay1LanguageEnum = typeof PaySystemControllerCreateUnitpay1LanguageEnum[keyof typeof PaySystemControllerCreateUnitpay1LanguageEnum];


/**
 * PaymentApi - axios parameter creator
 * @export
 */
export const PaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create payment item for pay system
         * @param {PaymentControllerCreate1VEnum} v Version
         * @param {PaymentControllerCreate1LanguageEnum} language Current language
         * @param {PaymentControllerCreate1Request} paymentControllerCreate1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerCreate1: async (v: PaymentControllerCreate1VEnum, language: PaymentControllerCreate1LanguageEnum, paymentControllerCreate1Request: PaymentControllerCreate1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('paymentControllerCreate1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('paymentControllerCreate1', 'language', language)
            // verify required parameter 'paymentControllerCreate1Request' is not null or undefined
            assertParamExists('paymentControllerCreate1', 'paymentControllerCreate1Request', paymentControllerCreate1Request)
            const localVarPath = `/method/payment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentControllerCreate1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PaymentControllerGetStatus1VEnum} v Version
         * @param {PaymentControllerGetStatus1LanguageEnum} language Current language
         * @param {number} payId Pay order id
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerGetStatus1: async (v: PaymentControllerGetStatus1VEnum, language: PaymentControllerGetStatus1LanguageEnum, payId: number, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('paymentControllerGetStatus1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('paymentControllerGetStatus1', 'language', language)
            // verify required parameter 'payId' is not null or undefined
            assertParamExists('paymentControllerGetStatus1', 'payId', payId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('paymentControllerGetStatus1', 'projectId', projectId)
            const localVarPath = `/method/payment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (payId !== undefined) {
                localVarQueryParameter['payId'] = payId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PaymentControllerList1VEnum} v Version
         * @param {PaymentControllerList1LanguageEnum} language Current language
         * @param {number} [pageSize] Number of results
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerList1: async (v: PaymentControllerList1VEnum, language: PaymentControllerList1LanguageEnum, pageSize?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('paymentControllerList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('paymentControllerList1', 'language', language)
            const localVarPath = `/method/payment/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentApi - functional programming interface
 * @export
 */
export const PaymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create payment item for pay system
         * @param {PaymentControllerCreate1VEnum} v Version
         * @param {PaymentControllerCreate1LanguageEnum} language Current language
         * @param {PaymentControllerCreate1Request} paymentControllerCreate1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentControllerCreate1(v: PaymentControllerCreate1VEnum, language: PaymentControllerCreate1LanguageEnum, paymentControllerCreate1Request: PaymentControllerCreate1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerCreate1(v, language, paymentControllerCreate1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.paymentControllerCreate1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PaymentControllerGetStatus1VEnum} v Version
         * @param {PaymentControllerGetStatus1LanguageEnum} language Current language
         * @param {number} payId Pay order id
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentControllerGetStatus1(v: PaymentControllerGetStatus1VEnum, language: PaymentControllerGetStatus1LanguageEnum, payId: number, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerGetStatus1(v, language, payId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.paymentControllerGetStatus1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PaymentControllerList1VEnum} v Version
         * @param {PaymentControllerList1LanguageEnum} language Current language
         * @param {number} [pageSize] Number of results
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentControllerList1(v: PaymentControllerList1VEnum, language: PaymentControllerList1LanguageEnum, pageSize?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerList1(v, language, pageSize, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.paymentControllerList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentApi - factory interface
 * @export
 */
export const PaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentApiFp(configuration)
    return {
        /**
         * 
         * @summary Create payment item for pay system
         * @param {PaymentControllerCreate1VEnum} v Version
         * @param {PaymentControllerCreate1LanguageEnum} language Current language
         * @param {PaymentControllerCreate1Request} paymentControllerCreate1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerCreate1(v: PaymentControllerCreate1VEnum, language: PaymentControllerCreate1LanguageEnum, paymentControllerCreate1Request: PaymentControllerCreate1Request, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCreateResponse> {
            return localVarFp.paymentControllerCreate1(v, language, paymentControllerCreate1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PaymentControllerGetStatus1VEnum} v Version
         * @param {PaymentControllerGetStatus1LanguageEnum} language Current language
         * @param {number} payId Pay order id
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerGetStatus1(v: PaymentControllerGetStatus1VEnum, language: PaymentControllerGetStatus1LanguageEnum, payId: number, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<PaymentStatusResponse> {
            return localVarFp.paymentControllerGetStatus1(v, language, payId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PaymentControllerList1VEnum} v Version
         * @param {PaymentControllerList1LanguageEnum} language Current language
         * @param {number} [pageSize] Number of results
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerList1(v: PaymentControllerList1VEnum, language: PaymentControllerList1LanguageEnum, pageSize?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.paymentControllerList1(v, language, pageSize, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export class PaymentApi extends BaseAPI {
    /**
     * 
     * @summary Create payment item for pay system
     * @param {PaymentControllerCreate1VEnum} v Version
     * @param {PaymentControllerCreate1LanguageEnum} language Current language
     * @param {PaymentControllerCreate1Request} paymentControllerCreate1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentControllerCreate1(v: PaymentControllerCreate1VEnum, language: PaymentControllerCreate1LanguageEnum, paymentControllerCreate1Request: PaymentControllerCreate1Request, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).paymentControllerCreate1(v, language, paymentControllerCreate1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PaymentControllerGetStatus1VEnum} v Version
     * @param {PaymentControllerGetStatus1LanguageEnum} language Current language
     * @param {number} payId Pay order id
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentControllerGetStatus1(v: PaymentControllerGetStatus1VEnum, language: PaymentControllerGetStatus1LanguageEnum, payId: number, projectId: number, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).paymentControllerGetStatus1(v, language, payId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PaymentControllerList1VEnum} v Version
     * @param {PaymentControllerList1LanguageEnum} language Current language
     * @param {number} [pageSize] Number of results
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentControllerList1(v: PaymentControllerList1VEnum, language: PaymentControllerList1LanguageEnum, pageSize?: number, page?: number, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).paymentControllerList1(v, language, pageSize, page, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PaymentControllerCreate1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type PaymentControllerCreate1VEnum = typeof PaymentControllerCreate1VEnum[keyof typeof PaymentControllerCreate1VEnum];
/**
 * @export
 */
export const PaymentControllerCreate1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type PaymentControllerCreate1LanguageEnum = typeof PaymentControllerCreate1LanguageEnum[keyof typeof PaymentControllerCreate1LanguageEnum];
/**
 * @export
 */
export const PaymentControllerGetStatus1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type PaymentControllerGetStatus1VEnum = typeof PaymentControllerGetStatus1VEnum[keyof typeof PaymentControllerGetStatus1VEnum];
/**
 * @export
 */
export const PaymentControllerGetStatus1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type PaymentControllerGetStatus1LanguageEnum = typeof PaymentControllerGetStatus1LanguageEnum[keyof typeof PaymentControllerGetStatus1LanguageEnum];
/**
 * @export
 */
export const PaymentControllerList1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type PaymentControllerList1VEnum = typeof PaymentControllerList1VEnum[keyof typeof PaymentControllerList1VEnum];
/**
 * @export
 */
export const PaymentControllerList1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type PaymentControllerList1LanguageEnum = typeof PaymentControllerList1LanguageEnum[keyof typeof PaymentControllerList1LanguageEnum];


/**
 * PayoutApi - axios parameter creator
 * @export
 */
export const PayoutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create payout
         * @param {PayoutControllerCreate1VEnum} v Version
         * @param {PayoutControllerCreate1LanguageEnum} language Current language
         * @param {PayoutCreateRequestBodyDto} payoutCreateRequestBodyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutControllerCreate1: async (v: PayoutControllerCreate1VEnum, language: PayoutControllerCreate1LanguageEnum, payoutCreateRequestBodyDto: PayoutCreateRequestBodyDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('payoutControllerCreate1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('payoutControllerCreate1', 'language', language)
            // verify required parameter 'payoutCreateRequestBodyDto' is not null or undefined
            assertParamExists('payoutControllerCreate1', 'payoutCreateRequestBodyDto', payoutCreateRequestBodyDto)
            const localVarPath = `/method/payout/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payoutCreateRequestBodyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get payout data for create
         * @param {PayoutControllerPrepare1VEnum} v Version
         * @param {PayoutControllerPrepare1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutControllerPrepare1: async (v: PayoutControllerPrepare1VEnum, language: PayoutControllerPrepare1LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('payoutControllerPrepare1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('payoutControllerPrepare1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('payoutControllerPrepare1', 'projectId', projectId)
            const localVarPath = `/method/payout/prepare`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayoutApi - functional programming interface
 * @export
 */
export const PayoutApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PayoutApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create payout
         * @param {PayoutControllerCreate1VEnum} v Version
         * @param {PayoutControllerCreate1LanguageEnum} language Current language
         * @param {PayoutCreateRequestBodyDto} payoutCreateRequestBodyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payoutControllerCreate1(v: PayoutControllerCreate1VEnum, language: PayoutControllerCreate1LanguageEnum, payoutCreateRequestBodyDto: PayoutCreateRequestBodyDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payoutControllerCreate1(v, language, payoutCreateRequestBodyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PayoutApi.payoutControllerCreate1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get payout data for create
         * @param {PayoutControllerPrepare1VEnum} v Version
         * @param {PayoutControllerPrepare1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payoutControllerPrepare1(v: PayoutControllerPrepare1VEnum, language: PayoutControllerPrepare1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOfPayoutSystemAccountListItemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payoutControllerPrepare1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PayoutApi.payoutControllerPrepare1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PayoutApi - factory interface
 * @export
 */
export const PayoutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PayoutApiFp(configuration)
    return {
        /**
         * 
         * @summary Create payout
         * @param {PayoutControllerCreate1VEnum} v Version
         * @param {PayoutControllerCreate1LanguageEnum} language Current language
         * @param {PayoutCreateRequestBodyDto} payoutCreateRequestBodyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutControllerCreate1(v: PayoutControllerCreate1VEnum, language: PayoutControllerCreate1LanguageEnum, payoutCreateRequestBodyDto: PayoutCreateRequestBodyDto, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.payoutControllerCreate1(v, language, payoutCreateRequestBodyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get payout data for create
         * @param {PayoutControllerPrepare1VEnum} v Version
         * @param {PayoutControllerPrepare1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutControllerPrepare1(v: PayoutControllerPrepare1VEnum, language: PayoutControllerPrepare1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<ListOfPayoutSystemAccountListItemResponse> {
            return localVarFp.payoutControllerPrepare1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PayoutApi - object-oriented interface
 * @export
 * @class PayoutApi
 * @extends {BaseAPI}
 */
export class PayoutApi extends BaseAPI {
    /**
     * 
     * @summary Create payout
     * @param {PayoutControllerCreate1VEnum} v Version
     * @param {PayoutControllerCreate1LanguageEnum} language Current language
     * @param {PayoutCreateRequestBodyDto} payoutCreateRequestBodyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutApi
     */
    public payoutControllerCreate1(v: PayoutControllerCreate1VEnum, language: PayoutControllerCreate1LanguageEnum, payoutCreateRequestBodyDto: PayoutCreateRequestBodyDto, options?: RawAxiosRequestConfig) {
        return PayoutApiFp(this.configuration).payoutControllerCreate1(v, language, payoutCreateRequestBodyDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get payout data for create
     * @param {PayoutControllerPrepare1VEnum} v Version
     * @param {PayoutControllerPrepare1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutApi
     */
    public payoutControllerPrepare1(v: PayoutControllerPrepare1VEnum, language: PayoutControllerPrepare1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return PayoutApiFp(this.configuration).payoutControllerPrepare1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PayoutControllerCreate1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type PayoutControllerCreate1VEnum = typeof PayoutControllerCreate1VEnum[keyof typeof PayoutControllerCreate1VEnum];
/**
 * @export
 */
export const PayoutControllerCreate1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type PayoutControllerCreate1LanguageEnum = typeof PayoutControllerCreate1LanguageEnum[keyof typeof PayoutControllerCreate1LanguageEnum];
/**
 * @export
 */
export const PayoutControllerPrepare1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type PayoutControllerPrepare1VEnum = typeof PayoutControllerPrepare1VEnum[keyof typeof PayoutControllerPrepare1VEnum];
/**
 * @export
 */
export const PayoutControllerPrepare1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type PayoutControllerPrepare1LanguageEnum = typeof PayoutControllerPrepare1LanguageEnum[keyof typeof PayoutControllerPrepare1LanguageEnum];


/**
 * PlanRestreamApi - axios parameter creator
 * @export
 */
export const PlanRestreamApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Buy restream tariff
         * @param {SitePlanRestreamControllerBuy1VEnum} v Version
         * @param {SitePlanRestreamControllerBuy1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {SitePlanRestreamControllerBuy1PeriodEnum} period Period
         * @param {number} planRestreamId Restream plan id
         * @param {number} [countChannel] Channel count
         * @param {number} [bitrate] Bitrate, kbps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanRestreamControllerBuy1: async (v: SitePlanRestreamControllerBuy1VEnum, language: SitePlanRestreamControllerBuy1LanguageEnum, projectId: number, period: SitePlanRestreamControllerBuy1PeriodEnum, planRestreamId: number, countChannel?: number, bitrate?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanRestreamControllerBuy1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanRestreamControllerBuy1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('sitePlanRestreamControllerBuy1', 'projectId', projectId)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('sitePlanRestreamControllerBuy1', 'period', period)
            // verify required parameter 'planRestreamId' is not null or undefined
            assertParamExists('sitePlanRestreamControllerBuy1', 'planRestreamId', planRestreamId)
            const localVarPath = `/method/plan_restream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (planRestreamId !== undefined) {
                localVarQueryParameter['plan_restream_id'] = planRestreamId;
            }

            if (countChannel !== undefined) {
                localVarQueryParameter['count_channel'] = countChannel;
            }

            if (bitrate !== undefined) {
                localVarQueryParameter['bitrate'] = bitrate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Load data for show card the tariffs v2
         * @param {SitePlanRestreamControllerCheck21VEnum} v Version
         * @param {SitePlanRestreamControllerCheck21LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {SitePlanRestreamControllerCheck21PeriodEnum} period Period
         * @param {number} planRestreamId Restream plan id
         * @param {number} [useBalance] Is select balance
         * @param {number} [channels] Channels count
         * @param {number} [bitrate] Bitrate, kbps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanRestreamControllerCheck21: async (v: SitePlanRestreamControllerCheck21VEnum, language: SitePlanRestreamControllerCheck21LanguageEnum, projectId: number, period: SitePlanRestreamControllerCheck21PeriodEnum, planRestreamId: number, useBalance?: number, channels?: number, bitrate?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanRestreamControllerCheck21', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanRestreamControllerCheck21', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('sitePlanRestreamControllerCheck21', 'projectId', projectId)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('sitePlanRestreamControllerCheck21', 'period', period)
            // verify required parameter 'planRestreamId' is not null or undefined
            assertParamExists('sitePlanRestreamControllerCheck21', 'planRestreamId', planRestreamId)
            const localVarPath = `/method/plan_restream/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (planRestreamId !== undefined) {
                localVarQueryParameter['plan_restream_id'] = planRestreamId;
            }

            if (useBalance !== undefined) {
                localVarQueryParameter['use_balance'] = useBalance;
            }

            if (channels !== undefined) {
                localVarQueryParameter['channels'] = channels;
            }

            if (bitrate !== undefined) {
                localVarQueryParameter['bitrate'] = bitrate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get discount restream
         * @param {SitePlanRestreamControllerGetDiscount1VEnum} v Version
         * @param {SitePlanRestreamControllerGetDiscount1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanRestreamControllerGetDiscount1: async (v: SitePlanRestreamControllerGetDiscount1VEnum, language: SitePlanRestreamControllerGetDiscount1LanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanRestreamControllerGetDiscount1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanRestreamControllerGetDiscount1', 'language', language)
            const localVarPath = `/method/plan_restream/get_discount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of restream tariffs
         * @param {SitePlanRestreamControllerList1VEnum} v Version
         * @param {SitePlanRestreamControllerList1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanRestreamControllerList1: async (v: SitePlanRestreamControllerList1VEnum, language: SitePlanRestreamControllerList1LanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanRestreamControllerList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanRestreamControllerList1', 'language', language)
            const localVarPath = `/method/plan_restream/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of restream tariffs for project
         * @param {SitePlanRestreamControllerListProject1VEnum} v Version
         * @param {SitePlanRestreamControllerListProject1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanRestreamControllerListProject1: async (v: SitePlanRestreamControllerListProject1VEnum, language: SitePlanRestreamControllerListProject1LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanRestreamControllerListProject1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanRestreamControllerListProject1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('sitePlanRestreamControllerListProject1', 'projectId', projectId)
            const localVarPath = `/method/plan_restream/list/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove after tariff
         * @param {SitePlanRestreamControllerRemove1VEnum} v Version
         * @param {SitePlanRestreamControllerRemove1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} planRestreamId Restream plan id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanRestreamControllerRemove1: async (v: SitePlanRestreamControllerRemove1VEnum, language: SitePlanRestreamControllerRemove1LanguageEnum, projectId: number, planRestreamId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanRestreamControllerRemove1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanRestreamControllerRemove1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('sitePlanRestreamControllerRemove1', 'projectId', projectId)
            // verify required parameter 'planRestreamId' is not null or undefined
            assertParamExists('sitePlanRestreamControllerRemove1', 'planRestreamId', planRestreamId)
            const localVarPath = `/method/plan_restream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (planRestreamId !== undefined) {
                localVarQueryParameter['plan_restream_id'] = planRestreamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tariff for project
         * @param {SitePlanRestreamControllerTariff1VEnum} v Version
         * @param {SitePlanRestreamControllerTariff1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanRestreamControllerTariff1: async (v: SitePlanRestreamControllerTariff1VEnum, language: SitePlanRestreamControllerTariff1LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanRestreamControllerTariff1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanRestreamControllerTariff1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('sitePlanRestreamControllerTariff1', 'projectId', projectId)
            const localVarPath = `/method/plan_restream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlanRestreamApi - functional programming interface
 * @export
 */
export const PlanRestreamApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlanRestreamApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Buy restream tariff
         * @param {SitePlanRestreamControllerBuy1VEnum} v Version
         * @param {SitePlanRestreamControllerBuy1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {SitePlanRestreamControllerBuy1PeriodEnum} period Period
         * @param {number} planRestreamId Restream plan id
         * @param {number} [countChannel] Channel count
         * @param {number} [bitrate] Bitrate, kbps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanRestreamControllerBuy1(v: SitePlanRestreamControllerBuy1VEnum, language: SitePlanRestreamControllerBuy1LanguageEnum, projectId: number, period: SitePlanRestreamControllerBuy1PeriodEnum, planRestreamId: number, countChannel?: number, bitrate?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanRestreamControllerBuy1(v, language, projectId, period, planRestreamId, countChannel, bitrate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanRestreamApi.sitePlanRestreamControllerBuy1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Load data for show card the tariffs v2
         * @param {SitePlanRestreamControllerCheck21VEnum} v Version
         * @param {SitePlanRestreamControllerCheck21LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {SitePlanRestreamControllerCheck21PeriodEnum} period Period
         * @param {number} planRestreamId Restream plan id
         * @param {number} [useBalance] Is select balance
         * @param {number} [channels] Channels count
         * @param {number} [bitrate] Bitrate, kbps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanRestreamControllerCheck21(v: SitePlanRestreamControllerCheck21VEnum, language: SitePlanRestreamControllerCheck21LanguageEnum, projectId: number, period: SitePlanRestreamControllerCheck21PeriodEnum, planRestreamId: number, useBalance?: number, channels?: number, bitrate?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanRestreamCheckV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanRestreamControllerCheck21(v, language, projectId, period, planRestreamId, useBalance, channels, bitrate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanRestreamApi.sitePlanRestreamControllerCheck21']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get discount restream
         * @param {SitePlanRestreamControllerGetDiscount1VEnum} v Version
         * @param {SitePlanRestreamControllerGetDiscount1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanRestreamControllerGetDiscount1(v: SitePlanRestreamControllerGetDiscount1VEnum, language: SitePlanRestreamControllerGetDiscount1LanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanRestreamDiscountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanRestreamControllerGetDiscount1(v, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanRestreamApi.sitePlanRestreamControllerGetDiscount1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get list of restream tariffs
         * @param {SitePlanRestreamControllerList1VEnum} v Version
         * @param {SitePlanRestreamControllerList1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanRestreamControllerList1(v: SitePlanRestreamControllerList1VEnum, language: SitePlanRestreamControllerList1LanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanRestreamResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanRestreamControllerList1(v, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanRestreamApi.sitePlanRestreamControllerList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get list of restream tariffs for project
         * @param {SitePlanRestreamControllerListProject1VEnum} v Version
         * @param {SitePlanRestreamControllerListProject1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanRestreamControllerListProject1(v: SitePlanRestreamControllerListProject1VEnum, language: SitePlanRestreamControllerListProject1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanRestreamProjectResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanRestreamControllerListProject1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanRestreamApi.sitePlanRestreamControllerListProject1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove after tariff
         * @param {SitePlanRestreamControllerRemove1VEnum} v Version
         * @param {SitePlanRestreamControllerRemove1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} planRestreamId Restream plan id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanRestreamControllerRemove1(v: SitePlanRestreamControllerRemove1VEnum, language: SitePlanRestreamControllerRemove1LanguageEnum, projectId: number, planRestreamId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanRestreamControllerRemove1(v, language, projectId, planRestreamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanRestreamApi.sitePlanRestreamControllerRemove1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get tariff for project
         * @param {SitePlanRestreamControllerTariff1VEnum} v Version
         * @param {SitePlanRestreamControllerTariff1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanRestreamControllerTariff1(v: SitePlanRestreamControllerTariff1VEnum, language: SitePlanRestreamControllerTariff1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanRestreamForProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanRestreamControllerTariff1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanRestreamApi.sitePlanRestreamControllerTariff1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlanRestreamApi - factory interface
 * @export
 */
export const PlanRestreamApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlanRestreamApiFp(configuration)
    return {
        /**
         * 
         * @summary Buy restream tariff
         * @param {SitePlanRestreamControllerBuy1VEnum} v Version
         * @param {SitePlanRestreamControllerBuy1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {SitePlanRestreamControllerBuy1PeriodEnum} period Period
         * @param {number} planRestreamId Restream plan id
         * @param {number} [countChannel] Channel count
         * @param {number} [bitrate] Bitrate, kbps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanRestreamControllerBuy1(v: SitePlanRestreamControllerBuy1VEnum, language: SitePlanRestreamControllerBuy1LanguageEnum, projectId: number, period: SitePlanRestreamControllerBuy1PeriodEnum, planRestreamId: number, countChannel?: number, bitrate?: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.sitePlanRestreamControllerBuy1(v, language, projectId, period, planRestreamId, countChannel, bitrate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Load data for show card the tariffs v2
         * @param {SitePlanRestreamControllerCheck21VEnum} v Version
         * @param {SitePlanRestreamControllerCheck21LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {SitePlanRestreamControllerCheck21PeriodEnum} period Period
         * @param {number} planRestreamId Restream plan id
         * @param {number} [useBalance] Is select balance
         * @param {number} [channels] Channels count
         * @param {number} [bitrate] Bitrate, kbps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanRestreamControllerCheck21(v: SitePlanRestreamControllerCheck21VEnum, language: SitePlanRestreamControllerCheck21LanguageEnum, projectId: number, period: SitePlanRestreamControllerCheck21PeriodEnum, planRestreamId: number, useBalance?: number, channels?: number, bitrate?: number, options?: RawAxiosRequestConfig): AxiosPromise<PlanRestreamCheckV2Response> {
            return localVarFp.sitePlanRestreamControllerCheck21(v, language, projectId, period, planRestreamId, useBalance, channels, bitrate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get discount restream
         * @param {SitePlanRestreamControllerGetDiscount1VEnum} v Version
         * @param {SitePlanRestreamControllerGetDiscount1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanRestreamControllerGetDiscount1(v: SitePlanRestreamControllerGetDiscount1VEnum, language: SitePlanRestreamControllerGetDiscount1LanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<PlanRestreamDiscountResponse> {
            return localVarFp.sitePlanRestreamControllerGetDiscount1(v, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of restream tariffs
         * @param {SitePlanRestreamControllerList1VEnum} v Version
         * @param {SitePlanRestreamControllerList1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanRestreamControllerList1(v: SitePlanRestreamControllerList1VEnum, language: SitePlanRestreamControllerList1LanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<PlanRestreamResponseDto> {
            return localVarFp.sitePlanRestreamControllerList1(v, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of restream tariffs for project
         * @param {SitePlanRestreamControllerListProject1VEnum} v Version
         * @param {SitePlanRestreamControllerListProject1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanRestreamControllerListProject1(v: SitePlanRestreamControllerListProject1VEnum, language: SitePlanRestreamControllerListProject1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<PlanRestreamProjectResponseDto> {
            return localVarFp.sitePlanRestreamControllerListProject1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove after tariff
         * @param {SitePlanRestreamControllerRemove1VEnum} v Version
         * @param {SitePlanRestreamControllerRemove1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} planRestreamId Restream plan id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanRestreamControllerRemove1(v: SitePlanRestreamControllerRemove1VEnum, language: SitePlanRestreamControllerRemove1LanguageEnum, projectId: number, planRestreamId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.sitePlanRestreamControllerRemove1(v, language, projectId, planRestreamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tariff for project
         * @param {SitePlanRestreamControllerTariff1VEnum} v Version
         * @param {SitePlanRestreamControllerTariff1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanRestreamControllerTariff1(v: SitePlanRestreamControllerTariff1VEnum, language: SitePlanRestreamControllerTariff1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<PlanRestreamForProject> {
            return localVarFp.sitePlanRestreamControllerTariff1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlanRestreamApi - object-oriented interface
 * @export
 * @class PlanRestreamApi
 * @extends {BaseAPI}
 */
export class PlanRestreamApi extends BaseAPI {
    /**
     * 
     * @summary Buy restream tariff
     * @param {SitePlanRestreamControllerBuy1VEnum} v Version
     * @param {SitePlanRestreamControllerBuy1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {SitePlanRestreamControllerBuy1PeriodEnum} period Period
     * @param {number} planRestreamId Restream plan id
     * @param {number} [countChannel] Channel count
     * @param {number} [bitrate] Bitrate, kbps
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanRestreamApi
     */
    public sitePlanRestreamControllerBuy1(v: SitePlanRestreamControllerBuy1VEnum, language: SitePlanRestreamControllerBuy1LanguageEnum, projectId: number, period: SitePlanRestreamControllerBuy1PeriodEnum, planRestreamId: number, countChannel?: number, bitrate?: number, options?: RawAxiosRequestConfig) {
        return PlanRestreamApiFp(this.configuration).sitePlanRestreamControllerBuy1(v, language, projectId, period, planRestreamId, countChannel, bitrate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Load data for show card the tariffs v2
     * @param {SitePlanRestreamControllerCheck21VEnum} v Version
     * @param {SitePlanRestreamControllerCheck21LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {SitePlanRestreamControllerCheck21PeriodEnum} period Period
     * @param {number} planRestreamId Restream plan id
     * @param {number} [useBalance] Is select balance
     * @param {number} [channels] Channels count
     * @param {number} [bitrate] Bitrate, kbps
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanRestreamApi
     */
    public sitePlanRestreamControllerCheck21(v: SitePlanRestreamControllerCheck21VEnum, language: SitePlanRestreamControllerCheck21LanguageEnum, projectId: number, period: SitePlanRestreamControllerCheck21PeriodEnum, planRestreamId: number, useBalance?: number, channels?: number, bitrate?: number, options?: RawAxiosRequestConfig) {
        return PlanRestreamApiFp(this.configuration).sitePlanRestreamControllerCheck21(v, language, projectId, period, planRestreamId, useBalance, channels, bitrate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get discount restream
     * @param {SitePlanRestreamControllerGetDiscount1VEnum} v Version
     * @param {SitePlanRestreamControllerGetDiscount1LanguageEnum} language Current language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanRestreamApi
     */
    public sitePlanRestreamControllerGetDiscount1(v: SitePlanRestreamControllerGetDiscount1VEnum, language: SitePlanRestreamControllerGetDiscount1LanguageEnum, options?: RawAxiosRequestConfig) {
        return PlanRestreamApiFp(this.configuration).sitePlanRestreamControllerGetDiscount1(v, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of restream tariffs
     * @param {SitePlanRestreamControllerList1VEnum} v Version
     * @param {SitePlanRestreamControllerList1LanguageEnum} language Current language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanRestreamApi
     */
    public sitePlanRestreamControllerList1(v: SitePlanRestreamControllerList1VEnum, language: SitePlanRestreamControllerList1LanguageEnum, options?: RawAxiosRequestConfig) {
        return PlanRestreamApiFp(this.configuration).sitePlanRestreamControllerList1(v, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of restream tariffs for project
     * @param {SitePlanRestreamControllerListProject1VEnum} v Version
     * @param {SitePlanRestreamControllerListProject1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanRestreamApi
     */
    public sitePlanRestreamControllerListProject1(v: SitePlanRestreamControllerListProject1VEnum, language: SitePlanRestreamControllerListProject1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return PlanRestreamApiFp(this.configuration).sitePlanRestreamControllerListProject1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove after tariff
     * @param {SitePlanRestreamControllerRemove1VEnum} v Version
     * @param {SitePlanRestreamControllerRemove1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} planRestreamId Restream plan id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanRestreamApi
     */
    public sitePlanRestreamControllerRemove1(v: SitePlanRestreamControllerRemove1VEnum, language: SitePlanRestreamControllerRemove1LanguageEnum, projectId: number, planRestreamId: number, options?: RawAxiosRequestConfig) {
        return PlanRestreamApiFp(this.configuration).sitePlanRestreamControllerRemove1(v, language, projectId, planRestreamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tariff for project
     * @param {SitePlanRestreamControllerTariff1VEnum} v Version
     * @param {SitePlanRestreamControllerTariff1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanRestreamApi
     */
    public sitePlanRestreamControllerTariff1(v: SitePlanRestreamControllerTariff1VEnum, language: SitePlanRestreamControllerTariff1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return PlanRestreamApiFp(this.configuration).sitePlanRestreamControllerTariff1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SitePlanRestreamControllerBuy1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanRestreamControllerBuy1VEnum = typeof SitePlanRestreamControllerBuy1VEnum[keyof typeof SitePlanRestreamControllerBuy1VEnum];
/**
 * @export
 */
export const SitePlanRestreamControllerBuy1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanRestreamControllerBuy1LanguageEnum = typeof SitePlanRestreamControllerBuy1LanguageEnum[keyof typeof SitePlanRestreamControllerBuy1LanguageEnum];
/**
 * @export
 */
export const SitePlanRestreamControllerBuy1PeriodEnum = {
    Month: 'month',
    Year: 'year'
} as const;
export type SitePlanRestreamControllerBuy1PeriodEnum = typeof SitePlanRestreamControllerBuy1PeriodEnum[keyof typeof SitePlanRestreamControllerBuy1PeriodEnum];
/**
 * @export
 */
export const SitePlanRestreamControllerCheck21VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanRestreamControllerCheck21VEnum = typeof SitePlanRestreamControllerCheck21VEnum[keyof typeof SitePlanRestreamControllerCheck21VEnum];
/**
 * @export
 */
export const SitePlanRestreamControllerCheck21LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanRestreamControllerCheck21LanguageEnum = typeof SitePlanRestreamControllerCheck21LanguageEnum[keyof typeof SitePlanRestreamControllerCheck21LanguageEnum];
/**
 * @export
 */
export const SitePlanRestreamControllerCheck21PeriodEnum = {
    Month: 'month',
    Year: 'year'
} as const;
export type SitePlanRestreamControllerCheck21PeriodEnum = typeof SitePlanRestreamControllerCheck21PeriodEnum[keyof typeof SitePlanRestreamControllerCheck21PeriodEnum];
/**
 * @export
 */
export const SitePlanRestreamControllerGetDiscount1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanRestreamControllerGetDiscount1VEnum = typeof SitePlanRestreamControllerGetDiscount1VEnum[keyof typeof SitePlanRestreamControllerGetDiscount1VEnum];
/**
 * @export
 */
export const SitePlanRestreamControllerGetDiscount1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanRestreamControllerGetDiscount1LanguageEnum = typeof SitePlanRestreamControllerGetDiscount1LanguageEnum[keyof typeof SitePlanRestreamControllerGetDiscount1LanguageEnum];
/**
 * @export
 */
export const SitePlanRestreamControllerList1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanRestreamControllerList1VEnum = typeof SitePlanRestreamControllerList1VEnum[keyof typeof SitePlanRestreamControllerList1VEnum];
/**
 * @export
 */
export const SitePlanRestreamControllerList1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanRestreamControllerList1LanguageEnum = typeof SitePlanRestreamControllerList1LanguageEnum[keyof typeof SitePlanRestreamControllerList1LanguageEnum];
/**
 * @export
 */
export const SitePlanRestreamControllerListProject1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanRestreamControllerListProject1VEnum = typeof SitePlanRestreamControllerListProject1VEnum[keyof typeof SitePlanRestreamControllerListProject1VEnum];
/**
 * @export
 */
export const SitePlanRestreamControllerListProject1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanRestreamControllerListProject1LanguageEnum = typeof SitePlanRestreamControllerListProject1LanguageEnum[keyof typeof SitePlanRestreamControllerListProject1LanguageEnum];
/**
 * @export
 */
export const SitePlanRestreamControllerRemove1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanRestreamControllerRemove1VEnum = typeof SitePlanRestreamControllerRemove1VEnum[keyof typeof SitePlanRestreamControllerRemove1VEnum];
/**
 * @export
 */
export const SitePlanRestreamControllerRemove1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanRestreamControllerRemove1LanguageEnum = typeof SitePlanRestreamControllerRemove1LanguageEnum[keyof typeof SitePlanRestreamControllerRemove1LanguageEnum];
/**
 * @export
 */
export const SitePlanRestreamControllerTariff1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanRestreamControllerTariff1VEnum = typeof SitePlanRestreamControllerTariff1VEnum[keyof typeof SitePlanRestreamControllerTariff1VEnum];
/**
 * @export
 */
export const SitePlanRestreamControllerTariff1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanRestreamControllerTariff1LanguageEnum = typeof SitePlanRestreamControllerTariff1LanguageEnum[keyof typeof SitePlanRestreamControllerTariff1LanguageEnum];


/**
 * PlanStorageApi - axios parameter creator
 * @export
 */
export const PlanStorageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Buy storage tariff
         * @param {SitePlanStorageControllerBuy1VEnum} v Version
         * @param {SitePlanStorageControllerBuy1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {SitePlanStorageControllerBuy1PeriodEnum} period Period
         * @param {number} planStorageId Storage plan id
         * @param {number} [size] Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanStorageControllerBuy1: async (v: SitePlanStorageControllerBuy1VEnum, language: SitePlanStorageControllerBuy1LanguageEnum, projectId: number, period: SitePlanStorageControllerBuy1PeriodEnum, planStorageId: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanStorageControllerBuy1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanStorageControllerBuy1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('sitePlanStorageControllerBuy1', 'projectId', projectId)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('sitePlanStorageControllerBuy1', 'period', period)
            // verify required parameter 'planStorageId' is not null or undefined
            assertParamExists('sitePlanStorageControllerBuy1', 'planStorageId', planStorageId)
            const localVarPath = `/method/plan_storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (planStorageId !== undefined) {
                localVarQueryParameter['plan_storage_id'] = planStorageId;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove next tariff
         * @param {SitePlanStorageControllerCancel1VEnum} v Version
         * @param {SitePlanStorageControllerCancel1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanStorageControllerCancel1: async (v: SitePlanStorageControllerCancel1VEnum, language: SitePlanStorageControllerCancel1LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanStorageControllerCancel1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanStorageControllerCancel1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('sitePlanStorageControllerCancel1', 'projectId', projectId)
            const localVarPath = `/method/plan_storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check storage tariff before buy
         * @param {SitePlanStorageControllerCheck1VEnum} v Version
         * @param {SitePlanStorageControllerCheck1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanStorageControllerCheck1: async (v: SitePlanStorageControllerCheck1VEnum, language: SitePlanStorageControllerCheck1LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanStorageControllerCheck1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanStorageControllerCheck1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('sitePlanStorageControllerCheck1', 'projectId', projectId)
            const localVarPath = `/method/plan_storage/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get discount of storage
         * @param {SitePlanStorageControllerGetDiscount1VEnum} v Version
         * @param {SitePlanStorageControllerGetDiscount1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanStorageControllerGetDiscount1: async (v: SitePlanStorageControllerGetDiscount1VEnum, language: SitePlanStorageControllerGetDiscount1LanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanStorageControllerGetDiscount1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanStorageControllerGetDiscount1', 'language', language)
            const localVarPath = `/method/plan_storage/get_discount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get info for storage tariff
         * @param {SitePlanStorageControllerList1VEnum} v Version
         * @param {SitePlanStorageControllerList1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanStorageControllerList1: async (v: SitePlanStorageControllerList1VEnum, language: SitePlanStorageControllerList1LanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanStorageControllerList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanStorageControllerList1', 'language', language)
            const localVarPath = `/method/plan_storage/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tariff for project
         * @param {SitePlanStorageControllerTariff1VEnum} v Version
         * @param {SitePlanStorageControllerTariff1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanStorageControllerTariff1: async (v: SitePlanStorageControllerTariff1VEnum, language: SitePlanStorageControllerTariff1LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanStorageControllerTariff1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanStorageControllerTariff1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('sitePlanStorageControllerTariff1', 'projectId', projectId)
            const localVarPath = `/method/plan_storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlanStorageApi - functional programming interface
 * @export
 */
export const PlanStorageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlanStorageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Buy storage tariff
         * @param {SitePlanStorageControllerBuy1VEnum} v Version
         * @param {SitePlanStorageControllerBuy1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {SitePlanStorageControllerBuy1PeriodEnum} period Period
         * @param {number} planStorageId Storage plan id
         * @param {number} [size] Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanStorageControllerBuy1(v: SitePlanStorageControllerBuy1VEnum, language: SitePlanStorageControllerBuy1LanguageEnum, projectId: number, period: SitePlanStorageControllerBuy1PeriodEnum, planStorageId: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanStorageControllerBuy1(v, language, projectId, period, planStorageId, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanStorageApi.sitePlanStorageControllerBuy1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove next tariff
         * @param {SitePlanStorageControllerCancel1VEnum} v Version
         * @param {SitePlanStorageControllerCancel1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanStorageControllerCancel1(v: SitePlanStorageControllerCancel1VEnum, language: SitePlanStorageControllerCancel1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanStorageControllerCancel1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanStorageApi.sitePlanStorageControllerCancel1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check storage tariff before buy
         * @param {SitePlanStorageControllerCheck1VEnum} v Version
         * @param {SitePlanStorageControllerCheck1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanStorageControllerCheck1(v: SitePlanStorageControllerCheck1VEnum, language: SitePlanStorageControllerCheck1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanStorageCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanStorageControllerCheck1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanStorageApi.sitePlanStorageControllerCheck1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get discount of storage
         * @param {SitePlanStorageControllerGetDiscount1VEnum} v Version
         * @param {SitePlanStorageControllerGetDiscount1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanStorageControllerGetDiscount1(v: SitePlanStorageControllerGetDiscount1VEnum, language: SitePlanStorageControllerGetDiscount1LanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanStorageDiscountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanStorageControllerGetDiscount1(v, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanStorageApi.sitePlanStorageControllerGetDiscount1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get info for storage tariff
         * @param {SitePlanStorageControllerList1VEnum} v Version
         * @param {SitePlanStorageControllerList1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanStorageControllerList1(v: SitePlanStorageControllerList1VEnum, language: SitePlanStorageControllerList1LanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanStorageResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanStorageControllerList1(v, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanStorageApi.sitePlanStorageControllerList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get tariff for project
         * @param {SitePlanStorageControllerTariff1VEnum} v Version
         * @param {SitePlanStorageControllerTariff1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanStorageControllerTariff1(v: SitePlanStorageControllerTariff1VEnum, language: SitePlanStorageControllerTariff1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanStorageForProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanStorageControllerTariff1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanStorageApi.sitePlanStorageControllerTariff1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlanStorageApi - factory interface
 * @export
 */
export const PlanStorageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlanStorageApiFp(configuration)
    return {
        /**
         * 
         * @summary Buy storage tariff
         * @param {SitePlanStorageControllerBuy1VEnum} v Version
         * @param {SitePlanStorageControllerBuy1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {SitePlanStorageControllerBuy1PeriodEnum} period Period
         * @param {number} planStorageId Storage plan id
         * @param {number} [size] Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanStorageControllerBuy1(v: SitePlanStorageControllerBuy1VEnum, language: SitePlanStorageControllerBuy1LanguageEnum, projectId: number, period: SitePlanStorageControllerBuy1PeriodEnum, planStorageId: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.sitePlanStorageControllerBuy1(v, language, projectId, period, planStorageId, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove next tariff
         * @param {SitePlanStorageControllerCancel1VEnum} v Version
         * @param {SitePlanStorageControllerCancel1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanStorageControllerCancel1(v: SitePlanStorageControllerCancel1VEnum, language: SitePlanStorageControllerCancel1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.sitePlanStorageControllerCancel1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check storage tariff before buy
         * @param {SitePlanStorageControllerCheck1VEnum} v Version
         * @param {SitePlanStorageControllerCheck1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanStorageControllerCheck1(v: SitePlanStorageControllerCheck1VEnum, language: SitePlanStorageControllerCheck1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<PlanStorageCheckResponse> {
            return localVarFp.sitePlanStorageControllerCheck1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get discount of storage
         * @param {SitePlanStorageControllerGetDiscount1VEnum} v Version
         * @param {SitePlanStorageControllerGetDiscount1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanStorageControllerGetDiscount1(v: SitePlanStorageControllerGetDiscount1VEnum, language: SitePlanStorageControllerGetDiscount1LanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<PlanStorageDiscountResponse> {
            return localVarFp.sitePlanStorageControllerGetDiscount1(v, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get info for storage tariff
         * @param {SitePlanStorageControllerList1VEnum} v Version
         * @param {SitePlanStorageControllerList1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanStorageControllerList1(v: SitePlanStorageControllerList1VEnum, language: SitePlanStorageControllerList1LanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<PlanStorageResponseDto> {
            return localVarFp.sitePlanStorageControllerList1(v, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tariff for project
         * @param {SitePlanStorageControllerTariff1VEnum} v Version
         * @param {SitePlanStorageControllerTariff1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanStorageControllerTariff1(v: SitePlanStorageControllerTariff1VEnum, language: SitePlanStorageControllerTariff1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<PlanStorageForProject> {
            return localVarFp.sitePlanStorageControllerTariff1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlanStorageApi - object-oriented interface
 * @export
 * @class PlanStorageApi
 * @extends {BaseAPI}
 */
export class PlanStorageApi extends BaseAPI {
    /**
     * 
     * @summary Buy storage tariff
     * @param {SitePlanStorageControllerBuy1VEnum} v Version
     * @param {SitePlanStorageControllerBuy1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {SitePlanStorageControllerBuy1PeriodEnum} period Period
     * @param {number} planStorageId Storage plan id
     * @param {number} [size] Size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanStorageApi
     */
    public sitePlanStorageControllerBuy1(v: SitePlanStorageControllerBuy1VEnum, language: SitePlanStorageControllerBuy1LanguageEnum, projectId: number, period: SitePlanStorageControllerBuy1PeriodEnum, planStorageId: number, size?: number, options?: RawAxiosRequestConfig) {
        return PlanStorageApiFp(this.configuration).sitePlanStorageControllerBuy1(v, language, projectId, period, planStorageId, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove next tariff
     * @param {SitePlanStorageControllerCancel1VEnum} v Version
     * @param {SitePlanStorageControllerCancel1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanStorageApi
     */
    public sitePlanStorageControllerCancel1(v: SitePlanStorageControllerCancel1VEnum, language: SitePlanStorageControllerCancel1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return PlanStorageApiFp(this.configuration).sitePlanStorageControllerCancel1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check storage tariff before buy
     * @param {SitePlanStorageControllerCheck1VEnum} v Version
     * @param {SitePlanStorageControllerCheck1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanStorageApi
     */
    public sitePlanStorageControllerCheck1(v: SitePlanStorageControllerCheck1VEnum, language: SitePlanStorageControllerCheck1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return PlanStorageApiFp(this.configuration).sitePlanStorageControllerCheck1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get discount of storage
     * @param {SitePlanStorageControllerGetDiscount1VEnum} v Version
     * @param {SitePlanStorageControllerGetDiscount1LanguageEnum} language Current language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanStorageApi
     */
    public sitePlanStorageControllerGetDiscount1(v: SitePlanStorageControllerGetDiscount1VEnum, language: SitePlanStorageControllerGetDiscount1LanguageEnum, options?: RawAxiosRequestConfig) {
        return PlanStorageApiFp(this.configuration).sitePlanStorageControllerGetDiscount1(v, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get info for storage tariff
     * @param {SitePlanStorageControllerList1VEnum} v Version
     * @param {SitePlanStorageControllerList1LanguageEnum} language Current language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanStorageApi
     */
    public sitePlanStorageControllerList1(v: SitePlanStorageControllerList1VEnum, language: SitePlanStorageControllerList1LanguageEnum, options?: RawAxiosRequestConfig) {
        return PlanStorageApiFp(this.configuration).sitePlanStorageControllerList1(v, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tariff for project
     * @param {SitePlanStorageControllerTariff1VEnum} v Version
     * @param {SitePlanStorageControllerTariff1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanStorageApi
     */
    public sitePlanStorageControllerTariff1(v: SitePlanStorageControllerTariff1VEnum, language: SitePlanStorageControllerTariff1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return PlanStorageApiFp(this.configuration).sitePlanStorageControllerTariff1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SitePlanStorageControllerBuy1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanStorageControllerBuy1VEnum = typeof SitePlanStorageControllerBuy1VEnum[keyof typeof SitePlanStorageControllerBuy1VEnum];
/**
 * @export
 */
export const SitePlanStorageControllerBuy1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanStorageControllerBuy1LanguageEnum = typeof SitePlanStorageControllerBuy1LanguageEnum[keyof typeof SitePlanStorageControllerBuy1LanguageEnum];
/**
 * @export
 */
export const SitePlanStorageControllerBuy1PeriodEnum = {
    Month: 'month',
    Year: 'year'
} as const;
export type SitePlanStorageControllerBuy1PeriodEnum = typeof SitePlanStorageControllerBuy1PeriodEnum[keyof typeof SitePlanStorageControllerBuy1PeriodEnum];
/**
 * @export
 */
export const SitePlanStorageControllerCancel1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanStorageControllerCancel1VEnum = typeof SitePlanStorageControllerCancel1VEnum[keyof typeof SitePlanStorageControllerCancel1VEnum];
/**
 * @export
 */
export const SitePlanStorageControllerCancel1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanStorageControllerCancel1LanguageEnum = typeof SitePlanStorageControllerCancel1LanguageEnum[keyof typeof SitePlanStorageControllerCancel1LanguageEnum];
/**
 * @export
 */
export const SitePlanStorageControllerCheck1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanStorageControllerCheck1VEnum = typeof SitePlanStorageControllerCheck1VEnum[keyof typeof SitePlanStorageControllerCheck1VEnum];
/**
 * @export
 */
export const SitePlanStorageControllerCheck1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanStorageControllerCheck1LanguageEnum = typeof SitePlanStorageControllerCheck1LanguageEnum[keyof typeof SitePlanStorageControllerCheck1LanguageEnum];
/**
 * @export
 */
export const SitePlanStorageControllerGetDiscount1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanStorageControllerGetDiscount1VEnum = typeof SitePlanStorageControllerGetDiscount1VEnum[keyof typeof SitePlanStorageControllerGetDiscount1VEnum];
/**
 * @export
 */
export const SitePlanStorageControllerGetDiscount1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanStorageControllerGetDiscount1LanguageEnum = typeof SitePlanStorageControllerGetDiscount1LanguageEnum[keyof typeof SitePlanStorageControllerGetDiscount1LanguageEnum];
/**
 * @export
 */
export const SitePlanStorageControllerList1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanStorageControllerList1VEnum = typeof SitePlanStorageControllerList1VEnum[keyof typeof SitePlanStorageControllerList1VEnum];
/**
 * @export
 */
export const SitePlanStorageControllerList1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanStorageControllerList1LanguageEnum = typeof SitePlanStorageControllerList1LanguageEnum[keyof typeof SitePlanStorageControllerList1LanguageEnum];
/**
 * @export
 */
export const SitePlanStorageControllerTariff1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanStorageControllerTariff1VEnum = typeof SitePlanStorageControllerTariff1VEnum[keyof typeof SitePlanStorageControllerTariff1VEnum];
/**
 * @export
 */
export const SitePlanStorageControllerTariff1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanStorageControllerTariff1LanguageEnum = typeof SitePlanStorageControllerTariff1LanguageEnum[keyof typeof SitePlanStorageControllerTariff1LanguageEnum];


/**
 * PlanTranscodingApi - axios parameter creator
 * @export
 */
export const PlanTranscodingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Buy transcoder tariff
         * @param {SitePlanTranscodingControllerBuy1VEnum} v Version
         * @param {SitePlanTranscodingControllerBuy1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {SitePlanTranscodingControllerBuy1PeriodEnum} period Period
         * @param {number} planTranscodingId Transcoding plan id
         * @param {number} [count] Count flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanTranscodingControllerBuy1: async (v: SitePlanTranscodingControllerBuy1VEnum, language: SitePlanTranscodingControllerBuy1LanguageEnum, projectId: number, period: SitePlanTranscodingControllerBuy1PeriodEnum, planTranscodingId: number, count?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanTranscodingControllerBuy1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanTranscodingControllerBuy1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('sitePlanTranscodingControllerBuy1', 'projectId', projectId)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('sitePlanTranscodingControllerBuy1', 'period', period)
            // verify required parameter 'planTranscodingId' is not null or undefined
            assertParamExists('sitePlanTranscodingControllerBuy1', 'planTranscodingId', planTranscodingId)
            const localVarPath = `/method/plan_transcoding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (planTranscodingId !== undefined) {
                localVarQueryParameter['plan_transcoding_id'] = planTranscodingId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove after tariff
         * @param {SitePlanTranscodingControllerCancel1VEnum} v Version
         * @param {SitePlanTranscodingControllerCancel1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanTranscodingControllerCancel1: async (v: SitePlanTranscodingControllerCancel1VEnum, language: SitePlanTranscodingControllerCancel1LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanTranscodingControllerCancel1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanTranscodingControllerCancel1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('sitePlanTranscodingControllerCancel1', 'projectId', projectId)
            const localVarPath = `/method/plan_transcoding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check transcoding tariff before buy
         * @param {SitePlanTranscodingControllerCheck1VEnum} v Version
         * @param {SitePlanTranscodingControllerCheck1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanTranscodingControllerCheck1: async (v: SitePlanTranscodingControllerCheck1VEnum, language: SitePlanTranscodingControllerCheck1LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanTranscodingControllerCheck1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanTranscodingControllerCheck1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('sitePlanTranscodingControllerCheck1', 'projectId', projectId)
            const localVarPath = `/method/plan_transcoding/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get discount transcoding
         * @param {SitePlanTranscodingControllerGetDiscount1VEnum} v Version
         * @param {SitePlanTranscodingControllerGetDiscount1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanTranscodingControllerGetDiscount1: async (v: SitePlanTranscodingControllerGetDiscount1VEnum, language: SitePlanTranscodingControllerGetDiscount1LanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanTranscodingControllerGetDiscount1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanTranscodingControllerGetDiscount1', 'language', language)
            const localVarPath = `/method/plan_transcoding/get_discount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of transcoding tariffs
         * @param {SitePlanTranscodingControllerList1VEnum} v Version
         * @param {SitePlanTranscodingControllerList1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanTranscodingControllerList1: async (v: SitePlanTranscodingControllerList1VEnum, language: SitePlanTranscodingControllerList1LanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanTranscodingControllerList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanTranscodingControllerList1', 'language', language)
            const localVarPath = `/method/plan_transcoding/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tariff for project
         * @param {SitePlanTranscodingControllerTariff1VEnum} v Version
         * @param {SitePlanTranscodingControllerTariff1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanTranscodingControllerTariff1: async (v: SitePlanTranscodingControllerTariff1VEnum, language: SitePlanTranscodingControllerTariff1LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlanTranscodingControllerTariff1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlanTranscodingControllerTariff1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('sitePlanTranscodingControllerTariff1', 'projectId', projectId)
            const localVarPath = `/method/plan_transcoding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlanTranscodingApi - functional programming interface
 * @export
 */
export const PlanTranscodingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlanTranscodingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Buy transcoder tariff
         * @param {SitePlanTranscodingControllerBuy1VEnum} v Version
         * @param {SitePlanTranscodingControllerBuy1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {SitePlanTranscodingControllerBuy1PeriodEnum} period Period
         * @param {number} planTranscodingId Transcoding plan id
         * @param {number} [count] Count flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanTranscodingControllerBuy1(v: SitePlanTranscodingControllerBuy1VEnum, language: SitePlanTranscodingControllerBuy1LanguageEnum, projectId: number, period: SitePlanTranscodingControllerBuy1PeriodEnum, planTranscodingId: number, count?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanTranscodingControllerBuy1(v, language, projectId, period, planTranscodingId, count, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanTranscodingApi.sitePlanTranscodingControllerBuy1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove after tariff
         * @param {SitePlanTranscodingControllerCancel1VEnum} v Version
         * @param {SitePlanTranscodingControllerCancel1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanTranscodingControllerCancel1(v: SitePlanTranscodingControllerCancel1VEnum, language: SitePlanTranscodingControllerCancel1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanTranscodingControllerCancel1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanTranscodingApi.sitePlanTranscodingControllerCancel1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check transcoding tariff before buy
         * @param {SitePlanTranscodingControllerCheck1VEnum} v Version
         * @param {SitePlanTranscodingControllerCheck1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanTranscodingControllerCheck1(v: SitePlanTranscodingControllerCheck1VEnum, language: SitePlanTranscodingControllerCheck1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanTranscodingCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanTranscodingControllerCheck1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanTranscodingApi.sitePlanTranscodingControllerCheck1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get discount transcoding
         * @param {SitePlanTranscodingControllerGetDiscount1VEnum} v Version
         * @param {SitePlanTranscodingControllerGetDiscount1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanTranscodingControllerGetDiscount1(v: SitePlanTranscodingControllerGetDiscount1VEnum, language: SitePlanTranscodingControllerGetDiscount1LanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanTranscodingDiscountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanTranscodingControllerGetDiscount1(v, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanTranscodingApi.sitePlanTranscodingControllerGetDiscount1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get list of transcoding tariffs
         * @param {SitePlanTranscodingControllerList1VEnum} v Version
         * @param {SitePlanTranscodingControllerList1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanTranscodingControllerList1(v: SitePlanTranscodingControllerList1VEnum, language: SitePlanTranscodingControllerList1LanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanTranscodingResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanTranscodingControllerList1(v, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanTranscodingApi.sitePlanTranscodingControllerList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get tariff for project
         * @param {SitePlanTranscodingControllerTariff1VEnum} v Version
         * @param {SitePlanTranscodingControllerTariff1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlanTranscodingControllerTariff1(v: SitePlanTranscodingControllerTariff1VEnum, language: SitePlanTranscodingControllerTariff1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanTranscodingForProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlanTranscodingControllerTariff1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanTranscodingApi.sitePlanTranscodingControllerTariff1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlanTranscodingApi - factory interface
 * @export
 */
export const PlanTranscodingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlanTranscodingApiFp(configuration)
    return {
        /**
         * 
         * @summary Buy transcoder tariff
         * @param {SitePlanTranscodingControllerBuy1VEnum} v Version
         * @param {SitePlanTranscodingControllerBuy1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {SitePlanTranscodingControllerBuy1PeriodEnum} period Period
         * @param {number} planTranscodingId Transcoding plan id
         * @param {number} [count] Count flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanTranscodingControllerBuy1(v: SitePlanTranscodingControllerBuy1VEnum, language: SitePlanTranscodingControllerBuy1LanguageEnum, projectId: number, period: SitePlanTranscodingControllerBuy1PeriodEnum, planTranscodingId: number, count?: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.sitePlanTranscodingControllerBuy1(v, language, projectId, period, planTranscodingId, count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove after tariff
         * @param {SitePlanTranscodingControllerCancel1VEnum} v Version
         * @param {SitePlanTranscodingControllerCancel1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanTranscodingControllerCancel1(v: SitePlanTranscodingControllerCancel1VEnum, language: SitePlanTranscodingControllerCancel1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.sitePlanTranscodingControllerCancel1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check transcoding tariff before buy
         * @param {SitePlanTranscodingControllerCheck1VEnum} v Version
         * @param {SitePlanTranscodingControllerCheck1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanTranscodingControllerCheck1(v: SitePlanTranscodingControllerCheck1VEnum, language: SitePlanTranscodingControllerCheck1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<PlanTranscodingCheckResponse> {
            return localVarFp.sitePlanTranscodingControllerCheck1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get discount transcoding
         * @param {SitePlanTranscodingControllerGetDiscount1VEnum} v Version
         * @param {SitePlanTranscodingControllerGetDiscount1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanTranscodingControllerGetDiscount1(v: SitePlanTranscodingControllerGetDiscount1VEnum, language: SitePlanTranscodingControllerGetDiscount1LanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<PlanTranscodingDiscountResponse> {
            return localVarFp.sitePlanTranscodingControllerGetDiscount1(v, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of transcoding tariffs
         * @param {SitePlanTranscodingControllerList1VEnum} v Version
         * @param {SitePlanTranscodingControllerList1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanTranscodingControllerList1(v: SitePlanTranscodingControllerList1VEnum, language: SitePlanTranscodingControllerList1LanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<PlanTranscodingResponseDto> {
            return localVarFp.sitePlanTranscodingControllerList1(v, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tariff for project
         * @param {SitePlanTranscodingControllerTariff1VEnum} v Version
         * @param {SitePlanTranscodingControllerTariff1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlanTranscodingControllerTariff1(v: SitePlanTranscodingControllerTariff1VEnum, language: SitePlanTranscodingControllerTariff1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<PlanTranscodingForProject> {
            return localVarFp.sitePlanTranscodingControllerTariff1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlanTranscodingApi - object-oriented interface
 * @export
 * @class PlanTranscodingApi
 * @extends {BaseAPI}
 */
export class PlanTranscodingApi extends BaseAPI {
    /**
     * 
     * @summary Buy transcoder tariff
     * @param {SitePlanTranscodingControllerBuy1VEnum} v Version
     * @param {SitePlanTranscodingControllerBuy1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {SitePlanTranscodingControllerBuy1PeriodEnum} period Period
     * @param {number} planTranscodingId Transcoding plan id
     * @param {number} [count] Count flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanTranscodingApi
     */
    public sitePlanTranscodingControllerBuy1(v: SitePlanTranscodingControllerBuy1VEnum, language: SitePlanTranscodingControllerBuy1LanguageEnum, projectId: number, period: SitePlanTranscodingControllerBuy1PeriodEnum, planTranscodingId: number, count?: number, options?: RawAxiosRequestConfig) {
        return PlanTranscodingApiFp(this.configuration).sitePlanTranscodingControllerBuy1(v, language, projectId, period, planTranscodingId, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove after tariff
     * @param {SitePlanTranscodingControllerCancel1VEnum} v Version
     * @param {SitePlanTranscodingControllerCancel1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanTranscodingApi
     */
    public sitePlanTranscodingControllerCancel1(v: SitePlanTranscodingControllerCancel1VEnum, language: SitePlanTranscodingControllerCancel1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return PlanTranscodingApiFp(this.configuration).sitePlanTranscodingControllerCancel1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check transcoding tariff before buy
     * @param {SitePlanTranscodingControllerCheck1VEnum} v Version
     * @param {SitePlanTranscodingControllerCheck1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanTranscodingApi
     */
    public sitePlanTranscodingControllerCheck1(v: SitePlanTranscodingControllerCheck1VEnum, language: SitePlanTranscodingControllerCheck1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return PlanTranscodingApiFp(this.configuration).sitePlanTranscodingControllerCheck1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get discount transcoding
     * @param {SitePlanTranscodingControllerGetDiscount1VEnum} v Version
     * @param {SitePlanTranscodingControllerGetDiscount1LanguageEnum} language Current language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanTranscodingApi
     */
    public sitePlanTranscodingControllerGetDiscount1(v: SitePlanTranscodingControllerGetDiscount1VEnum, language: SitePlanTranscodingControllerGetDiscount1LanguageEnum, options?: RawAxiosRequestConfig) {
        return PlanTranscodingApiFp(this.configuration).sitePlanTranscodingControllerGetDiscount1(v, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of transcoding tariffs
     * @param {SitePlanTranscodingControllerList1VEnum} v Version
     * @param {SitePlanTranscodingControllerList1LanguageEnum} language Current language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanTranscodingApi
     */
    public sitePlanTranscodingControllerList1(v: SitePlanTranscodingControllerList1VEnum, language: SitePlanTranscodingControllerList1LanguageEnum, options?: RawAxiosRequestConfig) {
        return PlanTranscodingApiFp(this.configuration).sitePlanTranscodingControllerList1(v, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tariff for project
     * @param {SitePlanTranscodingControllerTariff1VEnum} v Version
     * @param {SitePlanTranscodingControllerTariff1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanTranscodingApi
     */
    public sitePlanTranscodingControllerTariff1(v: SitePlanTranscodingControllerTariff1VEnum, language: SitePlanTranscodingControllerTariff1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return PlanTranscodingApiFp(this.configuration).sitePlanTranscodingControllerTariff1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SitePlanTranscodingControllerBuy1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanTranscodingControllerBuy1VEnum = typeof SitePlanTranscodingControllerBuy1VEnum[keyof typeof SitePlanTranscodingControllerBuy1VEnum];
/**
 * @export
 */
export const SitePlanTranscodingControllerBuy1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanTranscodingControllerBuy1LanguageEnum = typeof SitePlanTranscodingControllerBuy1LanguageEnum[keyof typeof SitePlanTranscodingControllerBuy1LanguageEnum];
/**
 * @export
 */
export const SitePlanTranscodingControllerBuy1PeriodEnum = {
    Month: 'month',
    Year: 'year'
} as const;
export type SitePlanTranscodingControllerBuy1PeriodEnum = typeof SitePlanTranscodingControllerBuy1PeriodEnum[keyof typeof SitePlanTranscodingControllerBuy1PeriodEnum];
/**
 * @export
 */
export const SitePlanTranscodingControllerCancel1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanTranscodingControllerCancel1VEnum = typeof SitePlanTranscodingControllerCancel1VEnum[keyof typeof SitePlanTranscodingControllerCancel1VEnum];
/**
 * @export
 */
export const SitePlanTranscodingControllerCancel1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanTranscodingControllerCancel1LanguageEnum = typeof SitePlanTranscodingControllerCancel1LanguageEnum[keyof typeof SitePlanTranscodingControllerCancel1LanguageEnum];
/**
 * @export
 */
export const SitePlanTranscodingControllerCheck1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanTranscodingControllerCheck1VEnum = typeof SitePlanTranscodingControllerCheck1VEnum[keyof typeof SitePlanTranscodingControllerCheck1VEnum];
/**
 * @export
 */
export const SitePlanTranscodingControllerCheck1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanTranscodingControllerCheck1LanguageEnum = typeof SitePlanTranscodingControllerCheck1LanguageEnum[keyof typeof SitePlanTranscodingControllerCheck1LanguageEnum];
/**
 * @export
 */
export const SitePlanTranscodingControllerGetDiscount1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanTranscodingControllerGetDiscount1VEnum = typeof SitePlanTranscodingControllerGetDiscount1VEnum[keyof typeof SitePlanTranscodingControllerGetDiscount1VEnum];
/**
 * @export
 */
export const SitePlanTranscodingControllerGetDiscount1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanTranscodingControllerGetDiscount1LanguageEnum = typeof SitePlanTranscodingControllerGetDiscount1LanguageEnum[keyof typeof SitePlanTranscodingControllerGetDiscount1LanguageEnum];
/**
 * @export
 */
export const SitePlanTranscodingControllerList1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanTranscodingControllerList1VEnum = typeof SitePlanTranscodingControllerList1VEnum[keyof typeof SitePlanTranscodingControllerList1VEnum];
/**
 * @export
 */
export const SitePlanTranscodingControllerList1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanTranscodingControllerList1LanguageEnum = typeof SitePlanTranscodingControllerList1LanguageEnum[keyof typeof SitePlanTranscodingControllerList1LanguageEnum];
/**
 * @export
 */
export const SitePlanTranscodingControllerTariff1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlanTranscodingControllerTariff1VEnum = typeof SitePlanTranscodingControllerTariff1VEnum[keyof typeof SitePlanTranscodingControllerTariff1VEnum];
/**
 * @export
 */
export const SitePlanTranscodingControllerTariff1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlanTranscodingControllerTariff1LanguageEnum = typeof SitePlanTranscodingControllerTariff1LanguageEnum[keyof typeof SitePlanTranscodingControllerTariff1LanguageEnum];


/**
 * PlatformsApi - axios parameter creator
 * @export
 */
export const PlatformsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get url for start oauth
         * @param {SitePlatformsControllerAddAccount1VEnum} v Version
         * @param {SitePlatformsControllerAddAccount1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {SitePlatformsControllerAddAccount1PlatformEnum} platform Provider oauth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlatformsControllerAddAccount1: async (v: SitePlatformsControllerAddAccount1VEnum, language: SitePlatformsControllerAddAccount1LanguageEnum, projectId: number, platform: SitePlatformsControllerAddAccount1PlatformEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlatformsControllerAddAccount1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlatformsControllerAddAccount1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('sitePlatformsControllerAddAccount1', 'projectId', projectId)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('sitePlatformsControllerAddAccount1', 'platform', platform)
            const localVarPath = `/method/platforms/connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get category from the platform
         * @param {SitePlatformsControllerGetCategory1VEnum} v Version
         * @param {SitePlatformsControllerGetCategory1LanguageEnum} language Current language
         * @param {SitePlatformsControllerGetCategory1TypeEnum} type Category search bar
         * @param {string} [q] Category search bar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlatformsControllerGetCategory1: async (v: SitePlatformsControllerGetCategory1VEnum, language: SitePlatformsControllerGetCategory1LanguageEnum, type: SitePlatformsControllerGetCategory1TypeEnum, q?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlatformsControllerGetCategory1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlatformsControllerGetCategory1', 'language', language)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('sitePlatformsControllerGetCategory1', 'type', type)
            const localVarPath = `/method/platforms/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get category from the platform
         * @param {SitePlatformsControllerLogoutAccount1VEnum} v Version
         * @param {SitePlatformsControllerLogoutAccount1LanguageEnum} language Current language
         * @param {string} id Category search bar
         * @param {SitePlatformsControllerLogoutAccount1PlatformEnum} platform Provider oauth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlatformsControllerLogoutAccount1: async (v: SitePlatformsControllerLogoutAccount1VEnum, language: SitePlatformsControllerLogoutAccount1LanguageEnum, id: string, platform: SitePlatformsControllerLogoutAccount1PlatformEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlatformsControllerLogoutAccount1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlatformsControllerLogoutAccount1', 'language', language)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sitePlatformsControllerLogoutAccount1', 'id', id)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('sitePlatformsControllerLogoutAccount1', 'platform', platform)
            const localVarPath = `/method/platforms/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Supported platforms
         * @param {SitePlatformsControllerPlatformList1VEnum} v Version
         * @param {SitePlatformsControllerPlatformList1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlatformsControllerPlatformList1: async (v: SitePlatformsControllerPlatformList1VEnum, language: SitePlatformsControllerPlatformList1LanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePlatformsControllerPlatformList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePlatformsControllerPlatformList1', 'language', language)
            const localVarPath = `/method/platforms/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlatformsApi - functional programming interface
 * @export
 */
export const PlatformsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlatformsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get url for start oauth
         * @param {SitePlatformsControllerAddAccount1VEnum} v Version
         * @param {SitePlatformsControllerAddAccount1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {SitePlatformsControllerAddAccount1PlatformEnum} platform Provider oauth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlatformsControllerAddAccount1(v: SitePlatformsControllerAddAccount1VEnum, language: SitePlatformsControllerAddAccount1LanguageEnum, projectId: number, platform: SitePlatformsControllerAddAccount1PlatformEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlatformsControllerAddAccount1(v, language, projectId, platform, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlatformsApi.sitePlatformsControllerAddAccount1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get category from the platform
         * @param {SitePlatformsControllerGetCategory1VEnum} v Version
         * @param {SitePlatformsControllerGetCategory1LanguageEnum} language Current language
         * @param {SitePlatformsControllerGetCategory1TypeEnum} type Category search bar
         * @param {string} [q] Category search bar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlatformsControllerGetCategory1(v: SitePlatformsControllerGetCategory1VEnum, language: SitePlatformsControllerGetCategory1LanguageEnum, type: SitePlatformsControllerGetCategory1TypeEnum, q?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOfCategoryItemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlatformsControllerGetCategory1(v, language, type, q, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlatformsApi.sitePlatformsControllerGetCategory1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get category from the platform
         * @param {SitePlatformsControllerLogoutAccount1VEnum} v Version
         * @param {SitePlatformsControllerLogoutAccount1LanguageEnum} language Current language
         * @param {string} id Category search bar
         * @param {SitePlatformsControllerLogoutAccount1PlatformEnum} platform Provider oauth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlatformsControllerLogoutAccount1(v: SitePlatformsControllerLogoutAccount1VEnum, language: SitePlatformsControllerLogoutAccount1LanguageEnum, id: string, platform: SitePlatformsControllerLogoutAccount1PlatformEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOfCategoryItemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlatformsControllerLogoutAccount1(v, language, id, platform, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlatformsApi.sitePlatformsControllerLogoutAccount1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Supported platforms
         * @param {SitePlatformsControllerPlatformList1VEnum} v Version
         * @param {SitePlatformsControllerPlatformList1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePlatformsControllerPlatformList1(v: SitePlatformsControllerPlatformList1VEnum, language: SitePlatformsControllerPlatformList1LanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SitePlatformsSupportedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePlatformsControllerPlatformList1(v, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlatformsApi.sitePlatformsControllerPlatformList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlatformsApi - factory interface
 * @export
 */
export const PlatformsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlatformsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get url for start oauth
         * @param {SitePlatformsControllerAddAccount1VEnum} v Version
         * @param {SitePlatformsControllerAddAccount1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {SitePlatformsControllerAddAccount1PlatformEnum} platform Provider oauth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlatformsControllerAddAccount1(v: SitePlatformsControllerAddAccount1VEnum, language: SitePlatformsControllerAddAccount1LanguageEnum, projectId: number, platform: SitePlatformsControllerAddAccount1PlatformEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sitePlatformsControllerAddAccount1(v, language, projectId, platform, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get category from the platform
         * @param {SitePlatformsControllerGetCategory1VEnum} v Version
         * @param {SitePlatformsControllerGetCategory1LanguageEnum} language Current language
         * @param {SitePlatformsControllerGetCategory1TypeEnum} type Category search bar
         * @param {string} [q] Category search bar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlatformsControllerGetCategory1(v: SitePlatformsControllerGetCategory1VEnum, language: SitePlatformsControllerGetCategory1LanguageEnum, type: SitePlatformsControllerGetCategory1TypeEnum, q?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListOfCategoryItemResponse> {
            return localVarFp.sitePlatformsControllerGetCategory1(v, language, type, q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get category from the platform
         * @param {SitePlatformsControllerLogoutAccount1VEnum} v Version
         * @param {SitePlatformsControllerLogoutAccount1LanguageEnum} language Current language
         * @param {string} id Category search bar
         * @param {SitePlatformsControllerLogoutAccount1PlatformEnum} platform Provider oauth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlatformsControllerLogoutAccount1(v: SitePlatformsControllerLogoutAccount1VEnum, language: SitePlatformsControllerLogoutAccount1LanguageEnum, id: string, platform: SitePlatformsControllerLogoutAccount1PlatformEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListOfCategoryItemResponse> {
            return localVarFp.sitePlatformsControllerLogoutAccount1(v, language, id, platform, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Supported platforms
         * @param {SitePlatformsControllerPlatformList1VEnum} v Version
         * @param {SitePlatformsControllerPlatformList1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePlatformsControllerPlatformList1(v: SitePlatformsControllerPlatformList1VEnum, language: SitePlatformsControllerPlatformList1LanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<SitePlatformsSupportedResponse> {
            return localVarFp.sitePlatformsControllerPlatformList1(v, language, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlatformsApi - object-oriented interface
 * @export
 * @class PlatformsApi
 * @extends {BaseAPI}
 */
export class PlatformsApi extends BaseAPI {
    /**
     * 
     * @summary Get url for start oauth
     * @param {SitePlatformsControllerAddAccount1VEnum} v Version
     * @param {SitePlatformsControllerAddAccount1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {SitePlatformsControllerAddAccount1PlatformEnum} platform Provider oauth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformsApi
     */
    public sitePlatformsControllerAddAccount1(v: SitePlatformsControllerAddAccount1VEnum, language: SitePlatformsControllerAddAccount1LanguageEnum, projectId: number, platform: SitePlatformsControllerAddAccount1PlatformEnum, options?: RawAxiosRequestConfig) {
        return PlatformsApiFp(this.configuration).sitePlatformsControllerAddAccount1(v, language, projectId, platform, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get category from the platform
     * @param {SitePlatformsControllerGetCategory1VEnum} v Version
     * @param {SitePlatformsControllerGetCategory1LanguageEnum} language Current language
     * @param {SitePlatformsControllerGetCategory1TypeEnum} type Category search bar
     * @param {string} [q] Category search bar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformsApi
     */
    public sitePlatformsControllerGetCategory1(v: SitePlatformsControllerGetCategory1VEnum, language: SitePlatformsControllerGetCategory1LanguageEnum, type: SitePlatformsControllerGetCategory1TypeEnum, q?: string, options?: RawAxiosRequestConfig) {
        return PlatformsApiFp(this.configuration).sitePlatformsControllerGetCategory1(v, language, type, q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get category from the platform
     * @param {SitePlatformsControllerLogoutAccount1VEnum} v Version
     * @param {SitePlatformsControllerLogoutAccount1LanguageEnum} language Current language
     * @param {string} id Category search bar
     * @param {SitePlatformsControllerLogoutAccount1PlatformEnum} platform Provider oauth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformsApi
     */
    public sitePlatformsControllerLogoutAccount1(v: SitePlatformsControllerLogoutAccount1VEnum, language: SitePlatformsControllerLogoutAccount1LanguageEnum, id: string, platform: SitePlatformsControllerLogoutAccount1PlatformEnum, options?: RawAxiosRequestConfig) {
        return PlatformsApiFp(this.configuration).sitePlatformsControllerLogoutAccount1(v, language, id, platform, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Supported platforms
     * @param {SitePlatformsControllerPlatformList1VEnum} v Version
     * @param {SitePlatformsControllerPlatformList1LanguageEnum} language Current language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformsApi
     */
    public sitePlatformsControllerPlatformList1(v: SitePlatformsControllerPlatformList1VEnum, language: SitePlatformsControllerPlatformList1LanguageEnum, options?: RawAxiosRequestConfig) {
        return PlatformsApiFp(this.configuration).sitePlatformsControllerPlatformList1(v, language, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SitePlatformsControllerAddAccount1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlatformsControllerAddAccount1VEnum = typeof SitePlatformsControllerAddAccount1VEnum[keyof typeof SitePlatformsControllerAddAccount1VEnum];
/**
 * @export
 */
export const SitePlatformsControllerAddAccount1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlatformsControllerAddAccount1LanguageEnum = typeof SitePlatformsControllerAddAccount1LanguageEnum[keyof typeof SitePlatformsControllerAddAccount1LanguageEnum];
/**
 * @export
 */
export const SitePlatformsControllerAddAccount1PlatformEnum = {
    Vk: 'vk',
    VkId: 'vk-id',
    Ok: 'ok',
    Youtube: 'youtube',
    Trovo: 'trovo',
    Twitch: 'twitch'
} as const;
export type SitePlatformsControllerAddAccount1PlatformEnum = typeof SitePlatformsControllerAddAccount1PlatformEnum[keyof typeof SitePlatformsControllerAddAccount1PlatformEnum];
/**
 * @export
 */
export const SitePlatformsControllerGetCategory1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlatformsControllerGetCategory1VEnum = typeof SitePlatformsControllerGetCategory1VEnum[keyof typeof SitePlatformsControllerGetCategory1VEnum];
/**
 * @export
 */
export const SitePlatformsControllerGetCategory1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlatformsControllerGetCategory1LanguageEnum = typeof SitePlatformsControllerGetCategory1LanguageEnum[keyof typeof SitePlatformsControllerGetCategory1LanguageEnum];
/**
 * @export
 */
export const SitePlatformsControllerGetCategory1TypeEnum = {
    Vk: 'vk',
    Youtube: 'youtube',
    Trovo: 'trovo',
    Twitch: 'twitch',
    Vkvideolive: 'vkvideolive'
} as const;
export type SitePlatformsControllerGetCategory1TypeEnum = typeof SitePlatformsControllerGetCategory1TypeEnum[keyof typeof SitePlatformsControllerGetCategory1TypeEnum];
/**
 * @export
 */
export const SitePlatformsControllerLogoutAccount1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlatformsControllerLogoutAccount1VEnum = typeof SitePlatformsControllerLogoutAccount1VEnum[keyof typeof SitePlatformsControllerLogoutAccount1VEnum];
/**
 * @export
 */
export const SitePlatformsControllerLogoutAccount1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlatformsControllerLogoutAccount1LanguageEnum = typeof SitePlatformsControllerLogoutAccount1LanguageEnum[keyof typeof SitePlatformsControllerLogoutAccount1LanguageEnum];
/**
 * @export
 */
export const SitePlatformsControllerLogoutAccount1PlatformEnum = {
    Vk: 'vk',
    VkId: 'vk-id',
    Ok: 'ok',
    Youtube: 'youtube',
    Trovo: 'trovo',
    Twitch: 'twitch'
} as const;
export type SitePlatformsControllerLogoutAccount1PlatformEnum = typeof SitePlatformsControllerLogoutAccount1PlatformEnum[keyof typeof SitePlatformsControllerLogoutAccount1PlatformEnum];
/**
 * @export
 */
export const SitePlatformsControllerPlatformList1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePlatformsControllerPlatformList1VEnum = typeof SitePlatformsControllerPlatformList1VEnum[keyof typeof SitePlatformsControllerPlatformList1VEnum];
/**
 * @export
 */
export const SitePlatformsControllerPlatformList1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePlatformsControllerPlatformList1LanguageEnum = typeof SitePlatformsControllerPlatformList1LanguageEnum[keyof typeof SitePlatformsControllerPlatformList1LanguageEnum];


/**
 * PolicyPageApi - axios parameter creator
 * @export
 */
export const PolicyPageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get policy page
         * @param {SitePolicyPageControllerGetItem1VEnum} v Version
         * @param {SitePolicyPageControllerGetItem1LanguageEnum} language Current language
         * @param {SitePolicyPageControllerGetItem1FileNameEnum} fileName Policy file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePolicyPageControllerGetItem1: async (v: SitePolicyPageControllerGetItem1VEnum, language: SitePolicyPageControllerGetItem1LanguageEnum, fileName: SitePolicyPageControllerGetItem1FileNameEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePolicyPageControllerGetItem1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePolicyPageControllerGetItem1', 'language', language)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('sitePolicyPageControllerGetItem1', 'fileName', fileName)
            const localVarPath = `/method/policy/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['file_name'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get policy structure
         * @param {SitePolicyPageControllerGetStructure1VEnum} v Version
         * @param {SitePolicyPageControllerGetStructure1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePolicyPageControllerGetStructure1: async (v: SitePolicyPageControllerGetStructure1VEnum, language: SitePolicyPageControllerGetStructure1LanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('sitePolicyPageControllerGetStructure1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('sitePolicyPageControllerGetStructure1', 'language', language)
            const localVarPath = `/method/policy/structure`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PolicyPageApi - functional programming interface
 * @export
 */
export const PolicyPageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PolicyPageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get policy page
         * @param {SitePolicyPageControllerGetItem1VEnum} v Version
         * @param {SitePolicyPageControllerGetItem1LanguageEnum} language Current language
         * @param {SitePolicyPageControllerGetItem1FileNameEnum} fileName Policy file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePolicyPageControllerGetItem1(v: SitePolicyPageControllerGetItem1VEnum, language: SitePolicyPageControllerGetItem1LanguageEnum, fileName: SitePolicyPageControllerGetItem1FileNameEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePolicyPageControllerGetItem1(v, language, fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PolicyPageApi.sitePolicyPageControllerGetItem1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get policy structure
         * @param {SitePolicyPageControllerGetStructure1VEnum} v Version
         * @param {SitePolicyPageControllerGetStructure1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitePolicyPageControllerGetStructure1(v: SitePolicyPageControllerGetStructure1VEnum, language: SitePolicyPageControllerGetStructure1LanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteGetPolicyStructureDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitePolicyPageControllerGetStructure1(v, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PolicyPageApi.sitePolicyPageControllerGetStructure1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PolicyPageApi - factory interface
 * @export
 */
export const PolicyPageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PolicyPageApiFp(configuration)
    return {
        /**
         * 
         * @summary Get policy page
         * @param {SitePolicyPageControllerGetItem1VEnum} v Version
         * @param {SitePolicyPageControllerGetItem1LanguageEnum} language Current language
         * @param {SitePolicyPageControllerGetItem1FileNameEnum} fileName Policy file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePolicyPageControllerGetItem1(v: SitePolicyPageControllerGetItem1VEnum, language: SitePolicyPageControllerGetItem1LanguageEnum, fileName: SitePolicyPageControllerGetItem1FileNameEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sitePolicyPageControllerGetItem1(v, language, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get policy structure
         * @param {SitePolicyPageControllerGetStructure1VEnum} v Version
         * @param {SitePolicyPageControllerGetStructure1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitePolicyPageControllerGetStructure1(v: SitePolicyPageControllerGetStructure1VEnum, language: SitePolicyPageControllerGetStructure1LanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<SiteGetPolicyStructureDto> {
            return localVarFp.sitePolicyPageControllerGetStructure1(v, language, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PolicyPageApi - object-oriented interface
 * @export
 * @class PolicyPageApi
 * @extends {BaseAPI}
 */
export class PolicyPageApi extends BaseAPI {
    /**
     * 
     * @summary Get policy page
     * @param {SitePolicyPageControllerGetItem1VEnum} v Version
     * @param {SitePolicyPageControllerGetItem1LanguageEnum} language Current language
     * @param {SitePolicyPageControllerGetItem1FileNameEnum} fileName Policy file name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyPageApi
     */
    public sitePolicyPageControllerGetItem1(v: SitePolicyPageControllerGetItem1VEnum, language: SitePolicyPageControllerGetItem1LanguageEnum, fileName: SitePolicyPageControllerGetItem1FileNameEnum, options?: RawAxiosRequestConfig) {
        return PolicyPageApiFp(this.configuration).sitePolicyPageControllerGetItem1(v, language, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get policy structure
     * @param {SitePolicyPageControllerGetStructure1VEnum} v Version
     * @param {SitePolicyPageControllerGetStructure1LanguageEnum} language Current language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyPageApi
     */
    public sitePolicyPageControllerGetStructure1(v: SitePolicyPageControllerGetStructure1VEnum, language: SitePolicyPageControllerGetStructure1LanguageEnum, options?: RawAxiosRequestConfig) {
        return PolicyPageApiFp(this.configuration).sitePolicyPageControllerGetStructure1(v, language, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SitePolicyPageControllerGetItem1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePolicyPageControllerGetItem1VEnum = typeof SitePolicyPageControllerGetItem1VEnum[keyof typeof SitePolicyPageControllerGetItem1VEnum];
/**
 * @export
 */
export const SitePolicyPageControllerGetItem1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePolicyPageControllerGetItem1LanguageEnum = typeof SitePolicyPageControllerGetItem1LanguageEnum[keyof typeof SitePolicyPageControllerGetItem1LanguageEnum];
/**
 * @export
 */
export const SitePolicyPageControllerGetItem1FileNameEnum = {
    RefundPolicy: 'refund-policy',
    TermsOfUse: 'terms-of-use',
    UsingCookie: 'using-cookie',
    AcceptableUse: 'acceptable-use',
    PrivacyNotice: 'privacy-notice'
} as const;
export type SitePolicyPageControllerGetItem1FileNameEnum = typeof SitePolicyPageControllerGetItem1FileNameEnum[keyof typeof SitePolicyPageControllerGetItem1FileNameEnum];
/**
 * @export
 */
export const SitePolicyPageControllerGetStructure1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SitePolicyPageControllerGetStructure1VEnum = typeof SitePolicyPageControllerGetStructure1VEnum[keyof typeof SitePolicyPageControllerGetStructure1VEnum];
/**
 * @export
 */
export const SitePolicyPageControllerGetStructure1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SitePolicyPageControllerGetStructure1LanguageEnum = typeof SitePolicyPageControllerGetStructure1LanguageEnum[keyof typeof SitePolicyPageControllerGetStructure1LanguageEnum];


/**
 * ProjectApi - axios parameter creator
 * @export
 */
export const ProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get live status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodControllerLiveStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/method/project/live-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get live status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async methodControllerLiveStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MethodProjectLiveStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.methodControllerLiveStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.methodControllerLiveStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectApiFp(configuration)
    return {
        /**
         * 
         * @summary Get live status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodControllerLiveStatus(options?: RawAxiosRequestConfig): AxiosPromise<MethodProjectLiveStatusResponse> {
            return localVarFp.methodControllerLiveStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     * 
     * @summary Get live status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public methodControllerLiveStatus(options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).methodControllerLiveStatus(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectChannelApi - axios parameter creator
 * @export
 */
export const ProjectChannelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change access for project in channel
         * @param {SiteProjectChannelControllerChangeAccess1VEnum} v Version
         * @param {SiteProjectChannelControllerChangeAccess1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {number} toProjectId Target project id
         * @param {SiteProjectChannelControllerChangeAccess1AccessTypeEnum} accessType Access type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelControllerChangeAccess1: async (v: SiteProjectChannelControllerChangeAccess1VEnum, language: SiteProjectChannelControllerChangeAccess1LanguageEnum, projectId: number, channelId: number, toProjectId: number, accessType: SiteProjectChannelControllerChangeAccess1AccessTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteProjectChannelControllerChangeAccess1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteProjectChannelControllerChangeAccess1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteProjectChannelControllerChangeAccess1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteProjectChannelControllerChangeAccess1', 'channelId', channelId)
            // verify required parameter 'toProjectId' is not null or undefined
            assertParamExists('siteProjectChannelControllerChangeAccess1', 'toProjectId', toProjectId)
            // verify required parameter 'accessType' is not null or undefined
            assertParamExists('siteProjectChannelControllerChangeAccess1', 'accessType', accessType)
            const localVarPath = `/method/channel/access/change`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }

            if (toProjectId !== undefined) {
                localVarQueryParameter['to_project_id'] = toProjectId;
            }

            if (accessType !== undefined) {
                localVarQueryParameter['access_type'] = accessType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove access for project in channel
         * @param {SiteProjectChannelControllerDel1VEnum} v Version
         * @param {SiteProjectChannelControllerDel1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {number} targetProjectId Target project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelControllerDel1: async (v: SiteProjectChannelControllerDel1VEnum, language: SiteProjectChannelControllerDel1LanguageEnum, projectId: number, channelId: number, targetProjectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteProjectChannelControllerDel1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteProjectChannelControllerDel1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteProjectChannelControllerDel1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteProjectChannelControllerDel1', 'channelId', channelId)
            // verify required parameter 'targetProjectId' is not null or undefined
            assertParamExists('siteProjectChannelControllerDel1', 'targetProjectId', targetProjectId)
            const localVarPath = `/method/channel/access/del`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }

            if (targetProjectId !== undefined) {
                localVarQueryParameter['target_project_id'] = targetProjectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Project channel list
         * @param {SiteProjectChannelControllerList1VEnum} v Version
         * @param {SiteProjectChannelControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelControllerList1: async (v: SiteProjectChannelControllerList1VEnum, language: SiteProjectChannelControllerList1LanguageEnum, projectId: number, channelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteProjectChannelControllerList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteProjectChannelControllerList1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteProjectChannelControllerList1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteProjectChannelControllerList1', 'channelId', channelId)
            const localVarPath = `/method/channel/access/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer owner for project in channel
         * @param {SiteProjectChannelControllerTransferOwner1VEnum} v Version
         * @param {SiteProjectChannelControllerTransferOwner1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {number} toProjectId Target project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelControllerTransferOwner1: async (v: SiteProjectChannelControllerTransferOwner1VEnum, language: SiteProjectChannelControllerTransferOwner1LanguageEnum, projectId: number, channelId: number, toProjectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteProjectChannelControllerTransferOwner1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteProjectChannelControllerTransferOwner1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteProjectChannelControllerTransferOwner1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteProjectChannelControllerTransferOwner1', 'channelId', channelId)
            // verify required parameter 'toProjectId' is not null or undefined
            assertParamExists('siteProjectChannelControllerTransferOwner1', 'toProjectId', toProjectId)
            const localVarPath = `/method/channel/access/transfer_owner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }

            if (toProjectId !== undefined) {
                localVarQueryParameter['to_project_id'] = toProjectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectChannelApi - functional programming interface
 * @export
 */
export const ProjectChannelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectChannelApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Change access for project in channel
         * @param {SiteProjectChannelControllerChangeAccess1VEnum} v Version
         * @param {SiteProjectChannelControllerChangeAccess1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {number} toProjectId Target project id
         * @param {SiteProjectChannelControllerChangeAccess1AccessTypeEnum} accessType Access type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteProjectChannelControllerChangeAccess1(v: SiteProjectChannelControllerChangeAccess1VEnum, language: SiteProjectChannelControllerChangeAccess1LanguageEnum, projectId: number, channelId: number, toProjectId: number, accessType: SiteProjectChannelControllerChangeAccess1AccessTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteProjectChannelControllerChangeAccess1(v, language, projectId, channelId, toProjectId, accessType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectChannelApi.siteProjectChannelControllerChangeAccess1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove access for project in channel
         * @param {SiteProjectChannelControllerDel1VEnum} v Version
         * @param {SiteProjectChannelControllerDel1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {number} targetProjectId Target project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteProjectChannelControllerDel1(v: SiteProjectChannelControllerDel1VEnum, language: SiteProjectChannelControllerDel1LanguageEnum, projectId: number, channelId: number, targetProjectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteProjectChannelControllerDel1(v, language, projectId, channelId, targetProjectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectChannelApi.siteProjectChannelControllerDel1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Project channel list
         * @param {SiteProjectChannelControllerList1VEnum} v Version
         * @param {SiteProjectChannelControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteProjectChannelControllerList1(v: SiteProjectChannelControllerList1VEnum, language: SiteProjectChannelControllerList1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOfProjectChannelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteProjectChannelControllerList1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectChannelApi.siteProjectChannelControllerList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Transfer owner for project in channel
         * @param {SiteProjectChannelControllerTransferOwner1VEnum} v Version
         * @param {SiteProjectChannelControllerTransferOwner1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {number} toProjectId Target project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteProjectChannelControllerTransferOwner1(v: SiteProjectChannelControllerTransferOwner1VEnum, language: SiteProjectChannelControllerTransferOwner1LanguageEnum, projectId: number, channelId: number, toProjectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteProjectChannelControllerTransferOwner1(v, language, projectId, channelId, toProjectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectChannelApi.siteProjectChannelControllerTransferOwner1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectChannelApi - factory interface
 * @export
 */
export const ProjectChannelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectChannelApiFp(configuration)
    return {
        /**
         * 
         * @summary Change access for project in channel
         * @param {SiteProjectChannelControllerChangeAccess1VEnum} v Version
         * @param {SiteProjectChannelControllerChangeAccess1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {number} toProjectId Target project id
         * @param {SiteProjectChannelControllerChangeAccess1AccessTypeEnum} accessType Access type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelControllerChangeAccess1(v: SiteProjectChannelControllerChangeAccess1VEnum, language: SiteProjectChannelControllerChangeAccess1LanguageEnum, projectId: number, channelId: number, toProjectId: number, accessType: SiteProjectChannelControllerChangeAccess1AccessTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteProjectChannelControllerChangeAccess1(v, language, projectId, channelId, toProjectId, accessType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove access for project in channel
         * @param {SiteProjectChannelControllerDel1VEnum} v Version
         * @param {SiteProjectChannelControllerDel1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {number} targetProjectId Target project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelControllerDel1(v: SiteProjectChannelControllerDel1VEnum, language: SiteProjectChannelControllerDel1LanguageEnum, projectId: number, channelId: number, targetProjectId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteProjectChannelControllerDel1(v, language, projectId, channelId, targetProjectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Project channel list
         * @param {SiteProjectChannelControllerList1VEnum} v Version
         * @param {SiteProjectChannelControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelControllerList1(v: SiteProjectChannelControllerList1VEnum, language: SiteProjectChannelControllerList1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): AxiosPromise<ListOfProjectChannelResponse> {
            return localVarFp.siteProjectChannelControllerList1(v, language, projectId, channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer owner for project in channel
         * @param {SiteProjectChannelControllerTransferOwner1VEnum} v Version
         * @param {SiteProjectChannelControllerTransferOwner1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {number} toProjectId Target project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelControllerTransferOwner1(v: SiteProjectChannelControllerTransferOwner1VEnum, language: SiteProjectChannelControllerTransferOwner1LanguageEnum, projectId: number, channelId: number, toProjectId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteProjectChannelControllerTransferOwner1(v, language, projectId, channelId, toProjectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectChannelApi - object-oriented interface
 * @export
 * @class ProjectChannelApi
 * @extends {BaseAPI}
 */
export class ProjectChannelApi extends BaseAPI {
    /**
     * 
     * @summary Change access for project in channel
     * @param {SiteProjectChannelControllerChangeAccess1VEnum} v Version
     * @param {SiteProjectChannelControllerChangeAccess1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} channelId Channel id
     * @param {number} toProjectId Target project id
     * @param {SiteProjectChannelControllerChangeAccess1AccessTypeEnum} accessType Access type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelApi
     */
    public siteProjectChannelControllerChangeAccess1(v: SiteProjectChannelControllerChangeAccess1VEnum, language: SiteProjectChannelControllerChangeAccess1LanguageEnum, projectId: number, channelId: number, toProjectId: number, accessType: SiteProjectChannelControllerChangeAccess1AccessTypeEnum, options?: RawAxiosRequestConfig) {
        return ProjectChannelApiFp(this.configuration).siteProjectChannelControllerChangeAccess1(v, language, projectId, channelId, toProjectId, accessType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove access for project in channel
     * @param {SiteProjectChannelControllerDel1VEnum} v Version
     * @param {SiteProjectChannelControllerDel1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} channelId Channel id
     * @param {number} targetProjectId Target project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelApi
     */
    public siteProjectChannelControllerDel1(v: SiteProjectChannelControllerDel1VEnum, language: SiteProjectChannelControllerDel1LanguageEnum, projectId: number, channelId: number, targetProjectId: number, options?: RawAxiosRequestConfig) {
        return ProjectChannelApiFp(this.configuration).siteProjectChannelControllerDel1(v, language, projectId, channelId, targetProjectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Project channel list
     * @param {SiteProjectChannelControllerList1VEnum} v Version
     * @param {SiteProjectChannelControllerList1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} channelId Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelApi
     */
    public siteProjectChannelControllerList1(v: SiteProjectChannelControllerList1VEnum, language: SiteProjectChannelControllerList1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig) {
        return ProjectChannelApiFp(this.configuration).siteProjectChannelControllerList1(v, language, projectId, channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transfer owner for project in channel
     * @param {SiteProjectChannelControllerTransferOwner1VEnum} v Version
     * @param {SiteProjectChannelControllerTransferOwner1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} channelId Channel id
     * @param {number} toProjectId Target project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelApi
     */
    public siteProjectChannelControllerTransferOwner1(v: SiteProjectChannelControllerTransferOwner1VEnum, language: SiteProjectChannelControllerTransferOwner1LanguageEnum, projectId: number, channelId: number, toProjectId: number, options?: RawAxiosRequestConfig) {
        return ProjectChannelApiFp(this.configuration).siteProjectChannelControllerTransferOwner1(v, language, projectId, channelId, toProjectId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SiteProjectChannelControllerChangeAccess1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteProjectChannelControllerChangeAccess1VEnum = typeof SiteProjectChannelControllerChangeAccess1VEnum[keyof typeof SiteProjectChannelControllerChangeAccess1VEnum];
/**
 * @export
 */
export const SiteProjectChannelControllerChangeAccess1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteProjectChannelControllerChangeAccess1LanguageEnum = typeof SiteProjectChannelControllerChangeAccess1LanguageEnum[keyof typeof SiteProjectChannelControllerChangeAccess1LanguageEnum];
/**
 * @export
 */
export const SiteProjectChannelControllerChangeAccess1AccessTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_12: 1,
    NUMBER_2: 2
} as const;
export type SiteProjectChannelControllerChangeAccess1AccessTypeEnum = typeof SiteProjectChannelControllerChangeAccess1AccessTypeEnum[keyof typeof SiteProjectChannelControllerChangeAccess1AccessTypeEnum];
/**
 * @export
 */
export const SiteProjectChannelControllerDel1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteProjectChannelControllerDel1VEnum = typeof SiteProjectChannelControllerDel1VEnum[keyof typeof SiteProjectChannelControllerDel1VEnum];
/**
 * @export
 */
export const SiteProjectChannelControllerDel1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteProjectChannelControllerDel1LanguageEnum = typeof SiteProjectChannelControllerDel1LanguageEnum[keyof typeof SiteProjectChannelControllerDel1LanguageEnum];
/**
 * @export
 */
export const SiteProjectChannelControllerList1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteProjectChannelControllerList1VEnum = typeof SiteProjectChannelControllerList1VEnum[keyof typeof SiteProjectChannelControllerList1VEnum];
/**
 * @export
 */
export const SiteProjectChannelControllerList1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteProjectChannelControllerList1LanguageEnum = typeof SiteProjectChannelControllerList1LanguageEnum[keyof typeof SiteProjectChannelControllerList1LanguageEnum];
/**
 * @export
 */
export const SiteProjectChannelControllerTransferOwner1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteProjectChannelControllerTransferOwner1VEnum = typeof SiteProjectChannelControllerTransferOwner1VEnum[keyof typeof SiteProjectChannelControllerTransferOwner1VEnum];
/**
 * @export
 */
export const SiteProjectChannelControllerTransferOwner1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteProjectChannelControllerTransferOwner1LanguageEnum = typeof SiteProjectChannelControllerTransferOwner1LanguageEnum[keyof typeof SiteProjectChannelControllerTransferOwner1LanguageEnum];


/**
 * ProjectChannelInviteApi - axios parameter creator
 * @export
 */
export const ProjectChannelInviteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accept channel invitation for selected project
         * @param {SiteProjectChannelInviteControllerAcceptForProject1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerAcceptForProject1LanguageEnum} language Current language
         * @param {number} projectId The project to which you want to add a channel
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerAcceptForProject1: async (v: SiteProjectChannelInviteControllerAcceptForProject1VEnum, language: SiteProjectChannelInviteControllerAcceptForProject1LanguageEnum, projectId: number, channelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAcceptForProject1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAcceptForProject1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAcceptForProject1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAcceptForProject1', 'channelId', channelId)
            const localVarPath = `/method/channel_invite/accept_for_project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accept channel invitation using a secret link
         * @param {SiteProjectChannelInviteControllerAcceptForSecret1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerAcceptForSecret1LanguageEnum} language Current language
         * @param {number} projectId The project to which you want to add a channel
         * @param {number} channelId Channel id
         * @param {string} secret Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerAcceptForSecret1: async (v: SiteProjectChannelInviteControllerAcceptForSecret1VEnum, language: SiteProjectChannelInviteControllerAcceptForSecret1LanguageEnum, projectId: number, channelId: number, secret: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAcceptForSecret1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAcceptForSecret1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAcceptForSecret1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAcceptForSecret1', 'channelId', channelId)
            // verify required parameter 'secret' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAcceptForSecret1', 'secret', secret)
            const localVarPath = `/method/channel_invite/accept_for_secret`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }

            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add channel invite item for another user by email
         * @param {SiteProjectChannelInviteControllerAddByEmail1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerAddByEmail1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {string} email Email
         * @param {SiteProjectChannelInviteControllerAddByEmail1AccessTypeEnum} accessType Access type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerAddByEmail1: async (v: SiteProjectChannelInviteControllerAddByEmail1VEnum, language: SiteProjectChannelInviteControllerAddByEmail1LanguageEnum, projectId: number, channelId: number, email: string, accessType: SiteProjectChannelInviteControllerAddByEmail1AccessTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAddByEmail1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAddByEmail1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAddByEmail1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAddByEmail1', 'channelId', channelId)
            // verify required parameter 'email' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAddByEmail1', 'email', email)
            // verify required parameter 'accessType' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAddByEmail1', 'accessType', accessType)
            const localVarPath = `/method/channel_invite/add_by_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (accessType !== undefined) {
                localVarQueryParameter['access_type'] = accessType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add channel invite item for another user by id
         * @param {SiteProjectChannelInviteControllerAddById1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerAddById1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {SiteProjectChannelInviteControllerAddById1AccessTypeEnum} accessType Access type
         * @param {string} toProjectExternalId Project for get access by external id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerAddById1: async (v: SiteProjectChannelInviteControllerAddById1VEnum, language: SiteProjectChannelInviteControllerAddById1LanguageEnum, projectId: number, channelId: number, accessType: SiteProjectChannelInviteControllerAddById1AccessTypeEnum, toProjectExternalId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAddById1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAddById1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAddById1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAddById1', 'channelId', channelId)
            // verify required parameter 'accessType' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAddById1', 'accessType', accessType)
            // verify required parameter 'toProjectExternalId' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerAddById1', 'toProjectExternalId', toProjectExternalId)
            const localVarPath = `/method/channel_invite/add_by_id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }

            if (accessType !== undefined) {
                localVarQueryParameter['access_type'] = accessType;
            }

            if (toProjectExternalId !== undefined) {
                localVarQueryParameter['to_project_external_id'] = toProjectExternalId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Decline channel invitation for selected project
         * @param {SiteProjectChannelInviteControllerDeclineForProject1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerDeclineForProject1LanguageEnum} language Current language
         * @param {number} projectId Channel id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerDeclineForProject1: async (v: SiteProjectChannelInviteControllerDeclineForProject1VEnum, language: SiteProjectChannelInviteControllerDeclineForProject1LanguageEnum, projectId: number, channelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerDeclineForProject1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerDeclineForProject1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerDeclineForProject1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerDeclineForProject1', 'channelId', channelId)
            const localVarPath = `/method/channel_invite/decline_for_project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Decline channel invitation using a secret link
         * @param {SiteProjectChannelInviteControllerDeclineForSecret1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerDeclineForSecret1LanguageEnum} language Current language
         * @param {number} projectId The project to which you want to add a channel
         * @param {number} channelId Channel id
         * @param {string} secret Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerDeclineForSecret1: async (v: SiteProjectChannelInviteControllerDeclineForSecret1VEnum, language: SiteProjectChannelInviteControllerDeclineForSecret1LanguageEnum, projectId: number, channelId: number, secret: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerDeclineForSecret1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerDeclineForSecret1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerDeclineForSecret1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerDeclineForSecret1', 'channelId', channelId)
            // verify required parameter 'secret' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerDeclineForSecret1', 'secret', secret)
            const localVarPath = `/method/channel_invite/decline_for_secret`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }

            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Del channel invite item for my channel for another user
         * @param {SiteProjectChannelInviteControllerDel1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerDel1LanguageEnum} language Current language
         * @param {number} id Unique id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerDel1: async (v: SiteProjectChannelInviteControllerDel1VEnum, language: SiteProjectChannelInviteControllerDel1LanguageEnum, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerDel1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerDel1', 'language', language)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerDel1', 'id', id)
            const localVarPath = `/method/channel_invite/del`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get channel invite item for my channel for another user
         * @param {SiteProjectChannelInviteControllerGet1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerGet1LanguageEnum} language Current language
         * @param {number} id Channel request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerGet1: async (v: SiteProjectChannelInviteControllerGet1VEnum, language: SiteProjectChannelInviteControllerGet1LanguageEnum, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerGet1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerGet1', 'language', language)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerGet1', 'id', id)
            const localVarPath = `/method/channel_invite/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get invitation for channel
         * @param {SiteProjectChannelInviteControllerGetForProject1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerGetForProject1LanguageEnum} language Current language
         * @param {number} projectId Current project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerGetForProject1: async (v: SiteProjectChannelInviteControllerGetForProject1VEnum, language: SiteProjectChannelInviteControllerGetForProject1LanguageEnum, projectId: number, channelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerGetForProject1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerGetForProject1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerGetForProject1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerGetForProject1', 'channelId', channelId)
            const localVarPath = `/method/channel_invite/get_for_project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get channel invitation using a secret link
         * @param {SiteProjectChannelInviteControllerGetForSecret1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerGetForSecret1LanguageEnum} language Current language
         * @param {number} channelId Channel id
         * @param {string} secret Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerGetForSecret1: async (v: SiteProjectChannelInviteControllerGetForSecret1VEnum, language: SiteProjectChannelInviteControllerGetForSecret1LanguageEnum, channelId: number, secret: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerGetForSecret1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerGetForSecret1', 'language', language)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerGetForSecret1', 'channelId', channelId)
            // verify required parameter 'secret' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerGetForSecret1', 'secret', secret)
            const localVarPath = `/method/channel_invite/get_for_secret`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }

            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of invites for channel in project
         * @param {SiteProjectChannelInviteControllerList1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerList1: async (v: SiteProjectChannelInviteControllerList1VEnum, language: SiteProjectChannelInviteControllerList1LanguageEnum, projectId: number, channelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerList1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerList1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('siteProjectChannelInviteControllerList1', 'channelId', channelId)
            const localVarPath = `/method/channel_invite/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectChannelInviteApi - functional programming interface
 * @export
 */
export const ProjectChannelInviteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectChannelInviteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accept channel invitation for selected project
         * @param {SiteProjectChannelInviteControllerAcceptForProject1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerAcceptForProject1LanguageEnum} language Current language
         * @param {number} projectId The project to which you want to add a channel
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteProjectChannelInviteControllerAcceptForProject1(v: SiteProjectChannelInviteControllerAcceptForProject1VEnum, language: SiteProjectChannelInviteControllerAcceptForProject1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteProjectChannelInviteControllerAcceptForProject1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectChannelInviteApi.siteProjectChannelInviteControllerAcceptForProject1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Accept channel invitation using a secret link
         * @param {SiteProjectChannelInviteControllerAcceptForSecret1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerAcceptForSecret1LanguageEnum} language Current language
         * @param {number} projectId The project to which you want to add a channel
         * @param {number} channelId Channel id
         * @param {string} secret Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteProjectChannelInviteControllerAcceptForSecret1(v: SiteProjectChannelInviteControllerAcceptForSecret1VEnum, language: SiteProjectChannelInviteControllerAcceptForSecret1LanguageEnum, projectId: number, channelId: number, secret: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteProjectChannelInviteControllerAcceptForSecret1(v, language, projectId, channelId, secret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectChannelInviteApi.siteProjectChannelInviteControllerAcceptForSecret1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add channel invite item for another user by email
         * @param {SiteProjectChannelInviteControllerAddByEmail1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerAddByEmail1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {string} email Email
         * @param {SiteProjectChannelInviteControllerAddByEmail1AccessTypeEnum} accessType Access type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteProjectChannelInviteControllerAddByEmail1(v: SiteProjectChannelInviteControllerAddByEmail1VEnum, language: SiteProjectChannelInviteControllerAddByEmail1LanguageEnum, projectId: number, channelId: number, email: string, accessType: SiteProjectChannelInviteControllerAddByEmail1AccessTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectChannelInviteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteProjectChannelInviteControllerAddByEmail1(v, language, projectId, channelId, email, accessType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectChannelInviteApi.siteProjectChannelInviteControllerAddByEmail1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add channel invite item for another user by id
         * @param {SiteProjectChannelInviteControllerAddById1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerAddById1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {SiteProjectChannelInviteControllerAddById1AccessTypeEnum} accessType Access type
         * @param {string} toProjectExternalId Project for get access by external id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteProjectChannelInviteControllerAddById1(v: SiteProjectChannelInviteControllerAddById1VEnum, language: SiteProjectChannelInviteControllerAddById1LanguageEnum, projectId: number, channelId: number, accessType: SiteProjectChannelInviteControllerAddById1AccessTypeEnum, toProjectExternalId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectChannelInviteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteProjectChannelInviteControllerAddById1(v, language, projectId, channelId, accessType, toProjectExternalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectChannelInviteApi.siteProjectChannelInviteControllerAddById1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Decline channel invitation for selected project
         * @param {SiteProjectChannelInviteControllerDeclineForProject1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerDeclineForProject1LanguageEnum} language Current language
         * @param {number} projectId Channel id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteProjectChannelInviteControllerDeclineForProject1(v: SiteProjectChannelInviteControllerDeclineForProject1VEnum, language: SiteProjectChannelInviteControllerDeclineForProject1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteProjectChannelInviteControllerDeclineForProject1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectChannelInviteApi.siteProjectChannelInviteControllerDeclineForProject1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Decline channel invitation using a secret link
         * @param {SiteProjectChannelInviteControllerDeclineForSecret1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerDeclineForSecret1LanguageEnum} language Current language
         * @param {number} projectId The project to which you want to add a channel
         * @param {number} channelId Channel id
         * @param {string} secret Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteProjectChannelInviteControllerDeclineForSecret1(v: SiteProjectChannelInviteControllerDeclineForSecret1VEnum, language: SiteProjectChannelInviteControllerDeclineForSecret1LanguageEnum, projectId: number, channelId: number, secret: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteProjectChannelInviteControllerDeclineForSecret1(v, language, projectId, channelId, secret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectChannelInviteApi.siteProjectChannelInviteControllerDeclineForSecret1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Del channel invite item for my channel for another user
         * @param {SiteProjectChannelInviteControllerDel1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerDel1LanguageEnum} language Current language
         * @param {number} id Unique id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteProjectChannelInviteControllerDel1(v: SiteProjectChannelInviteControllerDel1VEnum, language: SiteProjectChannelInviteControllerDel1LanguageEnum, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteProjectChannelInviteControllerDel1(v, language, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectChannelInviteApi.siteProjectChannelInviteControllerDel1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get channel invite item for my channel for another user
         * @param {SiteProjectChannelInviteControllerGet1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerGet1LanguageEnum} language Current language
         * @param {number} id Channel request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteProjectChannelInviteControllerGet1(v: SiteProjectChannelInviteControllerGet1VEnum, language: SiteProjectChannelInviteControllerGet1LanguageEnum, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteProjectChannelInviteControllerGet1(v, language, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectChannelInviteApi.siteProjectChannelInviteControllerGet1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get invitation for channel
         * @param {SiteProjectChannelInviteControllerGetForProject1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerGetForProject1LanguageEnum} language Current language
         * @param {number} projectId Current project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteProjectChannelInviteControllerGetForProject1(v: SiteProjectChannelInviteControllerGetForProject1VEnum, language: SiteProjectChannelInviteControllerGetForProject1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectChannelInviteLinkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteProjectChannelInviteControllerGetForProject1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectChannelInviteApi.siteProjectChannelInviteControllerGetForProject1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get channel invitation using a secret link
         * @param {SiteProjectChannelInviteControllerGetForSecret1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerGetForSecret1LanguageEnum} language Current language
         * @param {number} channelId Channel id
         * @param {string} secret Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteProjectChannelInviteControllerGetForSecret1(v: SiteProjectChannelInviteControllerGetForSecret1VEnum, language: SiteProjectChannelInviteControllerGetForSecret1LanguageEnum, channelId: number, secret: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectChannelInviteLinkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteProjectChannelInviteControllerGetForSecret1(v, language, channelId, secret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectChannelInviteApi.siteProjectChannelInviteControllerGetForSecret1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of invites for channel in project
         * @param {SiteProjectChannelInviteControllerList1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteProjectChannelInviteControllerList1(v: SiteProjectChannelInviteControllerList1VEnum, language: SiteProjectChannelInviteControllerList1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOfProjectChannelInviteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteProjectChannelInviteControllerList1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectChannelInviteApi.siteProjectChannelInviteControllerList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectChannelInviteApi - factory interface
 * @export
 */
export const ProjectChannelInviteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectChannelInviteApiFp(configuration)
    return {
        /**
         * 
         * @summary Accept channel invitation for selected project
         * @param {SiteProjectChannelInviteControllerAcceptForProject1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerAcceptForProject1LanguageEnum} language Current language
         * @param {number} projectId The project to which you want to add a channel
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerAcceptForProject1(v: SiteProjectChannelInviteControllerAcceptForProject1VEnum, language: SiteProjectChannelInviteControllerAcceptForProject1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteProjectChannelInviteControllerAcceptForProject1(v, language, projectId, channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Accept channel invitation using a secret link
         * @param {SiteProjectChannelInviteControllerAcceptForSecret1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerAcceptForSecret1LanguageEnum} language Current language
         * @param {number} projectId The project to which you want to add a channel
         * @param {number} channelId Channel id
         * @param {string} secret Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerAcceptForSecret1(v: SiteProjectChannelInviteControllerAcceptForSecret1VEnum, language: SiteProjectChannelInviteControllerAcceptForSecret1LanguageEnum, projectId: number, channelId: number, secret: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteProjectChannelInviteControllerAcceptForSecret1(v, language, projectId, channelId, secret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add channel invite item for another user by email
         * @param {SiteProjectChannelInviteControllerAddByEmail1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerAddByEmail1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {string} email Email
         * @param {SiteProjectChannelInviteControllerAddByEmail1AccessTypeEnum} accessType Access type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerAddByEmail1(v: SiteProjectChannelInviteControllerAddByEmail1VEnum, language: SiteProjectChannelInviteControllerAddByEmail1LanguageEnum, projectId: number, channelId: number, email: string, accessType: SiteProjectChannelInviteControllerAddByEmail1AccessTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<ProjectChannelInviteResponse> {
            return localVarFp.siteProjectChannelInviteControllerAddByEmail1(v, language, projectId, channelId, email, accessType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add channel invite item for another user by id
         * @param {SiteProjectChannelInviteControllerAddById1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerAddById1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {SiteProjectChannelInviteControllerAddById1AccessTypeEnum} accessType Access type
         * @param {string} toProjectExternalId Project for get access by external id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerAddById1(v: SiteProjectChannelInviteControllerAddById1VEnum, language: SiteProjectChannelInviteControllerAddById1LanguageEnum, projectId: number, channelId: number, accessType: SiteProjectChannelInviteControllerAddById1AccessTypeEnum, toProjectExternalId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectChannelInviteResponse> {
            return localVarFp.siteProjectChannelInviteControllerAddById1(v, language, projectId, channelId, accessType, toProjectExternalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Decline channel invitation for selected project
         * @param {SiteProjectChannelInviteControllerDeclineForProject1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerDeclineForProject1LanguageEnum} language Current language
         * @param {number} projectId Channel id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerDeclineForProject1(v: SiteProjectChannelInviteControllerDeclineForProject1VEnum, language: SiteProjectChannelInviteControllerDeclineForProject1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteProjectChannelInviteControllerDeclineForProject1(v, language, projectId, channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Decline channel invitation using a secret link
         * @param {SiteProjectChannelInviteControllerDeclineForSecret1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerDeclineForSecret1LanguageEnum} language Current language
         * @param {number} projectId The project to which you want to add a channel
         * @param {number} channelId Channel id
         * @param {string} secret Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerDeclineForSecret1(v: SiteProjectChannelInviteControllerDeclineForSecret1VEnum, language: SiteProjectChannelInviteControllerDeclineForSecret1LanguageEnum, projectId: number, channelId: number, secret: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteProjectChannelInviteControllerDeclineForSecret1(v, language, projectId, channelId, secret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Del channel invite item for my channel for another user
         * @param {SiteProjectChannelInviteControllerDel1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerDel1LanguageEnum} language Current language
         * @param {number} id Unique id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerDel1(v: SiteProjectChannelInviteControllerDel1VEnum, language: SiteProjectChannelInviteControllerDel1LanguageEnum, id: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteProjectChannelInviteControllerDel1(v, language, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get channel invite item for my channel for another user
         * @param {SiteProjectChannelInviteControllerGet1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerGet1LanguageEnum} language Current language
         * @param {number} id Channel request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerGet1(v: SiteProjectChannelInviteControllerGet1VEnum, language: SiteProjectChannelInviteControllerGet1LanguageEnum, id: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteProjectChannelInviteControllerGet1(v, language, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get invitation for channel
         * @param {SiteProjectChannelInviteControllerGetForProject1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerGetForProject1LanguageEnum} language Current language
         * @param {number} projectId Current project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerGetForProject1(v: SiteProjectChannelInviteControllerGetForProject1VEnum, language: SiteProjectChannelInviteControllerGetForProject1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): AxiosPromise<ProjectChannelInviteLinkResponse> {
            return localVarFp.siteProjectChannelInviteControllerGetForProject1(v, language, projectId, channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get channel invitation using a secret link
         * @param {SiteProjectChannelInviteControllerGetForSecret1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerGetForSecret1LanguageEnum} language Current language
         * @param {number} channelId Channel id
         * @param {string} secret Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerGetForSecret1(v: SiteProjectChannelInviteControllerGetForSecret1VEnum, language: SiteProjectChannelInviteControllerGetForSecret1LanguageEnum, channelId: number, secret: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectChannelInviteLinkResponse> {
            return localVarFp.siteProjectChannelInviteControllerGetForSecret1(v, language, channelId, secret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of invites for channel in project
         * @param {SiteProjectChannelInviteControllerList1VEnum} v Version
         * @param {SiteProjectChannelInviteControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectChannelInviteControllerList1(v: SiteProjectChannelInviteControllerList1VEnum, language: SiteProjectChannelInviteControllerList1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): AxiosPromise<ListOfProjectChannelInviteResponse> {
            return localVarFp.siteProjectChannelInviteControllerList1(v, language, projectId, channelId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectChannelInviteApi - object-oriented interface
 * @export
 * @class ProjectChannelInviteApi
 * @extends {BaseAPI}
 */
export class ProjectChannelInviteApi extends BaseAPI {
    /**
     * 
     * @summary Accept channel invitation for selected project
     * @param {SiteProjectChannelInviteControllerAcceptForProject1VEnum} v Version
     * @param {SiteProjectChannelInviteControllerAcceptForProject1LanguageEnum} language Current language
     * @param {number} projectId The project to which you want to add a channel
     * @param {number} channelId Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    public siteProjectChannelInviteControllerAcceptForProject1(v: SiteProjectChannelInviteControllerAcceptForProject1VEnum, language: SiteProjectChannelInviteControllerAcceptForProject1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig) {
        return ProjectChannelInviteApiFp(this.configuration).siteProjectChannelInviteControllerAcceptForProject1(v, language, projectId, channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Accept channel invitation using a secret link
     * @param {SiteProjectChannelInviteControllerAcceptForSecret1VEnum} v Version
     * @param {SiteProjectChannelInviteControllerAcceptForSecret1LanguageEnum} language Current language
     * @param {number} projectId The project to which you want to add a channel
     * @param {number} channelId Channel id
     * @param {string} secret Secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    public siteProjectChannelInviteControllerAcceptForSecret1(v: SiteProjectChannelInviteControllerAcceptForSecret1VEnum, language: SiteProjectChannelInviteControllerAcceptForSecret1LanguageEnum, projectId: number, channelId: number, secret: string, options?: RawAxiosRequestConfig) {
        return ProjectChannelInviteApiFp(this.configuration).siteProjectChannelInviteControllerAcceptForSecret1(v, language, projectId, channelId, secret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add channel invite item for another user by email
     * @param {SiteProjectChannelInviteControllerAddByEmail1VEnum} v Version
     * @param {SiteProjectChannelInviteControllerAddByEmail1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} channelId Channel id
     * @param {string} email Email
     * @param {SiteProjectChannelInviteControllerAddByEmail1AccessTypeEnum} accessType Access type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    public siteProjectChannelInviteControllerAddByEmail1(v: SiteProjectChannelInviteControllerAddByEmail1VEnum, language: SiteProjectChannelInviteControllerAddByEmail1LanguageEnum, projectId: number, channelId: number, email: string, accessType: SiteProjectChannelInviteControllerAddByEmail1AccessTypeEnum, options?: RawAxiosRequestConfig) {
        return ProjectChannelInviteApiFp(this.configuration).siteProjectChannelInviteControllerAddByEmail1(v, language, projectId, channelId, email, accessType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add channel invite item for another user by id
     * @param {SiteProjectChannelInviteControllerAddById1VEnum} v Version
     * @param {SiteProjectChannelInviteControllerAddById1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} channelId Channel id
     * @param {SiteProjectChannelInviteControllerAddById1AccessTypeEnum} accessType Access type
     * @param {string} toProjectExternalId Project for get access by external id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    public siteProjectChannelInviteControllerAddById1(v: SiteProjectChannelInviteControllerAddById1VEnum, language: SiteProjectChannelInviteControllerAddById1LanguageEnum, projectId: number, channelId: number, accessType: SiteProjectChannelInviteControllerAddById1AccessTypeEnum, toProjectExternalId: string, options?: RawAxiosRequestConfig) {
        return ProjectChannelInviteApiFp(this.configuration).siteProjectChannelInviteControllerAddById1(v, language, projectId, channelId, accessType, toProjectExternalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Decline channel invitation for selected project
     * @param {SiteProjectChannelInviteControllerDeclineForProject1VEnum} v Version
     * @param {SiteProjectChannelInviteControllerDeclineForProject1LanguageEnum} language Current language
     * @param {number} projectId Channel id
     * @param {number} channelId Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    public siteProjectChannelInviteControllerDeclineForProject1(v: SiteProjectChannelInviteControllerDeclineForProject1VEnum, language: SiteProjectChannelInviteControllerDeclineForProject1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig) {
        return ProjectChannelInviteApiFp(this.configuration).siteProjectChannelInviteControllerDeclineForProject1(v, language, projectId, channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Decline channel invitation using a secret link
     * @param {SiteProjectChannelInviteControllerDeclineForSecret1VEnum} v Version
     * @param {SiteProjectChannelInviteControllerDeclineForSecret1LanguageEnum} language Current language
     * @param {number} projectId The project to which you want to add a channel
     * @param {number} channelId Channel id
     * @param {string} secret Secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    public siteProjectChannelInviteControllerDeclineForSecret1(v: SiteProjectChannelInviteControllerDeclineForSecret1VEnum, language: SiteProjectChannelInviteControllerDeclineForSecret1LanguageEnum, projectId: number, channelId: number, secret: string, options?: RawAxiosRequestConfig) {
        return ProjectChannelInviteApiFp(this.configuration).siteProjectChannelInviteControllerDeclineForSecret1(v, language, projectId, channelId, secret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Del channel invite item for my channel for another user
     * @param {SiteProjectChannelInviteControllerDel1VEnum} v Version
     * @param {SiteProjectChannelInviteControllerDel1LanguageEnum} language Current language
     * @param {number} id Unique id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    public siteProjectChannelInviteControllerDel1(v: SiteProjectChannelInviteControllerDel1VEnum, language: SiteProjectChannelInviteControllerDel1LanguageEnum, id: number, options?: RawAxiosRequestConfig) {
        return ProjectChannelInviteApiFp(this.configuration).siteProjectChannelInviteControllerDel1(v, language, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get channel invite item for my channel for another user
     * @param {SiteProjectChannelInviteControllerGet1VEnum} v Version
     * @param {SiteProjectChannelInviteControllerGet1LanguageEnum} language Current language
     * @param {number} id Channel request id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    public siteProjectChannelInviteControllerGet1(v: SiteProjectChannelInviteControllerGet1VEnum, language: SiteProjectChannelInviteControllerGet1LanguageEnum, id: number, options?: RawAxiosRequestConfig) {
        return ProjectChannelInviteApiFp(this.configuration).siteProjectChannelInviteControllerGet1(v, language, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get invitation for channel
     * @param {SiteProjectChannelInviteControllerGetForProject1VEnum} v Version
     * @param {SiteProjectChannelInviteControllerGetForProject1LanguageEnum} language Current language
     * @param {number} projectId Current project id
     * @param {number} channelId Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    public siteProjectChannelInviteControllerGetForProject1(v: SiteProjectChannelInviteControllerGetForProject1VEnum, language: SiteProjectChannelInviteControllerGetForProject1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig) {
        return ProjectChannelInviteApiFp(this.configuration).siteProjectChannelInviteControllerGetForProject1(v, language, projectId, channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get channel invitation using a secret link
     * @param {SiteProjectChannelInviteControllerGetForSecret1VEnum} v Version
     * @param {SiteProjectChannelInviteControllerGetForSecret1LanguageEnum} language Current language
     * @param {number} channelId Channel id
     * @param {string} secret Secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    public siteProjectChannelInviteControllerGetForSecret1(v: SiteProjectChannelInviteControllerGetForSecret1VEnum, language: SiteProjectChannelInviteControllerGetForSecret1LanguageEnum, channelId: number, secret: string, options?: RawAxiosRequestConfig) {
        return ProjectChannelInviteApiFp(this.configuration).siteProjectChannelInviteControllerGetForSecret1(v, language, channelId, secret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of invites for channel in project
     * @param {SiteProjectChannelInviteControllerList1VEnum} v Version
     * @param {SiteProjectChannelInviteControllerList1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} channelId Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    public siteProjectChannelInviteControllerList1(v: SiteProjectChannelInviteControllerList1VEnum, language: SiteProjectChannelInviteControllerList1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig) {
        return ProjectChannelInviteApiFp(this.configuration).siteProjectChannelInviteControllerList1(v, language, projectId, channelId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SiteProjectChannelInviteControllerAcceptForProject1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteProjectChannelInviteControllerAcceptForProject1VEnum = typeof SiteProjectChannelInviteControllerAcceptForProject1VEnum[keyof typeof SiteProjectChannelInviteControllerAcceptForProject1VEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerAcceptForProject1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteProjectChannelInviteControllerAcceptForProject1LanguageEnum = typeof SiteProjectChannelInviteControllerAcceptForProject1LanguageEnum[keyof typeof SiteProjectChannelInviteControllerAcceptForProject1LanguageEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerAcceptForSecret1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteProjectChannelInviteControllerAcceptForSecret1VEnum = typeof SiteProjectChannelInviteControllerAcceptForSecret1VEnum[keyof typeof SiteProjectChannelInviteControllerAcceptForSecret1VEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerAcceptForSecret1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteProjectChannelInviteControllerAcceptForSecret1LanguageEnum = typeof SiteProjectChannelInviteControllerAcceptForSecret1LanguageEnum[keyof typeof SiteProjectChannelInviteControllerAcceptForSecret1LanguageEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerAddByEmail1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteProjectChannelInviteControllerAddByEmail1VEnum = typeof SiteProjectChannelInviteControllerAddByEmail1VEnum[keyof typeof SiteProjectChannelInviteControllerAddByEmail1VEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerAddByEmail1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteProjectChannelInviteControllerAddByEmail1LanguageEnum = typeof SiteProjectChannelInviteControllerAddByEmail1LanguageEnum[keyof typeof SiteProjectChannelInviteControllerAddByEmail1LanguageEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerAddByEmail1AccessTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_12: 1,
    NUMBER_2: 2
} as const;
export type SiteProjectChannelInviteControllerAddByEmail1AccessTypeEnum = typeof SiteProjectChannelInviteControllerAddByEmail1AccessTypeEnum[keyof typeof SiteProjectChannelInviteControllerAddByEmail1AccessTypeEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerAddById1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteProjectChannelInviteControllerAddById1VEnum = typeof SiteProjectChannelInviteControllerAddById1VEnum[keyof typeof SiteProjectChannelInviteControllerAddById1VEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerAddById1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteProjectChannelInviteControllerAddById1LanguageEnum = typeof SiteProjectChannelInviteControllerAddById1LanguageEnum[keyof typeof SiteProjectChannelInviteControllerAddById1LanguageEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerAddById1AccessTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_12: 1,
    NUMBER_2: 2
} as const;
export type SiteProjectChannelInviteControllerAddById1AccessTypeEnum = typeof SiteProjectChannelInviteControllerAddById1AccessTypeEnum[keyof typeof SiteProjectChannelInviteControllerAddById1AccessTypeEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerDeclineForProject1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteProjectChannelInviteControllerDeclineForProject1VEnum = typeof SiteProjectChannelInviteControllerDeclineForProject1VEnum[keyof typeof SiteProjectChannelInviteControllerDeclineForProject1VEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerDeclineForProject1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteProjectChannelInviteControllerDeclineForProject1LanguageEnum = typeof SiteProjectChannelInviteControllerDeclineForProject1LanguageEnum[keyof typeof SiteProjectChannelInviteControllerDeclineForProject1LanguageEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerDeclineForSecret1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteProjectChannelInviteControllerDeclineForSecret1VEnum = typeof SiteProjectChannelInviteControllerDeclineForSecret1VEnum[keyof typeof SiteProjectChannelInviteControllerDeclineForSecret1VEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerDeclineForSecret1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteProjectChannelInviteControllerDeclineForSecret1LanguageEnum = typeof SiteProjectChannelInviteControllerDeclineForSecret1LanguageEnum[keyof typeof SiteProjectChannelInviteControllerDeclineForSecret1LanguageEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerDel1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteProjectChannelInviteControllerDel1VEnum = typeof SiteProjectChannelInviteControllerDel1VEnum[keyof typeof SiteProjectChannelInviteControllerDel1VEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerDel1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteProjectChannelInviteControllerDel1LanguageEnum = typeof SiteProjectChannelInviteControllerDel1LanguageEnum[keyof typeof SiteProjectChannelInviteControllerDel1LanguageEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerGet1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteProjectChannelInviteControllerGet1VEnum = typeof SiteProjectChannelInviteControllerGet1VEnum[keyof typeof SiteProjectChannelInviteControllerGet1VEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerGet1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteProjectChannelInviteControllerGet1LanguageEnum = typeof SiteProjectChannelInviteControllerGet1LanguageEnum[keyof typeof SiteProjectChannelInviteControllerGet1LanguageEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerGetForProject1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteProjectChannelInviteControllerGetForProject1VEnum = typeof SiteProjectChannelInviteControllerGetForProject1VEnum[keyof typeof SiteProjectChannelInviteControllerGetForProject1VEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerGetForProject1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteProjectChannelInviteControllerGetForProject1LanguageEnum = typeof SiteProjectChannelInviteControllerGetForProject1LanguageEnum[keyof typeof SiteProjectChannelInviteControllerGetForProject1LanguageEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerGetForSecret1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteProjectChannelInviteControllerGetForSecret1VEnum = typeof SiteProjectChannelInviteControllerGetForSecret1VEnum[keyof typeof SiteProjectChannelInviteControllerGetForSecret1VEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerGetForSecret1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteProjectChannelInviteControllerGetForSecret1LanguageEnum = typeof SiteProjectChannelInviteControllerGetForSecret1LanguageEnum[keyof typeof SiteProjectChannelInviteControllerGetForSecret1LanguageEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerList1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteProjectChannelInviteControllerList1VEnum = typeof SiteProjectChannelInviteControllerList1VEnum[keyof typeof SiteProjectChannelInviteControllerList1VEnum];
/**
 * @export
 */
export const SiteProjectChannelInviteControllerList1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteProjectChannelInviteControllerList1LanguageEnum = typeof SiteProjectChannelInviteControllerList1LanguageEnum[keyof typeof SiteProjectChannelInviteControllerList1LanguageEnum];


/**
 * ProjectHistoryApi - axios parameter creator
 * @export
 */
export const ProjectHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get project history of actions
         * @param {SiteProjectHistoryControllerList1VEnum} v Version
         * @param {SiteProjectHistoryControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {string} [dateFrom] Date from
         * @param {string} [dateTo] Date to
         * @param {SiteProjectHistoryControllerList1ActionEnum} [action] Action
         * @param {number} [groupId] Group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectHistoryControllerList1: async (v: SiteProjectHistoryControllerList1VEnum, language: SiteProjectHistoryControllerList1LanguageEnum, projectId: number, limit?: number, offset?: number, dateFrom?: string, dateTo?: string, action?: SiteProjectHistoryControllerList1ActionEnum, groupId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteProjectHistoryControllerList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteProjectHistoryControllerList1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteProjectHistoryControllerList1', 'projectId', projectId)
            const localVarPath = `/method/project_history/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString() :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString() :
                    dateTo;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectHistoryApi - functional programming interface
 * @export
 */
export const ProjectHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get project history of actions
         * @param {SiteProjectHistoryControllerList1VEnum} v Version
         * @param {SiteProjectHistoryControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {string} [dateFrom] Date from
         * @param {string} [dateTo] Date to
         * @param {SiteProjectHistoryControllerList1ActionEnum} [action] Action
         * @param {number} [groupId] Group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteProjectHistoryControllerList1(v: SiteProjectHistoryControllerList1VEnum, language: SiteProjectHistoryControllerList1LanguageEnum, projectId: number, limit?: number, offset?: number, dateFrom?: string, dateTo?: string, action?: SiteProjectHistoryControllerList1ActionEnum, groupId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseOfProjectHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteProjectHistoryControllerList1(v, language, projectId, limit, offset, dateFrom, dateTo, action, groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectHistoryApi.siteProjectHistoryControllerList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectHistoryApi - factory interface
 * @export
 */
export const ProjectHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectHistoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Get project history of actions
         * @param {SiteProjectHistoryControllerList1VEnum} v Version
         * @param {SiteProjectHistoryControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {string} [dateFrom] Date from
         * @param {string} [dateTo] Date to
         * @param {SiteProjectHistoryControllerList1ActionEnum} [action] Action
         * @param {number} [groupId] Group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteProjectHistoryControllerList1(v: SiteProjectHistoryControllerList1VEnum, language: SiteProjectHistoryControllerList1LanguageEnum, projectId: number, limit?: number, offset?: number, dateFrom?: string, dateTo?: string, action?: SiteProjectHistoryControllerList1ActionEnum, groupId?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseOfProjectHistoryResponse> {
            return localVarFp.siteProjectHistoryControllerList1(v, language, projectId, limit, offset, dateFrom, dateTo, action, groupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectHistoryApi - object-oriented interface
 * @export
 * @class ProjectHistoryApi
 * @extends {BaseAPI}
 */
export class ProjectHistoryApi extends BaseAPI {
    /**
     * 
     * @summary Get project history of actions
     * @param {SiteProjectHistoryControllerList1VEnum} v Version
     * @param {SiteProjectHistoryControllerList1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} [limit] Number of results
     * @param {number} [offset] Page offset number
     * @param {string} [dateFrom] Date from
     * @param {string} [dateTo] Date to
     * @param {SiteProjectHistoryControllerList1ActionEnum} [action] Action
     * @param {number} [groupId] Group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectHistoryApi
     */
    public siteProjectHistoryControllerList1(v: SiteProjectHistoryControllerList1VEnum, language: SiteProjectHistoryControllerList1LanguageEnum, projectId: number, limit?: number, offset?: number, dateFrom?: string, dateTo?: string, action?: SiteProjectHistoryControllerList1ActionEnum, groupId?: number, options?: RawAxiosRequestConfig) {
        return ProjectHistoryApiFp(this.configuration).siteProjectHistoryControllerList1(v, language, projectId, limit, offset, dateFrom, dateTo, action, groupId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SiteProjectHistoryControllerList1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteProjectHistoryControllerList1VEnum = typeof SiteProjectHistoryControllerList1VEnum[keyof typeof SiteProjectHistoryControllerList1VEnum];
/**
 * @export
 */
export const SiteProjectHistoryControllerList1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteProjectHistoryControllerList1LanguageEnum = typeof SiteProjectHistoryControllerList1LanguageEnum[keyof typeof SiteProjectHistoryControllerList1LanguageEnum];
/**
 * @export
 */
export const SiteProjectHistoryControllerList1ActionEnum = {
    ProjectChannelInviteAdd: 'project_channel_invite_add',
    ProjectChannelInviteDel: 'project_channel_invite_del',
    ProjectChannelInviteAccept: 'project_channel_invite_accept',
    ProjectChannelInviteDecline: 'project_channel_invite_decline',
    UserProjectInviteAdd: 'user_project_invite_add',
    UserProjectInviteDel: 'user_project_invite_del',
    UserProjectInviteAccept: 'user_project_invite_accept',
    UserProjectInviteDecline: 'user_project_invite_decline',
    UserProjectAdd: 'user_project_add',
    UserProjectDel: 'user_project_del',
    UserProjectChange: 'user_project_change',
    ProjectChannelAdd: 'project_channel_add',
    ProjectChannelDel: 'project_channel_del',
    ProjectChannelChange: 'project_channel_change'
} as const;
export type SiteProjectHistoryControllerList1ActionEnum = typeof SiteProjectHistoryControllerList1ActionEnum[keyof typeof SiteProjectHistoryControllerList1ActionEnum];


/**
 * PromoApi - axios parameter creator
 * @export
 */
export const PromoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply code
         * @param {PromoControllerApply1VEnum} v Version
         * @param {PromoControllerApply1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} code Code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoControllerApply1: async (v: PromoControllerApply1VEnum, language: PromoControllerApply1LanguageEnum, projectId: number, code: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('promoControllerApply1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('promoControllerApply1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promoControllerApply1', 'projectId', projectId)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('promoControllerApply1', 'code', code)
            const localVarPath = `/method/promo/apply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check code
         * @param {PromoControllerCheck1VEnum} v Version
         * @param {PromoControllerCheck1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} code Code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoControllerCheck1: async (v: PromoControllerCheck1VEnum, language: PromoControllerCheck1LanguageEnum, projectId: number, code: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('promoControllerCheck1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('promoControllerCheck1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promoControllerCheck1', 'projectId', projectId)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('promoControllerCheck1', 'code', code)
            const localVarPath = `/method/promo/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromoApi - functional programming interface
 * @export
 */
export const PromoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Apply code
         * @param {PromoControllerApply1VEnum} v Version
         * @param {PromoControllerApply1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} code Code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoControllerApply1(v: PromoControllerApply1VEnum, language: PromoControllerApply1LanguageEnum, projectId: number, code: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SitePromoApplyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoControllerApply1(v, language, projectId, code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromoApi.promoControllerApply1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check code
         * @param {PromoControllerCheck1VEnum} v Version
         * @param {PromoControllerCheck1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} code Code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoControllerCheck1(v: PromoControllerCheck1VEnum, language: PromoControllerCheck1LanguageEnum, projectId: number, code: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SitePromoCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoControllerCheck1(v, language, projectId, code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromoApi.promoControllerCheck1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromoApi - factory interface
 * @export
 */
export const PromoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromoApiFp(configuration)
    return {
        /**
         * 
         * @summary Apply code
         * @param {PromoControllerApply1VEnum} v Version
         * @param {PromoControllerApply1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} code Code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoControllerApply1(v: PromoControllerApply1VEnum, language: PromoControllerApply1LanguageEnum, projectId: number, code: number, options?: RawAxiosRequestConfig): AxiosPromise<SitePromoApplyResponse> {
            return localVarFp.promoControllerApply1(v, language, projectId, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check code
         * @param {PromoControllerCheck1VEnum} v Version
         * @param {PromoControllerCheck1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} code Code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoControllerCheck1(v: PromoControllerCheck1VEnum, language: PromoControllerCheck1LanguageEnum, projectId: number, code: number, options?: RawAxiosRequestConfig): AxiosPromise<SitePromoCheckResponse> {
            return localVarFp.promoControllerCheck1(v, language, projectId, code, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromoApi - object-oriented interface
 * @export
 * @class PromoApi
 * @extends {BaseAPI}
 */
export class PromoApi extends BaseAPI {
    /**
     * 
     * @summary Apply code
     * @param {PromoControllerApply1VEnum} v Version
     * @param {PromoControllerApply1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} code Code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromoApi
     */
    public promoControllerApply1(v: PromoControllerApply1VEnum, language: PromoControllerApply1LanguageEnum, projectId: number, code: number, options?: RawAxiosRequestConfig) {
        return PromoApiFp(this.configuration).promoControllerApply1(v, language, projectId, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check code
     * @param {PromoControllerCheck1VEnum} v Version
     * @param {PromoControllerCheck1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} code Code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromoApi
     */
    public promoControllerCheck1(v: PromoControllerCheck1VEnum, language: PromoControllerCheck1LanguageEnum, projectId: number, code: number, options?: RawAxiosRequestConfig) {
        return PromoApiFp(this.configuration).promoControllerCheck1(v, language, projectId, code, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PromoControllerApply1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type PromoControllerApply1VEnum = typeof PromoControllerApply1VEnum[keyof typeof PromoControllerApply1VEnum];
/**
 * @export
 */
export const PromoControllerApply1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type PromoControllerApply1LanguageEnum = typeof PromoControllerApply1LanguageEnum[keyof typeof PromoControllerApply1LanguageEnum];
/**
 * @export
 */
export const PromoControllerCheck1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type PromoControllerCheck1VEnum = typeof PromoControllerCheck1VEnum[keyof typeof PromoControllerCheck1VEnum];
/**
 * @export
 */
export const PromoControllerCheck1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type PromoControllerCheck1LanguageEnum = typeof PromoControllerCheck1LanguageEnum[keyof typeof PromoControllerCheck1LanguageEnum];


/**
 * PullServersApi - axios parameter creator
 * @export
 */
export const PullServersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get pull servers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullServersControllerGetPullServers1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/method/pull-servers/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PullServersApi - functional programming interface
 * @export
 */
export const PullServersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PullServersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get pull servers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pullServersControllerGetPullServers1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullServerListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pullServersControllerGetPullServers1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullServersApi.pullServersControllerGetPullServers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PullServersApi - factory interface
 * @export
 */
export const PullServersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PullServersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get pull servers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullServersControllerGetPullServers1(options?: RawAxiosRequestConfig): AxiosPromise<PullServerListResponse> {
            return localVarFp.pullServersControllerGetPullServers1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PullServersApi - object-oriented interface
 * @export
 * @class PullServersApi
 * @extends {BaseAPI}
 */
export class PullServersApi extends BaseAPI {
    /**
     * 
     * @summary Get pull servers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullServersApi
     */
    public pullServersControllerGetPullServers1(options?: RawAxiosRequestConfig) {
        return PullServersApiFp(this.configuration).pullServersControllerGetPullServers1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReferralsApi - axios parameter creator
 * @export
 */
export const ReferralsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Total info
         * @param {SiteReferralsControllerTotalInfo1VEnum} v Version
         * @param {SiteReferralsControllerTotalInfo1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteReferralsControllerTotalInfo1: async (v: SiteReferralsControllerTotalInfo1VEnum, language: SiteReferralsControllerTotalInfo1LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteReferralsControllerTotalInfo1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteReferralsControllerTotalInfo1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteReferralsControllerTotalInfo1', 'projectId', projectId)
            const localVarPath = `/method/referrals/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferralsApi - functional programming interface
 * @export
 */
export const ReferralsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferralsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Total info
         * @param {SiteReferralsControllerTotalInfo1VEnum} v Version
         * @param {SiteReferralsControllerTotalInfo1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteReferralsControllerTotalInfo1(v: SiteReferralsControllerTotalInfo1VEnum, language: SiteReferralsControllerTotalInfo1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteTotalInfoReferralsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteReferralsControllerTotalInfo1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralsApi.siteReferralsControllerTotalInfo1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReferralsApi - factory interface
 * @export
 */
export const ReferralsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferralsApiFp(configuration)
    return {
        /**
         * 
         * @summary Total info
         * @param {SiteReferralsControllerTotalInfo1VEnum} v Version
         * @param {SiteReferralsControllerTotalInfo1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteReferralsControllerTotalInfo1(v: SiteReferralsControllerTotalInfo1VEnum, language: SiteReferralsControllerTotalInfo1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<SiteTotalInfoReferralsResponse> {
            return localVarFp.siteReferralsControllerTotalInfo1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferralsApi - object-oriented interface
 * @export
 * @class ReferralsApi
 * @extends {BaseAPI}
 */
export class ReferralsApi extends BaseAPI {
    /**
     * 
     * @summary Total info
     * @param {SiteReferralsControllerTotalInfo1VEnum} v Version
     * @param {SiteReferralsControllerTotalInfo1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public siteReferralsControllerTotalInfo1(v: SiteReferralsControllerTotalInfo1VEnum, language: SiteReferralsControllerTotalInfo1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).siteReferralsControllerTotalInfo1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SiteReferralsControllerTotalInfo1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteReferralsControllerTotalInfo1VEnum = typeof SiteReferralsControllerTotalInfo1VEnum[keyof typeof SiteReferralsControllerTotalInfo1VEnum];
/**
 * @export
 */
export const SiteReferralsControllerTotalInfo1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteReferralsControllerTotalInfo1LanguageEnum = typeof SiteReferralsControllerTotalInfo1LanguageEnum[keyof typeof SiteReferralsControllerTotalInfo1LanguageEnum];


/**
 * ReleaseApi - axios parameter creator
 * @export
 */
export const ReleaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current version app
         * @param {SiteReleaseAppControllerCabinet1VEnum} v Version
         * @param {SiteReleaseAppControllerCabinet1LanguageEnum} language Current language
         * @param {SiteReleaseAppControllerCabinet1AppEnum} [app] Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteReleaseAppControllerCabinet1: async (v: SiteReleaseAppControllerCabinet1VEnum, language: SiteReleaseAppControllerCabinet1LanguageEnum, app?: SiteReleaseAppControllerCabinet1AppEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteReleaseAppControllerCabinet1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteReleaseAppControllerCabinet1', 'language', language)
            const localVarPath = `/method/release-app`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReleaseApi - functional programming interface
 * @export
 */
export const ReleaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReleaseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current version app
         * @param {SiteReleaseAppControllerCabinet1VEnum} v Version
         * @param {SiteReleaseAppControllerCabinet1LanguageEnum} language Current language
         * @param {SiteReleaseAppControllerCabinet1AppEnum} [app] Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteReleaseAppControllerCabinet1(v: SiteReleaseAppControllerCabinet1VEnum, language: SiteReleaseAppControllerCabinet1LanguageEnum, app?: SiteReleaseAppControllerCabinet1AppEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVersionAppResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteReleaseAppControllerCabinet1(v, language, app, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReleaseApi.siteReleaseAppControllerCabinet1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReleaseApi - factory interface
 * @export
 */
export const ReleaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReleaseApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current version app
         * @param {SiteReleaseAppControllerCabinet1VEnum} v Version
         * @param {SiteReleaseAppControllerCabinet1LanguageEnum} language Current language
         * @param {SiteReleaseAppControllerCabinet1AppEnum} [app] Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteReleaseAppControllerCabinet1(v: SiteReleaseAppControllerCabinet1VEnum, language: SiteReleaseAppControllerCabinet1LanguageEnum, app?: SiteReleaseAppControllerCabinet1AppEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetVersionAppResponse> {
            return localVarFp.siteReleaseAppControllerCabinet1(v, language, app, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReleaseApi - object-oriented interface
 * @export
 * @class ReleaseApi
 * @extends {BaseAPI}
 */
export class ReleaseApi extends BaseAPI {
    /**
     * 
     * @summary Get current version app
     * @param {SiteReleaseAppControllerCabinet1VEnum} v Version
     * @param {SiteReleaseAppControllerCabinet1LanguageEnum} language Current language
     * @param {SiteReleaseAppControllerCabinet1AppEnum} [app] Apps
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleaseApi
     */
    public siteReleaseAppControllerCabinet1(v: SiteReleaseAppControllerCabinet1VEnum, language: SiteReleaseAppControllerCabinet1LanguageEnum, app?: SiteReleaseAppControllerCabinet1AppEnum, options?: RawAxiosRequestConfig) {
        return ReleaseApiFp(this.configuration).siteReleaseAppControllerCabinet1(v, language, app, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SiteReleaseAppControllerCabinet1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteReleaseAppControllerCabinet1VEnum = typeof SiteReleaseAppControllerCabinet1VEnum[keyof typeof SiteReleaseAppControllerCabinet1VEnum];
/**
 * @export
 */
export const SiteReleaseAppControllerCabinet1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteReleaseAppControllerCabinet1LanguageEnum = typeof SiteReleaseAppControllerCabinet1LanguageEnum[keyof typeof SiteReleaseAppControllerCabinet1LanguageEnum];
/**
 * @export
 */
export const SiteReleaseAppControllerCabinet1AppEnum = {
    Cabinet: 'cabinet'
} as const;
export type SiteReleaseAppControllerCabinet1AppEnum = typeof SiteReleaseAppControllerCabinet1AppEnum[keyof typeof SiteReleaseAppControllerCabinet1AppEnum];


/**
 * RtmpServerApi - axios parameter creator
 * @export
 */
export const RtmpServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Rtmp locations server list example for unauthorized
         * @param {MethodRtmpServerControllerListLocationsUnauthorizedVEnum} v Version
         * @param {MethodRtmpServerControllerListLocationsUnauthorizedLanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodRtmpServerControllerListLocationsUnauthorized: async (v: MethodRtmpServerControllerListLocationsUnauthorizedVEnum, language: MethodRtmpServerControllerListLocationsUnauthorizedLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('methodRtmpServerControllerListLocationsUnauthorized', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('methodRtmpServerControllerListLocationsUnauthorized', 'language', language)
            const localVarPath = `/method/rtmp_server/list_locations_unauthorized`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Graph of rtmp servers
         * @param {SiteRtmpServerControllerGraph1VEnum} v Version
         * @param {SiteRtmpServerControllerGraph1LanguageEnum} language Current language
         * @param {SiteRtmpServerControllerGraph1IntervalEnum} interval Interval state in hours
         * @param {SiteRtmpServerControllerGraph1TypeEnum} type Type graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteRtmpServerControllerGraph1: async (v: SiteRtmpServerControllerGraph1VEnum, language: SiteRtmpServerControllerGraph1LanguageEnum, interval: SiteRtmpServerControllerGraph1IntervalEnum, type: SiteRtmpServerControllerGraph1TypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteRtmpServerControllerGraph1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteRtmpServerControllerGraph1', 'language', language)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('siteRtmpServerControllerGraph1', 'interval', interval)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('siteRtmpServerControllerGraph1', 'type', type)
            const localVarPath = `/method/rtmp_server/graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List rtmp servers
         * @param {SiteRtmpServerControllerList1VEnum} v Version
         * @param {SiteRtmpServerControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {SiteRtmpServerControllerList1IntervalEnum} interval Interval state in hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteRtmpServerControllerList1: async (v: SiteRtmpServerControllerList1VEnum, language: SiteRtmpServerControllerList1LanguageEnum, projectId: number, interval: SiteRtmpServerControllerList1IntervalEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteRtmpServerControllerList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteRtmpServerControllerList1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteRtmpServerControllerList1', 'projectId', projectId)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('siteRtmpServerControllerList1', 'interval', interval)
            const localVarPath = `/method/rtmp_server/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary State of rtmp servers
         * @param {SiteRtmpServerControllerState1VEnum} v Version
         * @param {SiteRtmpServerControllerState1LanguageEnum} language Current language
         * @param {SiteRtmpServerControllerState1IntervalEnum} interval Interval state in hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteRtmpServerControllerState1: async (v: SiteRtmpServerControllerState1VEnum, language: SiteRtmpServerControllerState1LanguageEnum, interval: SiteRtmpServerControllerState1IntervalEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteRtmpServerControllerState1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteRtmpServerControllerState1', 'language', language)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('siteRtmpServerControllerState1', 'interval', interval)
            const localVarPath = `/method/rtmp_server/state`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary State of rtmp servers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteRtmpServerControllerUp1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/method/rtmp_server/up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RtmpServerApi - functional programming interface
 * @export
 */
export const RtmpServerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RtmpServerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Rtmp locations server list example for unauthorized
         * @param {MethodRtmpServerControllerListLocationsUnauthorizedVEnum} v Version
         * @param {MethodRtmpServerControllerListLocationsUnauthorizedLanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async methodRtmpServerControllerListLocationsUnauthorized(v: MethodRtmpServerControllerListLocationsUnauthorizedVEnum, language: MethodRtmpServerControllerListLocationsUnauthorizedLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOfRtmpServerLocationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.methodRtmpServerControllerListLocationsUnauthorized(v, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RtmpServerApi.methodRtmpServerControllerListLocationsUnauthorized']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Graph of rtmp servers
         * @param {SiteRtmpServerControllerGraph1VEnum} v Version
         * @param {SiteRtmpServerControllerGraph1LanguageEnum} language Current language
         * @param {SiteRtmpServerControllerGraph1IntervalEnum} interval Interval state in hours
         * @param {SiteRtmpServerControllerGraph1TypeEnum} type Type graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteRtmpServerControllerGraph1(v: SiteRtmpServerControllerGraph1VEnum, language: SiteRtmpServerControllerGraph1LanguageEnum, interval: SiteRtmpServerControllerGraph1IntervalEnum, type: SiteRtmpServerControllerGraph1TypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RtmpServerGraphResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteRtmpServerControllerGraph1(v, language, interval, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RtmpServerApi.siteRtmpServerControllerGraph1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List rtmp servers
         * @param {SiteRtmpServerControllerList1VEnum} v Version
         * @param {SiteRtmpServerControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {SiteRtmpServerControllerList1IntervalEnum} interval Interval state in hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteRtmpServerControllerList1(v: SiteRtmpServerControllerList1VEnum, language: SiteRtmpServerControllerList1LanguageEnum, projectId: number, interval: SiteRtmpServerControllerList1IntervalEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RtmpServerListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteRtmpServerControllerList1(v, language, projectId, interval, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RtmpServerApi.siteRtmpServerControllerList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary State of rtmp servers
         * @param {SiteRtmpServerControllerState1VEnum} v Version
         * @param {SiteRtmpServerControllerState1LanguageEnum} language Current language
         * @param {SiteRtmpServerControllerState1IntervalEnum} interval Interval state in hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteRtmpServerControllerState1(v: SiteRtmpServerControllerState1VEnum, language: SiteRtmpServerControllerState1LanguageEnum, interval: SiteRtmpServerControllerState1IntervalEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RtmpServerStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteRtmpServerControllerState1(v, language, interval, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RtmpServerApi.siteRtmpServerControllerState1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary State of rtmp servers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteRtmpServerControllerUp1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteRtmpServerControllerUp1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RtmpServerApi.siteRtmpServerControllerUp1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RtmpServerApi - factory interface
 * @export
 */
export const RtmpServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RtmpServerApiFp(configuration)
    return {
        /**
         * 
         * @summary Rtmp locations server list example for unauthorized
         * @param {MethodRtmpServerControllerListLocationsUnauthorizedVEnum} v Version
         * @param {MethodRtmpServerControllerListLocationsUnauthorizedLanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        methodRtmpServerControllerListLocationsUnauthorized(v: MethodRtmpServerControllerListLocationsUnauthorizedVEnum, language: MethodRtmpServerControllerListLocationsUnauthorizedLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListOfRtmpServerLocationResponse> {
            return localVarFp.methodRtmpServerControllerListLocationsUnauthorized(v, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Graph of rtmp servers
         * @param {SiteRtmpServerControllerGraph1VEnum} v Version
         * @param {SiteRtmpServerControllerGraph1LanguageEnum} language Current language
         * @param {SiteRtmpServerControllerGraph1IntervalEnum} interval Interval state in hours
         * @param {SiteRtmpServerControllerGraph1TypeEnum} type Type graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteRtmpServerControllerGraph1(v: SiteRtmpServerControllerGraph1VEnum, language: SiteRtmpServerControllerGraph1LanguageEnum, interval: SiteRtmpServerControllerGraph1IntervalEnum, type: SiteRtmpServerControllerGraph1TypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<RtmpServerGraphResponse> {
            return localVarFp.siteRtmpServerControllerGraph1(v, language, interval, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List rtmp servers
         * @param {SiteRtmpServerControllerList1VEnum} v Version
         * @param {SiteRtmpServerControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {SiteRtmpServerControllerList1IntervalEnum} interval Interval state in hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteRtmpServerControllerList1(v: SiteRtmpServerControllerList1VEnum, language: SiteRtmpServerControllerList1LanguageEnum, projectId: number, interval: SiteRtmpServerControllerList1IntervalEnum, options?: RawAxiosRequestConfig): AxiosPromise<RtmpServerListResponse> {
            return localVarFp.siteRtmpServerControllerList1(v, language, projectId, interval, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary State of rtmp servers
         * @param {SiteRtmpServerControllerState1VEnum} v Version
         * @param {SiteRtmpServerControllerState1LanguageEnum} language Current language
         * @param {SiteRtmpServerControllerState1IntervalEnum} interval Interval state in hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteRtmpServerControllerState1(v: SiteRtmpServerControllerState1VEnum, language: SiteRtmpServerControllerState1LanguageEnum, interval: SiteRtmpServerControllerState1IntervalEnum, options?: RawAxiosRequestConfig): AxiosPromise<RtmpServerStateResponse> {
            return localVarFp.siteRtmpServerControllerState1(v, language, interval, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary State of rtmp servers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteRtmpServerControllerUp1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.siteRtmpServerControllerUp1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RtmpServerApi - object-oriented interface
 * @export
 * @class RtmpServerApi
 * @extends {BaseAPI}
 */
export class RtmpServerApi extends BaseAPI {
    /**
     * 
     * @summary Rtmp locations server list example for unauthorized
     * @param {MethodRtmpServerControllerListLocationsUnauthorizedVEnum} v Version
     * @param {MethodRtmpServerControllerListLocationsUnauthorizedLanguageEnum} language Current language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RtmpServerApi
     */
    public methodRtmpServerControllerListLocationsUnauthorized(v: MethodRtmpServerControllerListLocationsUnauthorizedVEnum, language: MethodRtmpServerControllerListLocationsUnauthorizedLanguageEnum, options?: RawAxiosRequestConfig) {
        return RtmpServerApiFp(this.configuration).methodRtmpServerControllerListLocationsUnauthorized(v, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Graph of rtmp servers
     * @param {SiteRtmpServerControllerGraph1VEnum} v Version
     * @param {SiteRtmpServerControllerGraph1LanguageEnum} language Current language
     * @param {SiteRtmpServerControllerGraph1IntervalEnum} interval Interval state in hours
     * @param {SiteRtmpServerControllerGraph1TypeEnum} type Type graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RtmpServerApi
     */
    public siteRtmpServerControllerGraph1(v: SiteRtmpServerControllerGraph1VEnum, language: SiteRtmpServerControllerGraph1LanguageEnum, interval: SiteRtmpServerControllerGraph1IntervalEnum, type: SiteRtmpServerControllerGraph1TypeEnum, options?: RawAxiosRequestConfig) {
        return RtmpServerApiFp(this.configuration).siteRtmpServerControllerGraph1(v, language, interval, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List rtmp servers
     * @param {SiteRtmpServerControllerList1VEnum} v Version
     * @param {SiteRtmpServerControllerList1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {SiteRtmpServerControllerList1IntervalEnum} interval Interval state in hours
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RtmpServerApi
     */
    public siteRtmpServerControllerList1(v: SiteRtmpServerControllerList1VEnum, language: SiteRtmpServerControllerList1LanguageEnum, projectId: number, interval: SiteRtmpServerControllerList1IntervalEnum, options?: RawAxiosRequestConfig) {
        return RtmpServerApiFp(this.configuration).siteRtmpServerControllerList1(v, language, projectId, interval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary State of rtmp servers
     * @param {SiteRtmpServerControllerState1VEnum} v Version
     * @param {SiteRtmpServerControllerState1LanguageEnum} language Current language
     * @param {SiteRtmpServerControllerState1IntervalEnum} interval Interval state in hours
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RtmpServerApi
     */
    public siteRtmpServerControllerState1(v: SiteRtmpServerControllerState1VEnum, language: SiteRtmpServerControllerState1LanguageEnum, interval: SiteRtmpServerControllerState1IntervalEnum, options?: RawAxiosRequestConfig) {
        return RtmpServerApiFp(this.configuration).siteRtmpServerControllerState1(v, language, interval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary State of rtmp servers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RtmpServerApi
     */
    public siteRtmpServerControllerUp1(options?: RawAxiosRequestConfig) {
        return RtmpServerApiFp(this.configuration).siteRtmpServerControllerUp1(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MethodRtmpServerControllerListLocationsUnauthorizedVEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type MethodRtmpServerControllerListLocationsUnauthorizedVEnum = typeof MethodRtmpServerControllerListLocationsUnauthorizedVEnum[keyof typeof MethodRtmpServerControllerListLocationsUnauthorizedVEnum];
/**
 * @export
 */
export const MethodRtmpServerControllerListLocationsUnauthorizedLanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type MethodRtmpServerControllerListLocationsUnauthorizedLanguageEnum = typeof MethodRtmpServerControllerListLocationsUnauthorizedLanguageEnum[keyof typeof MethodRtmpServerControllerListLocationsUnauthorizedLanguageEnum];
/**
 * @export
 */
export const SiteRtmpServerControllerGraph1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteRtmpServerControllerGraph1VEnum = typeof SiteRtmpServerControllerGraph1VEnum[keyof typeof SiteRtmpServerControllerGraph1VEnum];
/**
 * @export
 */
export const SiteRtmpServerControllerGraph1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteRtmpServerControllerGraph1LanguageEnum = typeof SiteRtmpServerControllerGraph1LanguageEnum[keyof typeof SiteRtmpServerControllerGraph1LanguageEnum];
/**
 * @export
 */
export const SiteRtmpServerControllerGraph1IntervalEnum = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_6: 6,
    NUMBER_12: 12,
    NUMBER_24: 24
} as const;
export type SiteRtmpServerControllerGraph1IntervalEnum = typeof SiteRtmpServerControllerGraph1IntervalEnum[keyof typeof SiteRtmpServerControllerGraph1IntervalEnum];
/**
 * @export
 */
export const SiteRtmpServerControllerGraph1TypeEnum = {
    Performance: 'performance',
    Network: 'network',
    Cpu: 'cpu',
    Ram: 'ram',
    DeliveredPackages: 'deliveredPackages'
} as const;
export type SiteRtmpServerControllerGraph1TypeEnum = typeof SiteRtmpServerControllerGraph1TypeEnum[keyof typeof SiteRtmpServerControllerGraph1TypeEnum];
/**
 * @export
 */
export const SiteRtmpServerControllerList1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteRtmpServerControllerList1VEnum = typeof SiteRtmpServerControllerList1VEnum[keyof typeof SiteRtmpServerControllerList1VEnum];
/**
 * @export
 */
export const SiteRtmpServerControllerList1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteRtmpServerControllerList1LanguageEnum = typeof SiteRtmpServerControllerList1LanguageEnum[keyof typeof SiteRtmpServerControllerList1LanguageEnum];
/**
 * @export
 */
export const SiteRtmpServerControllerList1IntervalEnum = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_6: 6,
    NUMBER_12: 12,
    NUMBER_24: 24
} as const;
export type SiteRtmpServerControllerList1IntervalEnum = typeof SiteRtmpServerControllerList1IntervalEnum[keyof typeof SiteRtmpServerControllerList1IntervalEnum];
/**
 * @export
 */
export const SiteRtmpServerControllerState1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteRtmpServerControllerState1VEnum = typeof SiteRtmpServerControllerState1VEnum[keyof typeof SiteRtmpServerControllerState1VEnum];
/**
 * @export
 */
export const SiteRtmpServerControllerState1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteRtmpServerControllerState1LanguageEnum = typeof SiteRtmpServerControllerState1LanguageEnum[keyof typeof SiteRtmpServerControllerState1LanguageEnum];
/**
 * @export
 */
export const SiteRtmpServerControllerState1IntervalEnum = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_6: 6,
    NUMBER_12: 12,
    NUMBER_24: 24
} as const;
export type SiteRtmpServerControllerState1IntervalEnum = typeof SiteRtmpServerControllerState1IntervalEnum[keyof typeof SiteRtmpServerControllerState1IntervalEnum];


/**
 * SocialsApi - axios parameter creator
 * @export
 */
export const SocialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Social list for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialsControllerGetList1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/method/socials/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SocialsApi - functional programming interface
 * @export
 */
export const SocialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SocialsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Social list for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async socialsControllerGetList1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.socialsControllerGetList1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SocialsApi.socialsControllerGetList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SocialsApi - factory interface
 * @export
 */
export const SocialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SocialsApiFp(configuration)
    return {
        /**
         * 
         * @summary Social list for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialsControllerGetList1(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.socialsControllerGetList1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SocialsApi - object-oriented interface
 * @export
 * @class SocialsApi
 * @extends {BaseAPI}
 */
export class SocialsApi extends BaseAPI {
    /**
     * 
     * @summary Social list for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SocialsApi
     */
    public socialsControllerGetList1(options?: RawAxiosRequestConfig) {
        return SocialsApiFp(this.configuration).socialsControllerGetList1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StreamKeyApi - axios parameter creator
 * @export
 */
export const StreamKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get stream credentials
         * @param {SiteStreamKeysControllerKey1VEnum} v Version
         * @param {SiteStreamKeysControllerKey1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteStreamKeysControllerKey1: async (v: SiteStreamKeysControllerKey1VEnum, language: SiteStreamKeysControllerKey1LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteStreamKeysControllerKey1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteStreamKeysControllerKey1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteStreamKeysControllerKey1', 'projectId', projectId)
            const localVarPath = `/method/stream-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update record
         * @param {SetRecordStreamRequest} setRecordStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteStreamKeysControllerUpdateRecord1: async (setRecordStreamRequest: SetRecordStreamRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setRecordStreamRequest' is not null or undefined
            assertParamExists('siteStreamKeysControllerUpdateRecord1', 'setRecordStreamRequest', setRecordStreamRequest)
            const localVarPath = `/method/stream-keys/record`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setRecordStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StreamKeyApi - functional programming interface
 * @export
 */
export const StreamKeyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StreamKeyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get stream credentials
         * @param {SiteStreamKeysControllerKey1VEnum} v Version
         * @param {SiteStreamKeysControllerKey1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteStreamKeysControllerKey1(v: SiteStreamKeysControllerKey1VEnum, language: SiteStreamKeysControllerKey1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStreamKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteStreamKeysControllerKey1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StreamKeyApi.siteStreamKeysControllerKey1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update record
         * @param {SetRecordStreamRequest} setRecordStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteStreamKeysControllerUpdateRecord1(setRecordStreamRequest: SetRecordStreamRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteStreamKeysControllerUpdateRecord1(setRecordStreamRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StreamKeyApi.siteStreamKeysControllerUpdateRecord1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StreamKeyApi - factory interface
 * @export
 */
export const StreamKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StreamKeyApiFp(configuration)
    return {
        /**
         * 
         * @summary Get stream credentials
         * @param {SiteStreamKeysControllerKey1VEnum} v Version
         * @param {SiteStreamKeysControllerKey1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteStreamKeysControllerKey1(v: SiteStreamKeysControllerKey1VEnum, language: SiteStreamKeysControllerKey1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<GetStreamKeyResponse> {
            return localVarFp.siteStreamKeysControllerKey1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update record
         * @param {SetRecordStreamRequest} setRecordStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteStreamKeysControllerUpdateRecord1(setRecordStreamRequest: SetRecordStreamRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteStreamKeysControllerUpdateRecord1(setRecordStreamRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StreamKeyApi - object-oriented interface
 * @export
 * @class StreamKeyApi
 * @extends {BaseAPI}
 */
export class StreamKeyApi extends BaseAPI {
    /**
     * 
     * @summary Get stream credentials
     * @param {SiteStreamKeysControllerKey1VEnum} v Version
     * @param {SiteStreamKeysControllerKey1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamKeyApi
     */
    public siteStreamKeysControllerKey1(v: SiteStreamKeysControllerKey1VEnum, language: SiteStreamKeysControllerKey1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return StreamKeyApiFp(this.configuration).siteStreamKeysControllerKey1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update record
     * @param {SetRecordStreamRequest} setRecordStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamKeyApi
     */
    public siteStreamKeysControllerUpdateRecord1(setRecordStreamRequest: SetRecordStreamRequest, options?: RawAxiosRequestConfig) {
        return StreamKeyApiFp(this.configuration).siteStreamKeysControllerUpdateRecord1(setRecordStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SiteStreamKeysControllerKey1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteStreamKeysControllerKey1VEnum = typeof SiteStreamKeysControllerKey1VEnum[keyof typeof SiteStreamKeysControllerKey1VEnum];
/**
 * @export
 */
export const SiteStreamKeysControllerKey1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteStreamKeysControllerKey1LanguageEnum = typeof SiteStreamKeysControllerKey1LanguageEnum[keyof typeof SiteStreamKeysControllerKey1LanguageEnum];


/**
 * StreamPullKeysApi - axios parameter creator
 * @export
 */
export const StreamPullKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check key
         * @param {StreamPullKeysSiteControllerCheck1VEnum} v Version
         * @param {StreamPullKeysSiteControllerCheck1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {string} key Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamPullKeysSiteControllerCheck1: async (v: StreamPullKeysSiteControllerCheck1VEnum, language: StreamPullKeysSiteControllerCheck1LanguageEnum, projectId: number, key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('streamPullKeysSiteControllerCheck1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('streamPullKeysSiteControllerCheck1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('streamPullKeysSiteControllerCheck1', 'projectId', projectId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('streamPullKeysSiteControllerCheck1', 'key', key)
            const localVarPath = `/method/stream-pull-keys/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create key
         * @param {CreatePullKeyRequest} createPullKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamPullKeysSiteControllerCreate1: async (createPullKeyRequest: CreatePullKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPullKeyRequest' is not null or undefined
            assertParamExists('streamPullKeysSiteControllerCreate1', 'createPullKeyRequest', createPullKeyRequest)
            const localVarPath = `/method/stream-pull-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPullKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List keys
         * @param {StreamPullKeysSiteControllerGet1VEnum} v Version
         * @param {StreamPullKeysSiteControllerGet1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamPullKeysSiteControllerGet1: async (v: StreamPullKeysSiteControllerGet1VEnum, language: StreamPullKeysSiteControllerGet1LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('streamPullKeysSiteControllerGet1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('streamPullKeysSiteControllerGet1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('streamPullKeysSiteControllerGet1', 'projectId', projectId)
            const localVarPath = `/method/stream-pull-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete key
         * @param {StreamPullKeysSiteControllerRemove1VEnum} v Version
         * @param {StreamPullKeysSiteControllerRemove1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {string} key Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamPullKeysSiteControllerRemove1: async (v: StreamPullKeysSiteControllerRemove1VEnum, language: StreamPullKeysSiteControllerRemove1LanguageEnum, projectId: number, key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('streamPullKeysSiteControllerRemove1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('streamPullKeysSiteControllerRemove1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('streamPullKeysSiteControllerRemove1', 'projectId', projectId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('streamPullKeysSiteControllerRemove1', 'key', key)
            const localVarPath = `/method/stream-pull-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update key
         * @param {UpdatePullKeyRequest} updatePullKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamPullKeysSiteControllerUpdate1: async (updatePullKeyRequest: UpdatePullKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updatePullKeyRequest' is not null or undefined
            assertParamExists('streamPullKeysSiteControllerUpdate1', 'updatePullKeyRequest', updatePullKeyRequest)
            const localVarPath = `/method/stream-pull-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePullKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StreamPullKeysApi - functional programming interface
 * @export
 */
export const StreamPullKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StreamPullKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check key
         * @param {StreamPullKeysSiteControllerCheck1VEnum} v Version
         * @param {StreamPullKeysSiteControllerCheck1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {string} key Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamPullKeysSiteControllerCheck1(v: StreamPullKeysSiteControllerCheck1VEnum, language: StreamPullKeysSiteControllerCheck1LanguageEnum, projectId: number, key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckPullKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamPullKeysSiteControllerCheck1(v, language, projectId, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StreamPullKeysApi.streamPullKeysSiteControllerCheck1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create key
         * @param {CreatePullKeyRequest} createPullKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamPullKeysSiteControllerCreate1(createPullKeyRequest: CreatePullKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePullKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamPullKeysSiteControllerCreate1(createPullKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StreamPullKeysApi.streamPullKeysSiteControllerCreate1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List keys
         * @param {StreamPullKeysSiteControllerGet1VEnum} v Version
         * @param {StreamPullKeysSiteControllerGet1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamPullKeysSiteControllerGet1(v: StreamPullKeysSiteControllerGet1VEnum, language: StreamPullKeysSiteControllerGet1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullKeyListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamPullKeysSiteControllerGet1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StreamPullKeysApi.streamPullKeysSiteControllerGet1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete key
         * @param {StreamPullKeysSiteControllerRemove1VEnum} v Version
         * @param {StreamPullKeysSiteControllerRemove1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {string} key Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamPullKeysSiteControllerRemove1(v: StreamPullKeysSiteControllerRemove1VEnum, language: StreamPullKeysSiteControllerRemove1LanguageEnum, projectId: number, key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamPullKeysSiteControllerRemove1(v, language, projectId, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StreamPullKeysApi.streamPullKeysSiteControllerRemove1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update key
         * @param {UpdatePullKeyRequest} updatePullKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamPullKeysSiteControllerUpdate1(updatePullKeyRequest: UpdatePullKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamPullKeysSiteControllerUpdate1(updatePullKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StreamPullKeysApi.streamPullKeysSiteControllerUpdate1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StreamPullKeysApi - factory interface
 * @export
 */
export const StreamPullKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StreamPullKeysApiFp(configuration)
    return {
        /**
         * 
         * @summary Check key
         * @param {StreamPullKeysSiteControllerCheck1VEnum} v Version
         * @param {StreamPullKeysSiteControllerCheck1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {string} key Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamPullKeysSiteControllerCheck1(v: StreamPullKeysSiteControllerCheck1VEnum, language: StreamPullKeysSiteControllerCheck1LanguageEnum, projectId: number, key: string, options?: RawAxiosRequestConfig): AxiosPromise<CheckPullKeyResponse> {
            return localVarFp.streamPullKeysSiteControllerCheck1(v, language, projectId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create key
         * @param {CreatePullKeyRequest} createPullKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamPullKeysSiteControllerCreate1(createPullKeyRequest: CreatePullKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreatePullKeyResponse> {
            return localVarFp.streamPullKeysSiteControllerCreate1(createPullKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List keys
         * @param {StreamPullKeysSiteControllerGet1VEnum} v Version
         * @param {StreamPullKeysSiteControllerGet1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamPullKeysSiteControllerGet1(v: StreamPullKeysSiteControllerGet1VEnum, language: StreamPullKeysSiteControllerGet1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<PullKeyListResponse> {
            return localVarFp.streamPullKeysSiteControllerGet1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete key
         * @param {StreamPullKeysSiteControllerRemove1VEnum} v Version
         * @param {StreamPullKeysSiteControllerRemove1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {string} key Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamPullKeysSiteControllerRemove1(v: StreamPullKeysSiteControllerRemove1VEnum, language: StreamPullKeysSiteControllerRemove1LanguageEnum, projectId: number, key: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.streamPullKeysSiteControllerRemove1(v, language, projectId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update key
         * @param {UpdatePullKeyRequest} updatePullKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamPullKeysSiteControllerUpdate1(updatePullKeyRequest: UpdatePullKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.streamPullKeysSiteControllerUpdate1(updatePullKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StreamPullKeysApi - object-oriented interface
 * @export
 * @class StreamPullKeysApi
 * @extends {BaseAPI}
 */
export class StreamPullKeysApi extends BaseAPI {
    /**
     * 
     * @summary Check key
     * @param {StreamPullKeysSiteControllerCheck1VEnum} v Version
     * @param {StreamPullKeysSiteControllerCheck1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {string} key Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamPullKeysApi
     */
    public streamPullKeysSiteControllerCheck1(v: StreamPullKeysSiteControllerCheck1VEnum, language: StreamPullKeysSiteControllerCheck1LanguageEnum, projectId: number, key: string, options?: RawAxiosRequestConfig) {
        return StreamPullKeysApiFp(this.configuration).streamPullKeysSiteControllerCheck1(v, language, projectId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create key
     * @param {CreatePullKeyRequest} createPullKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamPullKeysApi
     */
    public streamPullKeysSiteControllerCreate1(createPullKeyRequest: CreatePullKeyRequest, options?: RawAxiosRequestConfig) {
        return StreamPullKeysApiFp(this.configuration).streamPullKeysSiteControllerCreate1(createPullKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List keys
     * @param {StreamPullKeysSiteControllerGet1VEnum} v Version
     * @param {StreamPullKeysSiteControllerGet1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamPullKeysApi
     */
    public streamPullKeysSiteControllerGet1(v: StreamPullKeysSiteControllerGet1VEnum, language: StreamPullKeysSiteControllerGet1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return StreamPullKeysApiFp(this.configuration).streamPullKeysSiteControllerGet1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete key
     * @param {StreamPullKeysSiteControllerRemove1VEnum} v Version
     * @param {StreamPullKeysSiteControllerRemove1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {string} key Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamPullKeysApi
     */
    public streamPullKeysSiteControllerRemove1(v: StreamPullKeysSiteControllerRemove1VEnum, language: StreamPullKeysSiteControllerRemove1LanguageEnum, projectId: number, key: string, options?: RawAxiosRequestConfig) {
        return StreamPullKeysApiFp(this.configuration).streamPullKeysSiteControllerRemove1(v, language, projectId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update key
     * @param {UpdatePullKeyRequest} updatePullKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamPullKeysApi
     */
    public streamPullKeysSiteControllerUpdate1(updatePullKeyRequest: UpdatePullKeyRequest, options?: RawAxiosRequestConfig) {
        return StreamPullKeysApiFp(this.configuration).streamPullKeysSiteControllerUpdate1(updatePullKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const StreamPullKeysSiteControllerCheck1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type StreamPullKeysSiteControllerCheck1VEnum = typeof StreamPullKeysSiteControllerCheck1VEnum[keyof typeof StreamPullKeysSiteControllerCheck1VEnum];
/**
 * @export
 */
export const StreamPullKeysSiteControllerCheck1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type StreamPullKeysSiteControllerCheck1LanguageEnum = typeof StreamPullKeysSiteControllerCheck1LanguageEnum[keyof typeof StreamPullKeysSiteControllerCheck1LanguageEnum];
/**
 * @export
 */
export const StreamPullKeysSiteControllerGet1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type StreamPullKeysSiteControllerGet1VEnum = typeof StreamPullKeysSiteControllerGet1VEnum[keyof typeof StreamPullKeysSiteControllerGet1VEnum];
/**
 * @export
 */
export const StreamPullKeysSiteControllerGet1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type StreamPullKeysSiteControllerGet1LanguageEnum = typeof StreamPullKeysSiteControllerGet1LanguageEnum[keyof typeof StreamPullKeysSiteControllerGet1LanguageEnum];
/**
 * @export
 */
export const StreamPullKeysSiteControllerRemove1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type StreamPullKeysSiteControllerRemove1VEnum = typeof StreamPullKeysSiteControllerRemove1VEnum[keyof typeof StreamPullKeysSiteControllerRemove1VEnum];
/**
 * @export
 */
export const StreamPullKeysSiteControllerRemove1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type StreamPullKeysSiteControllerRemove1LanguageEnum = typeof StreamPullKeysSiteControllerRemove1LanguageEnum[keyof typeof StreamPullKeysSiteControllerRemove1LanguageEnum];


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Transaction list for frontend
         * @param {SiteTransactionsControllerList1VEnum} v Version
         * @param {SiteTransactionsControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {string} [dateFrom] Date from
         * @param {string} [dateTo] Date to
         * @param {string} [code] Filter code transaction. example 1 or 1,2,3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteTransactionsControllerList1: async (v: SiteTransactionsControllerList1VEnum, language: SiteTransactionsControllerList1LanguageEnum, projectId: number, limit?: number, offset?: number, dateFrom?: string, dateTo?: string, code?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteTransactionsControllerList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteTransactionsControllerList1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteTransactionsControllerList1', 'projectId', projectId)
            const localVarPath = `/method/transactions/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString() :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString() :
                    dateTo;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Transaction list for frontend
         * @param {SiteTransactionsControllerList1VEnum} v Version
         * @param {SiteTransactionsControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {string} [dateFrom] Date from
         * @param {string} [dateTo] Date to
         * @param {string} [code] Filter code transaction. example 1 or 1,2,3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteTransactionsControllerList1(v: SiteTransactionsControllerList1VEnum, language: SiteTransactionsControllerList1LanguageEnum, projectId: number, limit?: number, offset?: number, dateFrom?: string, dateTo?: string, code?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseOfTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteTransactionsControllerList1(v, language, projectId, limit, offset, dateFrom, dateTo, code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.siteTransactionsControllerList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Transaction list for frontend
         * @param {SiteTransactionsControllerList1VEnum} v Version
         * @param {SiteTransactionsControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {string} [dateFrom] Date from
         * @param {string} [dateTo] Date to
         * @param {string} [code] Filter code transaction. example 1 or 1,2,3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteTransactionsControllerList1(v: SiteTransactionsControllerList1VEnum, language: SiteTransactionsControllerList1LanguageEnum, projectId: number, limit?: number, offset?: number, dateFrom?: string, dateTo?: string, code?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseOfTransactionResponse> {
            return localVarFp.siteTransactionsControllerList1(v, language, projectId, limit, offset, dateFrom, dateTo, code, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * 
     * @summary Transaction list for frontend
     * @param {SiteTransactionsControllerList1VEnum} v Version
     * @param {SiteTransactionsControllerList1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} [limit] Number of results
     * @param {number} [offset] Page offset number
     * @param {string} [dateFrom] Date from
     * @param {string} [dateTo] Date to
     * @param {string} [code] Filter code transaction. example 1 or 1,2,3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public siteTransactionsControllerList1(v: SiteTransactionsControllerList1VEnum, language: SiteTransactionsControllerList1LanguageEnum, projectId: number, limit?: number, offset?: number, dateFrom?: string, dateTo?: string, code?: string, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).siteTransactionsControllerList1(v, language, projectId, limit, offset, dateFrom, dateTo, code, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SiteTransactionsControllerList1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteTransactionsControllerList1VEnum = typeof SiteTransactionsControllerList1VEnum[keyof typeof SiteTransactionsControllerList1VEnum];
/**
 * @export
 */
export const SiteTransactionsControllerList1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteTransactionsControllerList1LanguageEnum = typeof SiteTransactionsControllerList1LanguageEnum[keyof typeof SiteTransactionsControllerList1LanguageEnum];


/**
 * TranscodersApi - axios parameter creator
 * @export
 */
export const TranscodersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Transcoder create
         * @param {SiteTranscoderCreateDto} siteTranscoderCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcodersControllerAdd1: async (siteTranscoderCreateDto: SiteTranscoderCreateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteTranscoderCreateDto' is not null or undefined
            assertParamExists('transcodersControllerAdd1', 'siteTranscoderCreateDto', siteTranscoderCreateDto)
            const localVarPath = `/method/transcoder/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteTranscoderCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transcoder delete
         * @param {SiteTranscoderItemDto} siteTranscoderItemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcodersControllerDelete1: async (siteTranscoderItemDto: SiteTranscoderItemDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteTranscoderItemDto' is not null or undefined
            assertParamExists('transcodersControllerDelete1', 'siteTranscoderItemDto', siteTranscoderItemDto)
            const localVarPath = `/method/transcoder/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteTranscoderItemDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of transcoder
         * @param {TranscodersControllerList1VEnum} v Version
         * @param {TranscodersControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcodersControllerList1: async (v: TranscodersControllerList1VEnum, language: TranscodersControllerList1LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('transcodersControllerList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('transcodersControllerList1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('transcodersControllerList1', 'projectId', projectId)
            const localVarPath = `/method/transcoder/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transcoder stop
         * @param {SiteTranscoderItemDto} siteTranscoderItemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcodersControllerStop1: async (siteTranscoderItemDto: SiteTranscoderItemDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteTranscoderItemDto' is not null or undefined
            assertParamExists('transcodersControllerStop1', 'siteTranscoderItemDto', siteTranscoderItemDto)
            const localVarPath = `/method/transcoder/stop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteTranscoderItemDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transcoder update
         * @param {SiteTranscoderUpdateDto} siteTranscoderUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcodersControllerUpdate1: async (siteTranscoderUpdateDto: SiteTranscoderUpdateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteTranscoderUpdateDto' is not null or undefined
            assertParamExists('transcodersControllerUpdate1', 'siteTranscoderUpdateDto', siteTranscoderUpdateDto)
            const localVarPath = `/method/transcoder/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteTranscoderUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TranscodersApi - functional programming interface
 * @export
 */
export const TranscodersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TranscodersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Transcoder create
         * @param {SiteTranscoderCreateDto} siteTranscoderCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcodersControllerAdd1(siteTranscoderCreateDto: SiteTranscoderCreateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transcodersControllerAdd1(siteTranscoderCreateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranscodersApi.transcodersControllerAdd1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Transcoder delete
         * @param {SiteTranscoderItemDto} siteTranscoderItemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcodersControllerDelete1(siteTranscoderItemDto: SiteTranscoderItemDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transcodersControllerDelete1(siteTranscoderItemDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranscodersApi.transcodersControllerDelete1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of transcoder
         * @param {TranscodersControllerList1VEnum} v Version
         * @param {TranscodersControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcodersControllerList1(v: TranscodersControllerList1VEnum, language: TranscodersControllerList1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteTranscoderListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transcodersControllerList1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranscodersApi.transcodersControllerList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Transcoder stop
         * @param {SiteTranscoderItemDto} siteTranscoderItemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcodersControllerStop1(siteTranscoderItemDto: SiteTranscoderItemDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transcodersControllerStop1(siteTranscoderItemDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranscodersApi.transcodersControllerStop1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Transcoder update
         * @param {SiteTranscoderUpdateDto} siteTranscoderUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcodersControllerUpdate1(siteTranscoderUpdateDto: SiteTranscoderUpdateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transcodersControllerUpdate1(siteTranscoderUpdateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranscodersApi.transcodersControllerUpdate1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TranscodersApi - factory interface
 * @export
 */
export const TranscodersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TranscodersApiFp(configuration)
    return {
        /**
         * 
         * @summary Transcoder create
         * @param {SiteTranscoderCreateDto} siteTranscoderCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcodersControllerAdd1(siteTranscoderCreateDto: SiteTranscoderCreateDto, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.transcodersControllerAdd1(siteTranscoderCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transcoder delete
         * @param {SiteTranscoderItemDto} siteTranscoderItemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcodersControllerDelete1(siteTranscoderItemDto: SiteTranscoderItemDto, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.transcodersControllerDelete1(siteTranscoderItemDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of transcoder
         * @param {TranscodersControllerList1VEnum} v Version
         * @param {TranscodersControllerList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcodersControllerList1(v: TranscodersControllerList1VEnum, language: TranscodersControllerList1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<SiteTranscoderListResponse> {
            return localVarFp.transcodersControllerList1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transcoder stop
         * @param {SiteTranscoderItemDto} siteTranscoderItemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcodersControllerStop1(siteTranscoderItemDto: SiteTranscoderItemDto, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.transcodersControllerStop1(siteTranscoderItemDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transcoder update
         * @param {SiteTranscoderUpdateDto} siteTranscoderUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcodersControllerUpdate1(siteTranscoderUpdateDto: SiteTranscoderUpdateDto, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.transcodersControllerUpdate1(siteTranscoderUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TranscodersApi - object-oriented interface
 * @export
 * @class TranscodersApi
 * @extends {BaseAPI}
 */
export class TranscodersApi extends BaseAPI {
    /**
     * 
     * @summary Transcoder create
     * @param {SiteTranscoderCreateDto} siteTranscoderCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranscodersApi
     */
    public transcodersControllerAdd1(siteTranscoderCreateDto: SiteTranscoderCreateDto, options?: RawAxiosRequestConfig) {
        return TranscodersApiFp(this.configuration).transcodersControllerAdd1(siteTranscoderCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transcoder delete
     * @param {SiteTranscoderItemDto} siteTranscoderItemDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranscodersApi
     */
    public transcodersControllerDelete1(siteTranscoderItemDto: SiteTranscoderItemDto, options?: RawAxiosRequestConfig) {
        return TranscodersApiFp(this.configuration).transcodersControllerDelete1(siteTranscoderItemDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of transcoder
     * @param {TranscodersControllerList1VEnum} v Version
     * @param {TranscodersControllerList1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranscodersApi
     */
    public transcodersControllerList1(v: TranscodersControllerList1VEnum, language: TranscodersControllerList1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return TranscodersApiFp(this.configuration).transcodersControllerList1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transcoder stop
     * @param {SiteTranscoderItemDto} siteTranscoderItemDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranscodersApi
     */
    public transcodersControllerStop1(siteTranscoderItemDto: SiteTranscoderItemDto, options?: RawAxiosRequestConfig) {
        return TranscodersApiFp(this.configuration).transcodersControllerStop1(siteTranscoderItemDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transcoder update
     * @param {SiteTranscoderUpdateDto} siteTranscoderUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranscodersApi
     */
    public transcodersControllerUpdate1(siteTranscoderUpdateDto: SiteTranscoderUpdateDto, options?: RawAxiosRequestConfig) {
        return TranscodersApiFp(this.configuration).transcodersControllerUpdate1(siteTranscoderUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const TranscodersControllerList1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type TranscodersControllerList1VEnum = typeof TranscodersControllerList1VEnum[keyof typeof TranscodersControllerList1VEnum];
/**
 * @export
 */
export const TranscodersControllerList1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type TranscodersControllerList1LanguageEnum = typeof TranscodersControllerList1LanguageEnum[keyof typeof TranscodersControllerList1LanguageEnum];


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get user profile
         * @param {SiteUserControllerGetProfile1VEnum} v Version
         * @param {SiteUserControllerGetProfile1LanguageEnum} language Current language
         * @param {number | null} [projectId] Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserControllerGetProfile1: async (v: SiteUserControllerGetProfile1VEnum, language: SiteUserControllerGetProfile1LanguageEnum, projectId?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteUserControllerGetProfile1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteUserControllerGetProfile1', 'language', language)
            const localVarPath = `/method/users/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test code only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserControllerTestCode1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/method/users/code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test code exception only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserControllerTestCodeException1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/method/users/code-throw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update profile
         * @param {SiteUserControllerUpdateProfile1VEnum} v Version
         * @param {SiteUserControllerUpdateProfile1LanguageEnum} language Current language
         * @param {string} firstName First name
         * @param {string} lastName Last name
         * @param {File} [avatar] File for avatar upload max size 2MB, format: jpeg, jpg, png
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserControllerUpdateProfile1: async (v: SiteUserControllerUpdateProfile1VEnum, language: SiteUserControllerUpdateProfile1LanguageEnum, firstName: string, lastName: string, avatar?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteUserControllerUpdateProfile1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteUserControllerUpdateProfile1', 'language', language)
            // verify required parameter 'firstName' is not null or undefined
            assertParamExists('siteUserControllerUpdateProfile1', 'firstName', firstName)
            // verify required parameter 'lastName' is not null or undefined
            assertParamExists('siteUserControllerUpdateProfile1', 'lastName', lastName)
            const localVarPath = `/method/users/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (v !== undefined) { 
                localVarFormParams.append('v', v as any);
            }
    
            if (language !== undefined) { 
                localVarFormParams.append('language', language as any);
            }
    
            if (firstName !== undefined) { 
                localVarFormParams.append('first_name', firstName as any);
            }
    
            if (lastName !== undefined) { 
                localVarFormParams.append('last_name', lastName as any);
            }
    
            if (avatar !== undefined) { 
                localVarFormParams.append('avatar', avatar as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get user profile
         * @param {SiteUserControllerGetProfile1VEnum} v Version
         * @param {SiteUserControllerGetProfile1LanguageEnum} language Current language
         * @param {number | null} [projectId] Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteUserControllerGetProfile1(v: SiteUserControllerGetProfile1VEnum, language: SiteUserControllerGetProfile1LanguageEnum, projectId?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteUserControllerGetProfile1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.siteUserControllerGetProfile1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Test code only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteUserControllerTestCode1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteUserControllerTestCode1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.siteUserControllerTestCode1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Test code exception only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteUserControllerTestCodeException1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteUserControllerTestCodeException1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.siteUserControllerTestCodeException1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update profile
         * @param {SiteUserControllerUpdateProfile1VEnum} v Version
         * @param {SiteUserControllerUpdateProfile1LanguageEnum} language Current language
         * @param {string} firstName First name
         * @param {string} lastName Last name
         * @param {File} [avatar] File for avatar upload max size 2MB, format: jpeg, jpg, png
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteUserControllerUpdateProfile1(v: SiteUserControllerUpdateProfile1VEnum, language: SiteUserControllerUpdateProfile1LanguageEnum, firstName: string, lastName: string, avatar?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteUserControllerUpdateProfile1(v, language, firstName, lastName, avatar, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.siteUserControllerUpdateProfile1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Get user profile
         * @param {SiteUserControllerGetProfile1VEnum} v Version
         * @param {SiteUserControllerGetProfile1LanguageEnum} language Current language
         * @param {number | null} [projectId] Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserControllerGetProfile1(v: SiteUserControllerGetProfile1VEnum, language: SiteUserControllerGetProfile1LanguageEnum, projectId?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.siteUserControllerGetProfile1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test code only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserControllerTestCode1(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.siteUserControllerTestCode1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test code exception only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserControllerTestCodeException1(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.siteUserControllerTestCodeException1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update profile
         * @param {SiteUserControllerUpdateProfile1VEnum} v Version
         * @param {SiteUserControllerUpdateProfile1LanguageEnum} language Current language
         * @param {string} firstName First name
         * @param {string} lastName Last name
         * @param {File} [avatar] File for avatar upload max size 2MB, format: jpeg, jpg, png
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserControllerUpdateProfile1(v: SiteUserControllerUpdateProfile1VEnum, language: SiteUserControllerUpdateProfile1LanguageEnum, firstName: string, lastName: string, avatar?: File, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteUserControllerUpdateProfile1(v, language, firstName, lastName, avatar, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Get user profile
     * @param {SiteUserControllerGetProfile1VEnum} v Version
     * @param {SiteUserControllerGetProfile1LanguageEnum} language Current language
     * @param {number | null} [projectId] Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public siteUserControllerGetProfile1(v: SiteUserControllerGetProfile1VEnum, language: SiteUserControllerGetProfile1LanguageEnum, projectId?: number | null, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).siteUserControllerGetProfile1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test code only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public siteUserControllerTestCode1(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).siteUserControllerTestCode1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test code exception only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public siteUserControllerTestCodeException1(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).siteUserControllerTestCodeException1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update profile
     * @param {SiteUserControllerUpdateProfile1VEnum} v Version
     * @param {SiteUserControllerUpdateProfile1LanguageEnum} language Current language
     * @param {string} firstName First name
     * @param {string} lastName Last name
     * @param {File} [avatar] File for avatar upload max size 2MB, format: jpeg, jpg, png
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public siteUserControllerUpdateProfile1(v: SiteUserControllerUpdateProfile1VEnum, language: SiteUserControllerUpdateProfile1LanguageEnum, firstName: string, lastName: string, avatar?: File, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).siteUserControllerUpdateProfile1(v, language, firstName, lastName, avatar, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SiteUserControllerGetProfile1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteUserControllerGetProfile1VEnum = typeof SiteUserControllerGetProfile1VEnum[keyof typeof SiteUserControllerGetProfile1VEnum];
/**
 * @export
 */
export const SiteUserControllerGetProfile1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteUserControllerGetProfile1LanguageEnum = typeof SiteUserControllerGetProfile1LanguageEnum[keyof typeof SiteUserControllerGetProfile1LanguageEnum];
/**
 * @export
 */
export const SiteUserControllerUpdateProfile1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteUserControllerUpdateProfile1VEnum = typeof SiteUserControllerUpdateProfile1VEnum[keyof typeof SiteUserControllerUpdateProfile1VEnum];
/**
 * @export
 */
export const SiteUserControllerUpdateProfile1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteUserControllerUpdateProfile1LanguageEnum = typeof SiteUserControllerUpdateProfile1LanguageEnum[keyof typeof SiteUserControllerUpdateProfile1LanguageEnum];


/**
 * UserProjectApi - axios parameter creator
 * @export
 */
export const UserProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change access user from project
         * @param {SiteUserProjectControllerChangeAccess1VEnum} v Version
         * @param {SiteUserProjectControllerChangeAccess1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} userId User id
         * @param {SiteUserProjectControllerChangeAccess1AccessTypeEnum} accessType Access type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserProjectControllerChangeAccess1: async (v: SiteUserProjectControllerChangeAccess1VEnum, language: SiteUserProjectControllerChangeAccess1LanguageEnum, projectId: number, userId: number, accessType: SiteUserProjectControllerChangeAccess1AccessTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteUserProjectControllerChangeAccess1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteUserProjectControllerChangeAccess1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteUserProjectControllerChangeAccess1', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('siteUserProjectControllerChangeAccess1', 'userId', userId)
            // verify required parameter 'accessType' is not null or undefined
            assertParamExists('siteUserProjectControllerChangeAccess1', 'accessType', accessType)
            const localVarPath = `/method/project/user/change_access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (accessType !== undefined) {
                localVarQueryParameter['access_type'] = accessType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove user from project
         * @param {SiteUserProjectControllerDel1VEnum} v Version
         * @param {SiteUserProjectControllerDel1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} userId User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserProjectControllerDel1: async (v: SiteUserProjectControllerDel1VEnum, language: SiteUserProjectControllerDel1LanguageEnum, projectId: number, userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteUserProjectControllerDel1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteUserProjectControllerDel1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteUserProjectControllerDel1', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('siteUserProjectControllerDel1', 'userId', userId)
            const localVarPath = `/method/project/user/del`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project by number id
         * @param {SiteUserProjectControllerGetProject1VEnum} v Version
         * @param {SiteUserProjectControllerGetProject1LanguageEnum} language Current language
         * @param {string} projectExternalId Project external id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserProjectControllerGetProject1: async (v: SiteUserProjectControllerGetProject1VEnum, language: SiteUserProjectControllerGetProject1LanguageEnum, projectExternalId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteUserProjectControllerGetProject1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteUserProjectControllerGetProject1', 'language', language)
            // verify required parameter 'projectExternalId' is not null or undefined
            assertParamExists('siteUserProjectControllerGetProject1', 'projectExternalId', projectExternalId)
            const localVarPath = `/method/project/get_project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectExternalId !== undefined) {
                localVarQueryParameter['project_external_id'] = projectExternalId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project full info
         * @param {SiteUserProjectControllerGetProjectInfo1VEnum} v Version
         * @param {SiteUserProjectControllerGetProjectInfo1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserProjectControllerGetProjectInfo1: async (v: SiteUserProjectControllerGetProjectInfo1VEnum, language: SiteUserProjectControllerGetProjectInfo1LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteUserProjectControllerGetProjectInfo1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteUserProjectControllerGetProjectInfo1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteUserProjectControllerGetProjectInfo1', 'projectId', projectId)
            const localVarPath = `/method/project/get_project_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user by number id
         * @param {SiteUserProjectControllerGetUser1VEnum} v Version
         * @param {SiteUserProjectControllerGetUser1LanguageEnum} language Current language
         * @param {string} userExternalId User external id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserProjectControllerGetUser1: async (v: SiteUserProjectControllerGetUser1VEnum, language: SiteUserProjectControllerGetUser1LanguageEnum, userExternalId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteUserProjectControllerGetUser1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteUserProjectControllerGetUser1', 'language', language)
            // verify required parameter 'userExternalId' is not null or undefined
            assertParamExists('siteUserProjectControllerGetUser1', 'userExternalId', userExternalId)
            const localVarPath = `/method/project/get_user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (userExternalId !== undefined) {
                localVarQueryParameter['user_external_id'] = userExternalId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of project for current user
         * @param {SiteUserProjectControllerList1VEnum} v Version
         * @param {SiteUserProjectControllerList1LanguageEnum} language Current language
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserProjectControllerList1: async (v: SiteUserProjectControllerList1VEnum, language: SiteUserProjectControllerList1LanguageEnum, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteUserProjectControllerList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteUserProjectControllerList1', 'language', language)
            const localVarPath = `/method/project/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of user in project
         * @param {SiteUserProjectControllerListAccess1VEnum} v Version
         * @param {SiteUserProjectControllerListAccess1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserProjectControllerListAccess1: async (v: SiteUserProjectControllerListAccess1VEnum, language: SiteUserProjectControllerListAccess1LanguageEnum, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteUserProjectControllerListAccess1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteUserProjectControllerListAccess1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('siteUserProjectControllerListAccess1', 'projectId', projectId)
            const localVarPath = `/method/project/user/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Select user for project
         * @param {SiteUserProjectControllerSelectProject1VEnum} v Version
         * @param {SiteUserProjectControllerSelectProject1LanguageEnum} language Current language
         * @param {number} id Project internal id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserProjectControllerSelectProject1: async (v: SiteUserProjectControllerSelectProject1VEnum, language: SiteUserProjectControllerSelectProject1LanguageEnum, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('siteUserProjectControllerSelectProject1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('siteUserProjectControllerSelectProject1', 'language', language)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('siteUserProjectControllerSelectProject1', 'id', id)
            const localVarPath = `/method/project/select`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserProjectApi - functional programming interface
 * @export
 */
export const UserProjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserProjectApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Change access user from project
         * @param {SiteUserProjectControllerChangeAccess1VEnum} v Version
         * @param {SiteUserProjectControllerChangeAccess1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} userId User id
         * @param {SiteUserProjectControllerChangeAccess1AccessTypeEnum} accessType Access type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteUserProjectControllerChangeAccess1(v: SiteUserProjectControllerChangeAccess1VEnum, language: SiteUserProjectControllerChangeAccess1LanguageEnum, projectId: number, userId: number, accessType: SiteUserProjectControllerChangeAccess1AccessTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteUserProjectControllerChangeAccess1(v, language, projectId, userId, accessType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserProjectApi.siteUserProjectControllerChangeAccess1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove user from project
         * @param {SiteUserProjectControllerDel1VEnum} v Version
         * @param {SiteUserProjectControllerDel1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} userId User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteUserProjectControllerDel1(v: SiteUserProjectControllerDel1VEnum, language: SiteUserProjectControllerDel1LanguageEnum, projectId: number, userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteUserProjectControllerDel1(v, language, projectId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserProjectApi.siteUserProjectControllerDel1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get project by number id
         * @param {SiteUserProjectControllerGetProject1VEnum} v Version
         * @param {SiteUserProjectControllerGetProject1LanguageEnum} language Current language
         * @param {string} projectExternalId Project external id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteUserProjectControllerGetProject1(v: SiteUserProjectControllerGetProject1VEnum, language: SiteUserProjectControllerGetProject1LanguageEnum, projectExternalId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProjectGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteUserProjectControllerGetProject1(v, language, projectExternalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserProjectApi.siteUserProjectControllerGetProject1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get project full info
         * @param {SiteUserProjectControllerGetProjectInfo1VEnum} v Version
         * @param {SiteUserProjectControllerGetProjectInfo1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteUserProjectControllerGetProjectInfo1(v: SiteUserProjectControllerGetProjectInfo1VEnum, language: SiteUserProjectControllerGetProjectInfo1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteUserProjectControllerGetProjectInfo1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserProjectApi.siteUserProjectControllerGetProjectInfo1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user by number id
         * @param {SiteUserProjectControllerGetUser1VEnum} v Version
         * @param {SiteUserProjectControllerGetUser1LanguageEnum} language Current language
         * @param {string} userExternalId User external id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteUserProjectControllerGetUser1(v: SiteUserProjectControllerGetUser1VEnum, language: SiteUserProjectControllerGetUser1LanguageEnum, userExternalId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProjectGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteUserProjectControllerGetUser1(v, language, userExternalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserProjectApi.siteUserProjectControllerGetUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of project for current user
         * @param {SiteUserProjectControllerList1VEnum} v Version
         * @param {SiteUserProjectControllerList1LanguageEnum} language Current language
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteUserProjectControllerList1(v: SiteUserProjectControllerList1VEnum, language: SiteUserProjectControllerList1LanguageEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseOfUserProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteUserProjectControllerList1(v, language, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserProjectApi.siteUserProjectControllerList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of user in project
         * @param {SiteUserProjectControllerListAccess1VEnum} v Version
         * @param {SiteUserProjectControllerListAccess1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteUserProjectControllerListAccess1(v: SiteUserProjectControllerListAccess1VEnum, language: SiteUserProjectControllerListAccess1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOfUserProject2ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteUserProjectControllerListAccess1(v, language, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserProjectApi.siteUserProjectControllerListAccess1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Select user for project
         * @param {SiteUserProjectControllerSelectProject1VEnum} v Version
         * @param {SiteUserProjectControllerSelectProject1LanguageEnum} language Current language
         * @param {number} id Project internal id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteUserProjectControllerSelectProject1(v: SiteUserProjectControllerSelectProject1VEnum, language: SiteUserProjectControllerSelectProject1LanguageEnum, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProjectGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteUserProjectControllerSelectProject1(v, language, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserProjectApi.siteUserProjectControllerSelectProject1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserProjectApi - factory interface
 * @export
 */
export const UserProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserProjectApiFp(configuration)
    return {
        /**
         * 
         * @summary Change access user from project
         * @param {SiteUserProjectControllerChangeAccess1VEnum} v Version
         * @param {SiteUserProjectControllerChangeAccess1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} userId User id
         * @param {SiteUserProjectControllerChangeAccess1AccessTypeEnum} accessType Access type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserProjectControllerChangeAccess1(v: SiteUserProjectControllerChangeAccess1VEnum, language: SiteUserProjectControllerChangeAccess1LanguageEnum, projectId: number, userId: number, accessType: SiteUserProjectControllerChangeAccess1AccessTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteUserProjectControllerChangeAccess1(v, language, projectId, userId, accessType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove user from project
         * @param {SiteUserProjectControllerDel1VEnum} v Version
         * @param {SiteUserProjectControllerDel1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} userId User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserProjectControllerDel1(v: SiteUserProjectControllerDel1VEnum, language: SiteUserProjectControllerDel1LanguageEnum, projectId: number, userId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.siteUserProjectControllerDel1(v, language, projectId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project by number id
         * @param {SiteUserProjectControllerGetProject1VEnum} v Version
         * @param {SiteUserProjectControllerGetProject1LanguageEnum} language Current language
         * @param {string} projectExternalId Project external id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserProjectControllerGetProject1(v: SiteUserProjectControllerGetProject1VEnum, language: SiteUserProjectControllerGetProject1LanguageEnum, projectExternalId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserProjectGetResponse> {
            return localVarFp.siteUserProjectControllerGetProject1(v, language, projectExternalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project full info
         * @param {SiteUserProjectControllerGetProjectInfo1VEnum} v Version
         * @param {SiteUserProjectControllerGetProjectInfo1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserProjectControllerGetProjectInfo1(v: SiteUserProjectControllerGetProjectInfo1VEnum, language: SiteUserProjectControllerGetProjectInfo1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<ProjectInfoResponse> {
            return localVarFp.siteUserProjectControllerGetProjectInfo1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user by number id
         * @param {SiteUserProjectControllerGetUser1VEnum} v Version
         * @param {SiteUserProjectControllerGetUser1LanguageEnum} language Current language
         * @param {string} userExternalId User external id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserProjectControllerGetUser1(v: SiteUserProjectControllerGetUser1VEnum, language: SiteUserProjectControllerGetUser1LanguageEnum, userExternalId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserProjectGetResponse> {
            return localVarFp.siteUserProjectControllerGetUser1(v, language, userExternalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of project for current user
         * @param {SiteUserProjectControllerList1VEnum} v Version
         * @param {SiteUserProjectControllerList1LanguageEnum} language Current language
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserProjectControllerList1(v: SiteUserProjectControllerList1VEnum, language: SiteUserProjectControllerList1LanguageEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseOfUserProjectResponse> {
            return localVarFp.siteUserProjectControllerList1(v, language, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of user in project
         * @param {SiteUserProjectControllerListAccess1VEnum} v Version
         * @param {SiteUserProjectControllerListAccess1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserProjectControllerListAccess1(v: SiteUserProjectControllerListAccess1VEnum, language: SiteUserProjectControllerListAccess1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<ListOfUserProject2ProjectResponse> {
            return localVarFp.siteUserProjectControllerListAccess1(v, language, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Select user for project
         * @param {SiteUserProjectControllerSelectProject1VEnum} v Version
         * @param {SiteUserProjectControllerSelectProject1LanguageEnum} language Current language
         * @param {number} id Project internal id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteUserProjectControllerSelectProject1(v: SiteUserProjectControllerSelectProject1VEnum, language: SiteUserProjectControllerSelectProject1LanguageEnum, id: number, options?: RawAxiosRequestConfig): AxiosPromise<UserProjectGetResponse> {
            return localVarFp.siteUserProjectControllerSelectProject1(v, language, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserProjectApi - object-oriented interface
 * @export
 * @class UserProjectApi
 * @extends {BaseAPI}
 */
export class UserProjectApi extends BaseAPI {
    /**
     * 
     * @summary Change access user from project
     * @param {SiteUserProjectControllerChangeAccess1VEnum} v Version
     * @param {SiteUserProjectControllerChangeAccess1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} userId User id
     * @param {SiteUserProjectControllerChangeAccess1AccessTypeEnum} accessType Access type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProjectApi
     */
    public siteUserProjectControllerChangeAccess1(v: SiteUserProjectControllerChangeAccess1VEnum, language: SiteUserProjectControllerChangeAccess1LanguageEnum, projectId: number, userId: number, accessType: SiteUserProjectControllerChangeAccess1AccessTypeEnum, options?: RawAxiosRequestConfig) {
        return UserProjectApiFp(this.configuration).siteUserProjectControllerChangeAccess1(v, language, projectId, userId, accessType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove user from project
     * @param {SiteUserProjectControllerDel1VEnum} v Version
     * @param {SiteUserProjectControllerDel1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {number} userId User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProjectApi
     */
    public siteUserProjectControllerDel1(v: SiteUserProjectControllerDel1VEnum, language: SiteUserProjectControllerDel1LanguageEnum, projectId: number, userId: number, options?: RawAxiosRequestConfig) {
        return UserProjectApiFp(this.configuration).siteUserProjectControllerDel1(v, language, projectId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project by number id
     * @param {SiteUserProjectControllerGetProject1VEnum} v Version
     * @param {SiteUserProjectControllerGetProject1LanguageEnum} language Current language
     * @param {string} projectExternalId Project external id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProjectApi
     */
    public siteUserProjectControllerGetProject1(v: SiteUserProjectControllerGetProject1VEnum, language: SiteUserProjectControllerGetProject1LanguageEnum, projectExternalId: string, options?: RawAxiosRequestConfig) {
        return UserProjectApiFp(this.configuration).siteUserProjectControllerGetProject1(v, language, projectExternalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project full info
     * @param {SiteUserProjectControllerGetProjectInfo1VEnum} v Version
     * @param {SiteUserProjectControllerGetProjectInfo1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProjectApi
     */
    public siteUserProjectControllerGetProjectInfo1(v: SiteUserProjectControllerGetProjectInfo1VEnum, language: SiteUserProjectControllerGetProjectInfo1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return UserProjectApiFp(this.configuration).siteUserProjectControllerGetProjectInfo1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user by number id
     * @param {SiteUserProjectControllerGetUser1VEnum} v Version
     * @param {SiteUserProjectControllerGetUser1LanguageEnum} language Current language
     * @param {string} userExternalId User external id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProjectApi
     */
    public siteUserProjectControllerGetUser1(v: SiteUserProjectControllerGetUser1VEnum, language: SiteUserProjectControllerGetUser1LanguageEnum, userExternalId: string, options?: RawAxiosRequestConfig) {
        return UserProjectApiFp(this.configuration).siteUserProjectControllerGetUser1(v, language, userExternalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of project for current user
     * @param {SiteUserProjectControllerList1VEnum} v Version
     * @param {SiteUserProjectControllerList1LanguageEnum} language Current language
     * @param {number} [limit] Number of results
     * @param {number} [offset] Page offset number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProjectApi
     */
    public siteUserProjectControllerList1(v: SiteUserProjectControllerList1VEnum, language: SiteUserProjectControllerList1LanguageEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return UserProjectApiFp(this.configuration).siteUserProjectControllerList1(v, language, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of user in project
     * @param {SiteUserProjectControllerListAccess1VEnum} v Version
     * @param {SiteUserProjectControllerListAccess1LanguageEnum} language Current language
     * @param {number} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProjectApi
     */
    public siteUserProjectControllerListAccess1(v: SiteUserProjectControllerListAccess1VEnum, language: SiteUserProjectControllerListAccess1LanguageEnum, projectId: number, options?: RawAxiosRequestConfig) {
        return UserProjectApiFp(this.configuration).siteUserProjectControllerListAccess1(v, language, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Select user for project
     * @param {SiteUserProjectControllerSelectProject1VEnum} v Version
     * @param {SiteUserProjectControllerSelectProject1LanguageEnum} language Current language
     * @param {number} id Project internal id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProjectApi
     */
    public siteUserProjectControllerSelectProject1(v: SiteUserProjectControllerSelectProject1VEnum, language: SiteUserProjectControllerSelectProject1LanguageEnum, id: number, options?: RawAxiosRequestConfig) {
        return UserProjectApiFp(this.configuration).siteUserProjectControllerSelectProject1(v, language, id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SiteUserProjectControllerChangeAccess1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteUserProjectControllerChangeAccess1VEnum = typeof SiteUserProjectControllerChangeAccess1VEnum[keyof typeof SiteUserProjectControllerChangeAccess1VEnum];
/**
 * @export
 */
export const SiteUserProjectControllerChangeAccess1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteUserProjectControllerChangeAccess1LanguageEnum = typeof SiteUserProjectControllerChangeAccess1LanguageEnum[keyof typeof SiteUserProjectControllerChangeAccess1LanguageEnum];
/**
 * @export
 */
export const SiteUserProjectControllerChangeAccess1AccessTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;
export type SiteUserProjectControllerChangeAccess1AccessTypeEnum = typeof SiteUserProjectControllerChangeAccess1AccessTypeEnum[keyof typeof SiteUserProjectControllerChangeAccess1AccessTypeEnum];
/**
 * @export
 */
export const SiteUserProjectControllerDel1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteUserProjectControllerDel1VEnum = typeof SiteUserProjectControllerDel1VEnum[keyof typeof SiteUserProjectControllerDel1VEnum];
/**
 * @export
 */
export const SiteUserProjectControllerDel1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteUserProjectControllerDel1LanguageEnum = typeof SiteUserProjectControllerDel1LanguageEnum[keyof typeof SiteUserProjectControllerDel1LanguageEnum];
/**
 * @export
 */
export const SiteUserProjectControllerGetProject1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteUserProjectControllerGetProject1VEnum = typeof SiteUserProjectControllerGetProject1VEnum[keyof typeof SiteUserProjectControllerGetProject1VEnum];
/**
 * @export
 */
export const SiteUserProjectControllerGetProject1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteUserProjectControllerGetProject1LanguageEnum = typeof SiteUserProjectControllerGetProject1LanguageEnum[keyof typeof SiteUserProjectControllerGetProject1LanguageEnum];
/**
 * @export
 */
export const SiteUserProjectControllerGetProjectInfo1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteUserProjectControllerGetProjectInfo1VEnum = typeof SiteUserProjectControllerGetProjectInfo1VEnum[keyof typeof SiteUserProjectControllerGetProjectInfo1VEnum];
/**
 * @export
 */
export const SiteUserProjectControllerGetProjectInfo1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteUserProjectControllerGetProjectInfo1LanguageEnum = typeof SiteUserProjectControllerGetProjectInfo1LanguageEnum[keyof typeof SiteUserProjectControllerGetProjectInfo1LanguageEnum];
/**
 * @export
 */
export const SiteUserProjectControllerGetUser1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteUserProjectControllerGetUser1VEnum = typeof SiteUserProjectControllerGetUser1VEnum[keyof typeof SiteUserProjectControllerGetUser1VEnum];
/**
 * @export
 */
export const SiteUserProjectControllerGetUser1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteUserProjectControllerGetUser1LanguageEnum = typeof SiteUserProjectControllerGetUser1LanguageEnum[keyof typeof SiteUserProjectControllerGetUser1LanguageEnum];
/**
 * @export
 */
export const SiteUserProjectControllerList1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteUserProjectControllerList1VEnum = typeof SiteUserProjectControllerList1VEnum[keyof typeof SiteUserProjectControllerList1VEnum];
/**
 * @export
 */
export const SiteUserProjectControllerList1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteUserProjectControllerList1LanguageEnum = typeof SiteUserProjectControllerList1LanguageEnum[keyof typeof SiteUserProjectControllerList1LanguageEnum];
/**
 * @export
 */
export const SiteUserProjectControllerListAccess1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteUserProjectControllerListAccess1VEnum = typeof SiteUserProjectControllerListAccess1VEnum[keyof typeof SiteUserProjectControllerListAccess1VEnum];
/**
 * @export
 */
export const SiteUserProjectControllerListAccess1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteUserProjectControllerListAccess1LanguageEnum = typeof SiteUserProjectControllerListAccess1LanguageEnum[keyof typeof SiteUserProjectControllerListAccess1LanguageEnum];
/**
 * @export
 */
export const SiteUserProjectControllerSelectProject1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type SiteUserProjectControllerSelectProject1VEnum = typeof SiteUserProjectControllerSelectProject1VEnum[keyof typeof SiteUserProjectControllerSelectProject1VEnum];
/**
 * @export
 */
export const SiteUserProjectControllerSelectProject1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
} as const;
export type SiteUserProjectControllerSelectProject1LanguageEnum = typeof SiteUserProjectControllerSelectProject1LanguageEnum[keyof typeof SiteUserProjectControllerSelectProject1LanguageEnum];


