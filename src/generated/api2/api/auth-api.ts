/* tslint:disable */
/* eslint-disable */
/**
 * StreamVi Backend
 * API
 *
 * The version of the OpenAPI document: 3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, keyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { CodeAppAuthResponse } from '../models';
// @ts-ignore
import type { ErrorResponse } from '../models';
// @ts-ignore
import type { RefreshAuthResponse } from '../models';
// @ts-ignore
import type { SiteAuthExchangeRequest } from '../models';
// @ts-ignore
import type { SiteLogoutAuthRequest } from '../models';
// @ts-ignore
import type { SiteRefreshAuthBodyRequest } from '../models';
// @ts-ignore
import type { SuccessResponse } from '../models';
/**
 * AuthApi - axios parameter creator
 * @export
 */
export const axiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Auth telegram
         * @param {authTelegram1VEnum} v Version
         * @param {authTelegram1LanguageEnum} language Current language
         * @param {number} authDate Time auth
         * @param {number} id Telegram userId
         * @param {string} firstName First name
         * @param {string} hash Hash
         * @param {authTelegram1AppEnum} app App oauth
         * @param {string} [lastName] Last name
         * @param {string} [username] Nickname
         * @param {string} [photoUrl] Photo
         * @param {string} [languageCode] IETF language tag of the user\&#39;s language
         * @param {boolean} [isPremium] True, if this user is a Telegram Premium user
         * @param {boolean} [addedToAttachmentMenu] True, if this user added the bot to the attachment menu
         * @param {string} [refId] Referal id
         * @param {string} [redirect] Redirect url
         * @param {string} [country] Country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTelegram1: async (v: authTelegram1VEnum, language: authTelegram1LanguageEnum, authDate: number, id: number, firstName: string, hash: string, app: authTelegram1AppEnum, lastName?: string, username?: string, photoUrl?: string, languageCode?: string, isPremium?: boolean, addedToAttachmentMenu?: boolean, refId?: string, redirect?: string, country?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('authTelegram1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('authTelegram1', 'language', language)
            // verify required parameter 'authDate' is not null or undefined
            assertParamExists('authTelegram1', 'authDate', authDate)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authTelegram1', 'id', id)
            // verify required parameter 'firstName' is not null or undefined
            assertParamExists('authTelegram1', 'firstName', firstName)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('authTelegram1', 'hash', hash)
            // verify required parameter 'app' is not null or undefined
            assertParamExists('authTelegram1', 'app', app)
            const localVarPath = `/method/auth/auth-telegram`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (authDate !== undefined) {
                localVarQueryParameter['auth_date'] = authDate;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['first_name'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['last_name'] = lastName;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (photoUrl !== undefined) {
                localVarQueryParameter['photo_url'] = photoUrl;
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            if (isPremium !== undefined) {
                localVarQueryParameter['is_premium'] = isPremium;
            }

            if (addedToAttachmentMenu !== undefined) {
                localVarQueryParameter['added_to_attachment_menu'] = addedToAttachmentMenu;
            }

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }

            if (refId !== undefined) {
                localVarQueryParameter['refId'] = refId;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Internal request of auth google
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callbackGoogle1: async (state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'state' is not null or undefined
            assertParamExists('callbackGoogle1', 'state', state)
            const localVarPath = `/method/auth/callback/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Internal request of auth old vk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callbackVk1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/method/auth/callback/vk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Internal request of auth new vk
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callbackVkId1: async (state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'state' is not null or undefined
            assertParamExists('callbackVkId1', 'state', state)
            const localVarPath = `/method/auth/callback/vk-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get code for auth
         * @param {code1VEnum} v Version
         * @param {code1LanguageEnum} language Current language
         * @param {code1AppEnum} app Create auth code for app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        code1: async (v: code1VEnum, language: code1LanguageEnum, app: code1AppEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('code1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('code1', 'language', language)
            // verify required parameter 'app' is not null or undefined
            assertParamExists('code1', 'app', app)
            const localVarPath = `/method/auth/app/code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Connected social account
         * @param {connect1VEnum} v Version
         * @param {connect1LanguageEnum} language Current language
         * @param {connect1ProviderEnum} provider Provider oauth
         * @param {connect1AppEnum} [app] App oauth
         * @param {string} [redirect] Redirect url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connect1: async (v: connect1VEnum, language: connect1LanguageEnum, provider: connect1ProviderEnum, app?: connect1AppEnum, redirect?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('connect1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('connect1', 'language', language)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('connect1', 'provider', provider)
            const localVarPath = `/method/auth/connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary CallBack for connect social
         * @param {connectResult1VEnum} v Version
         * @param {connectResult1LanguageEnum} language Current language
         * @param {string} message Result message for connect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectResult1: async (v: connectResult1VEnum, language: connectResult1LanguageEnum, message: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('connectResult1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('connectResult1', 'language', language)
            // verify required parameter 'message' is not null or undefined
            assertParamExists('connectResult1', 'message', message)
            const localVarPath = `/method/auth/connect/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (message !== undefined) {
                localVarQueryParameter['message'] = message;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Connect telegram in account
         * @param {connectTelegram1VEnum} v Version
         * @param {connectTelegram1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectTelegram1: async (v: connectTelegram1VEnum, language: connectTelegram1LanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('connectTelegram1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('connectTelegram1', 'language', language)
            const localVarPath = `/method/auth/connect-telegram`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disconnected social account
         * @param {disconnect1VEnum} v Version
         * @param {disconnect1LanguageEnum} language Current language
         * @param {number} socialId Social id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnect1: async (v: disconnect1VEnum, language: disconnect1LanguageEnum, socialId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('disconnect1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('disconnect1', 'language', language)
            // verify required parameter 'socialId' is not null or undefined
            assertParamExists('disconnect1', 'socialId', socialId)
            const localVarPath = `/method/auth/disconnect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (socialId !== undefined) {
                localVarQueryParameter['social_id'] = socialId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Code exchange
         * @param {SiteAuthExchangeRequest} siteAuthExchangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchange1: async (siteAuthExchangeRequest: SiteAuthExchangeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteAuthExchangeRequest' is not null or undefined
            assertParamExists('exchange1', 'siteAuthExchangeRequest', siteAuthExchangeRequest)
            const localVarPath = `/method/auth/app/exchange`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteAuthExchangeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get url for start oauth
         * @param {getAuthUrl1VEnum} v Version
         * @param {getAuthUrl1LanguageEnum} language Current language
         * @param {getAuthUrl1ProviderEnum} provider Provider oauth
         * @param {getAuthUrl1AppEnum} [app] App oauth
         * @param {string} [redirect] Redirect url
         * @param {string} [refId] Referal id
         * @param {string} [country] Country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthUrl1: async (v: getAuthUrl1VEnum, language: getAuthUrl1LanguageEnum, provider: getAuthUrl1ProviderEnum, app?: getAuthUrl1AppEnum, redirect?: string, refId?: string, country?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('getAuthUrl1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAuthUrl1', 'language', language)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('getAuthUrl1', 'provider', provider)
            const localVarPath = `/method/auth/redirect-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }

            if (refId !== undefined) {
                localVarQueryParameter['refId'] = refId;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get basic data for auth user
         * @param {getProfile1VEnum} v Version
         * @param {getProfile1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile1: async (v: getProfile1VEnum, language: getProfile1LanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('getProfile1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getProfile1', 'language', language)
            const localVarPath = `/method/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Guest request of auth
         * @param {string} refId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guest1: async (refId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refId' is not null or undefined
            assertParamExists('guest1', 'refId', refId)
            const localVarPath = `/method/auth/guest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (refId !== undefined) {
                localVarQueryParameter['refId'] = refId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout
         * @param {SiteLogoutAuthRequest} siteLogoutAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout1: async (siteLogoutAuthRequest: SiteLogoutAuthRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteLogoutAuthRequest' is not null or undefined
            assertParamExists('logout1', 'siteLogoutAuthRequest', siteLogoutAuthRequest)
            const localVarPath = `/method/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteLogoutAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update access token
         * @param {string} userAgent 
         * @param {SiteRefreshAuthBodyRequest} siteRefreshAuthBodyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccess1: async (userAgent: string, siteRefreshAuthBodyRequest: SiteRefreshAuthBodyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAgent' is not null or undefined
            assertParamExists('refreshAccess1', 'userAgent', userAgent)
            // verify required parameter 'siteRefreshAuthBodyRequest' is not null or undefined
            assertParamExists('refreshAccess1', 'siteRefreshAuthBodyRequest', siteRefreshAuthBodyRequest)
            const localVarPath = `/method/auth/refresh-access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (userAgent != null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteRefreshAuthBodyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const fp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = axiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Auth telegram
         * @param {authTelegram1VEnum} v Version
         * @param {authTelegram1LanguageEnum} language Current language
         * @param {number} authDate Time auth
         * @param {number} id Telegram userId
         * @param {string} firstName First name
         * @param {string} hash Hash
         * @param {authTelegram1AppEnum} app App oauth
         * @param {string} [lastName] Last name
         * @param {string} [username] Nickname
         * @param {string} [photoUrl] Photo
         * @param {string} [languageCode] IETF language tag of the user\&#39;s language
         * @param {boolean} [isPremium] True, if this user is a Telegram Premium user
         * @param {boolean} [addedToAttachmentMenu] True, if this user added the bot to the attachment menu
         * @param {string} [refId] Referal id
         * @param {string} [redirect] Redirect url
         * @param {string} [country] Country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTelegram1(v: authTelegram1VEnum, language: authTelegram1LanguageEnum, authDate: number, id: number, firstName: string, hash: string, app: authTelegram1AppEnum, lastName?: string, username?: string, photoUrl?: string, languageCode?: string, isPremium?: boolean, addedToAttachmentMenu?: boolean, refId?: string, redirect?: string, country?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTelegram1(v, language, authDate, id, firstName, hash, app, lastName, username, photoUrl, languageCode, isPremium, addedToAttachmentMenu, refId, redirect, country, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authTelegram1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Internal request of auth google
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callbackGoogle1(state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callbackGoogle1(state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.callbackGoogle1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Internal request of auth old vk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callbackVk1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callbackVk1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.callbackVk1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Internal request of auth new vk
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callbackVkId1(state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callbackVkId1(state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.callbackVkId1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get code for auth
         * @param {code1VEnum} v Version
         * @param {code1LanguageEnum} language Current language
         * @param {code1AppEnum} app Create auth code for app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async code1(v: code1VEnum, language: code1LanguageEnum, app: code1AppEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodeAppAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.code1(v, language, app, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.code1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Connected social account
         * @param {connect1VEnum} v Version
         * @param {connect1LanguageEnum} language Current language
         * @param {connect1ProviderEnum} provider Provider oauth
         * @param {connect1AppEnum} [app] App oauth
         * @param {string} [redirect] Redirect url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connect1(v: connect1VEnum, language: connect1LanguageEnum, provider: connect1ProviderEnum, app?: connect1AppEnum, redirect?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connect1(v, language, provider, app, redirect, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.connect1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary CallBack for connect social
         * @param {connectResult1VEnum} v Version
         * @param {connectResult1LanguageEnum} language Current language
         * @param {string} message Result message for connect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectResult1(v: connectResult1VEnum, language: connectResult1LanguageEnum, message: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectResult1(v, language, message, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.connectResult1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Connect telegram in account
         * @param {connectTelegram1VEnum} v Version
         * @param {connectTelegram1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectTelegram1(v: connectTelegram1VEnum, language: connectTelegram1LanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectTelegram1(v, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.connectTelegram1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Disconnected social account
         * @param {disconnect1VEnum} v Version
         * @param {disconnect1LanguageEnum} language Current language
         * @param {number} socialId Social id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disconnect1(v: disconnect1VEnum, language: disconnect1LanguageEnum, socialId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disconnect1(v, language, socialId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.disconnect1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Code exchange
         * @param {SiteAuthExchangeRequest} siteAuthExchangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exchange1(siteAuthExchangeRequest: SiteAuthExchangeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exchange1(siteAuthExchangeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.exchange1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get url for start oauth
         * @param {getAuthUrl1VEnum} v Version
         * @param {getAuthUrl1LanguageEnum} language Current language
         * @param {getAuthUrl1ProviderEnum} provider Provider oauth
         * @param {getAuthUrl1AppEnum} [app] App oauth
         * @param {string} [redirect] Redirect url
         * @param {string} [refId] Referal id
         * @param {string} [country] Country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthUrl1(v: getAuthUrl1VEnum, language: getAuthUrl1LanguageEnum, provider: getAuthUrl1ProviderEnum, app?: getAuthUrl1AppEnum, redirect?: string, refId?: string, country?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthUrl1(v, language, provider, app, redirect, refId, country, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getAuthUrl1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get basic data for auth user
         * @param {getProfile1VEnum} v Version
         * @param {getProfile1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile1(v: getProfile1VEnum, language: getProfile1LanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile1(v, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getProfile1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Guest request of auth
         * @param {string} refId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guest1(refId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guest1(refId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.guest1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout
         * @param {SiteLogoutAuthRequest} siteLogoutAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout1(siteLogoutAuthRequest: SiteLogoutAuthRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout1(siteLogoutAuthRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.logout1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update access token
         * @param {string} userAgent 
         * @param {SiteRefreshAuthBodyRequest} siteRefreshAuthBodyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshAccess1(userAgent: string, siteRefreshAuthBodyRequest: SiteRefreshAuthBodyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAccess1(userAgent, siteRefreshAuthBodyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refreshAccess1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const factory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = fp(configuration)
    return {
        /**
         * 
         * @summary Auth telegram
         * @param {authTelegram1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTelegram1(requestParameters: authTelegram1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            //         
            const actualV: authTelegram1VEnum = requestParameters.v || authTelegram1VEnum._1;
            return localVarFp.authTelegram1(actualV, requestParameters.language, requestParameters.authDate, requestParameters.id, requestParameters.firstName, requestParameters.hash, requestParameters.app, requestParameters.lastName, requestParameters.username, requestParameters.photoUrl, requestParameters.languageCode, requestParameters.isPremium, requestParameters.addedToAttachmentMenu, requestParameters.refId, requestParameters.redirect, requestParameters.country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Internal request of auth google
         * @param {callbackGoogle1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callbackGoogle1(requestParameters: callbackGoogle1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.callbackGoogle1(requestParameters.state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Internal request of auth old vk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callbackVk1(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.callbackVk1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Internal request of auth new vk
         * @param {callbackVkId1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callbackVkId1(requestParameters: callbackVkId1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.callbackVkId1(requestParameters.state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get code for auth
         * @param {code1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        code1(requestParameters: code1Request, options?: RawAxiosRequestConfig): AxiosPromise<CodeAppAuthResponse> {
            //         
            const actualV: code1VEnum = requestParameters.v || code1VEnum._1;
            return localVarFp.code1(actualV, requestParameters.language, requestParameters.app, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Connected social account
         * @param {connect1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connect1(requestParameters: connect1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            //         
            const actualV: connect1VEnum = requestParameters.v || connect1VEnum._1;
            return localVarFp.connect1(actualV, requestParameters.language, requestParameters.provider, requestParameters.app, requestParameters.redirect, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary CallBack for connect social
         * @param {connectResult1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectResult1(requestParameters: connectResult1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            //         
            const actualV: connectResult1VEnum = requestParameters.v || connectResult1VEnum._1;
            return localVarFp.connectResult1(actualV, requestParameters.language, requestParameters.message, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Connect telegram in account
         * @param {connectTelegram1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectTelegram1(requestParameters: connectTelegram1Request, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            //         
            const actualV: connectTelegram1VEnum = requestParameters.v || connectTelegram1VEnum._1;
            return localVarFp.connectTelegram1(actualV, requestParameters.language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disconnected social account
         * @param {disconnect1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnect1(requestParameters: disconnect1Request, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            //         
            const actualV: disconnect1VEnum = requestParameters.v || disconnect1VEnum._1;
            return localVarFp.disconnect1(actualV, requestParameters.language, requestParameters.socialId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Code exchange
         * @param {exchange1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchange1(requestParameters: exchange1Request, options?: RawAxiosRequestConfig): AxiosPromise<RefreshAuthResponse> {
            return localVarFp.exchange1(requestParameters.siteAuthExchangeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get url for start oauth
         * @param {getAuthUrl1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthUrl1(requestParameters: getAuthUrl1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            //         
            const actualV: getAuthUrl1VEnum = requestParameters.v || getAuthUrl1VEnum._1;
            return localVarFp.getAuthUrl1(actualV, requestParameters.language, requestParameters.provider, requestParameters.app, requestParameters.redirect, requestParameters.refId, requestParameters.country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get basic data for auth user
         * @param {getProfile1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile1(requestParameters: getProfile1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            //         
            const actualV: getProfile1VEnum = requestParameters.v || getProfile1VEnum._1;
            return localVarFp.getProfile1(actualV, requestParameters.language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Guest request of auth
         * @param {guest1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guest1(requestParameters: guest1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.guest1(requestParameters.refId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout
         * @param {logout1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout1(requestParameters: logout1Request, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.logout1(requestParameters.siteLogoutAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update access token
         * @param {refreshAccess1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccess1(requestParameters: refreshAccess1Request, options?: RawAxiosRequestConfig): AxiosPromise<RefreshAuthResponse> {
            return localVarFp.refreshAccess1(requestParameters.userAgent, requestParameters.siteRefreshAuthBodyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authTelegram1 operation in AuthApi.
 * @export
 * @interface authTelegram1Request
 */
export interface authTelegram1Request {
    /**
     * Version
     * @type {'1' | '2' | '3'}
     * @memberof authTelegram1
     */
    readonly v?: authTelegram1VEnum

    /**
     * Current language
     * @type {'ru' | 'en' | 'cn'}
     * @memberof authTelegram1
     */
    readonly language: authTelegram1LanguageEnum

    /**
     * Time auth
     * @type {number}
     * @memberof authTelegram1
     */
    readonly authDate: number

    /**
     * Telegram userId
     * @type {number}
     * @memberof authTelegram1
     */
    readonly id: number

    /**
     * First name
     * @type {string}
     * @memberof authTelegram1
     */
    readonly firstName: string

    /**
     * Hash
     * @type {string}
     * @memberof authTelegram1
     */
    readonly hash: string

    /**
     * App oauth
     * @type {'site' | 'admin' | 'mobile' | 'desktop'}
     * @memberof authTelegram1
     */
    readonly app: authTelegram1AppEnum

    /**
     * Last name
     * @type {string}
     * @memberof authTelegram1
     */
    readonly lastName?: string

    /**
     * Nickname
     * @type {string}
     * @memberof authTelegram1
     */
    readonly username?: string

    /**
     * Photo
     * @type {string}
     * @memberof authTelegram1
     */
    readonly photoUrl?: string

    /**
     * IETF language tag of the user\&#39;s language
     * @type {string}
     * @memberof authTelegram1
     */
    readonly languageCode?: string

    /**
     * True, if this user is a Telegram Premium user
     * @type {boolean}
     * @memberof authTelegram1
     */
    readonly isPremium?: boolean

    /**
     * True, if this user added the bot to the attachment menu
     * @type {boolean}
     * @memberof authTelegram1
     */
    readonly addedToAttachmentMenu?: boolean

    /**
     * Referal id
     * @type {string}
     * @memberof authTelegram1
     */
    readonly refId?: string

    /**
     * Redirect url
     * @type {string}
     * @memberof authTelegram1
     */
    readonly redirect?: string

    /**
     * Country code
     * @type {string}
     * @memberof authTelegram1
     */
    readonly country?: string
}

/**
 * Request parameters for callbackGoogle1 operation in AuthApi.
 * @export
 * @interface callbackGoogle1Request
 */
export interface callbackGoogle1Request {
    /**
     * 
     * @type {string}
     * @memberof callbackGoogle1
     */
    readonly state: string
}

/**
 * Request parameters for callbackVkId1 operation in AuthApi.
 * @export
 * @interface callbackVkId1Request
 */
export interface callbackVkId1Request {
    /**
     * 
     * @type {string}
     * @memberof callbackVkId1
     */
    readonly state: string
}

/**
 * Request parameters for code1 operation in AuthApi.
 * @export
 * @interface code1Request
 */
export interface code1Request {
    /**
     * Version
     * @type {'1' | '2' | '3'}
     * @memberof code1
     */
    readonly v?: code1VEnum

    /**
     * Current language
     * @type {'ru' | 'en' | 'cn'}
     * @memberof code1
     */
    readonly language: code1LanguageEnum

    /**
     * Create auth code for app
     * @type {'site' | 'admin' | 'mobile' | 'desktop'}
     * @memberof code1
     */
    readonly app: code1AppEnum
}

/**
 * Request parameters for connect1 operation in AuthApi.
 * @export
 * @interface connect1Request
 */
export interface connect1Request {
    /**
     * Version
     * @type {'1' | '2' | '3'}
     * @memberof connect1
     */
    readonly v?: connect1VEnum

    /**
     * Current language
     * @type {'ru' | 'en' | 'cn'}
     * @memberof connect1
     */
    readonly language: connect1LanguageEnum

    /**
     * Provider oauth
     * @type {'google' | 'vk' | 'vk-id' | 'telegram'}
     * @memberof connect1
     */
    readonly provider: connect1ProviderEnum

    /**
     * App oauth
     * @type {'site' | 'admin' | 'mobile' | 'desktop'}
     * @memberof connect1
     */
    readonly app?: connect1AppEnum

    /**
     * Redirect url
     * @type {string}
     * @memberof connect1
     */
    readonly redirect?: string
}

/**
 * Request parameters for connectResult1 operation in AuthApi.
 * @export
 * @interface connectResult1Request
 */
export interface connectResult1Request {
    /**
     * Version
     * @type {'1' | '2' | '3'}
     * @memberof connectResult1
     */
    readonly v?: connectResult1VEnum

    /**
     * Current language
     * @type {'ru' | 'en' | 'cn'}
     * @memberof connectResult1
     */
    readonly language: connectResult1LanguageEnum

    /**
     * Result message for connect
     * @type {string}
     * @memberof connectResult1
     */
    readonly message: string
}

/**
 * Request parameters for connectTelegram1 operation in AuthApi.
 * @export
 * @interface connectTelegram1Request
 */
export interface connectTelegram1Request {
    /**
     * Version
     * @type {'1' | '2' | '3'}
     * @memberof connectTelegram1
     */
    readonly v?: connectTelegram1VEnum

    /**
     * Current language
     * @type {'ru' | 'en' | 'cn'}
     * @memberof connectTelegram1
     */
    readonly language: connectTelegram1LanguageEnum
}

/**
 * Request parameters for disconnect1 operation in AuthApi.
 * @export
 * @interface disconnect1Request
 */
export interface disconnect1Request {
    /**
     * Version
     * @type {'1' | '2' | '3'}
     * @memberof disconnect1
     */
    readonly v?: disconnect1VEnum

    /**
     * Current language
     * @type {'ru' | 'en' | 'cn'}
     * @memberof disconnect1
     */
    readonly language: disconnect1LanguageEnum

    /**
     * Social id
     * @type {number}
     * @memberof disconnect1
     */
    readonly socialId: number
}

/**
 * Request parameters for exchange1 operation in AuthApi.
 * @export
 * @interface exchange1Request
 */
export interface exchange1Request {
    /**
     * 
     * @type {SiteAuthExchangeRequest}
     * @memberof exchange1
     */
    readonly siteAuthExchangeRequest: SiteAuthExchangeRequest
}

/**
 * Request parameters for getAuthUrl1 operation in AuthApi.
 * @export
 * @interface getAuthUrl1Request
 */
export interface getAuthUrl1Request {
    /**
     * Version
     * @type {'1' | '2' | '3'}
     * @memberof getAuthUrl1
     */
    readonly v?: getAuthUrl1VEnum

    /**
     * Current language
     * @type {'ru' | 'en' | 'cn'}
     * @memberof getAuthUrl1
     */
    readonly language: getAuthUrl1LanguageEnum

    /**
     * Provider oauth
     * @type {'google' | 'vk' | 'vk-id' | 'telegram'}
     * @memberof getAuthUrl1
     */
    readonly provider: getAuthUrl1ProviderEnum

    /**
     * App oauth
     * @type {'site' | 'admin' | 'mobile' | 'desktop'}
     * @memberof getAuthUrl1
     */
    readonly app?: getAuthUrl1AppEnum

    /**
     * Redirect url
     * @type {string}
     * @memberof getAuthUrl1
     */
    readonly redirect?: string

    /**
     * Referal id
     * @type {string}
     * @memberof getAuthUrl1
     */
    readonly refId?: string

    /**
     * Country code
     * @type {string}
     * @memberof getAuthUrl1
     */
    readonly country?: string
}

/**
 * Request parameters for getProfile1 operation in AuthApi.
 * @export
 * @interface getProfile1Request
 */
export interface getProfile1Request {
    /**
     * Version
     * @type {'1' | '2' | '3'}
     * @memberof getProfile1
     */
    readonly v?: getProfile1VEnum

    /**
     * Current language
     * @type {'ru' | 'en' | 'cn'}
     * @memberof getProfile1
     */
    readonly language: getProfile1LanguageEnum
}

/**
 * Request parameters for guest1 operation in AuthApi.
 * @export
 * @interface guest1Request
 */
export interface guest1Request {
    /**
     * 
     * @type {string}
     * @memberof guest1
     */
    readonly refId: string
}

/**
 * Request parameters for logout1 operation in AuthApi.
 * @export
 * @interface logout1Request
 */
export interface logout1Request {
    /**
     * 
     * @type {SiteLogoutAuthRequest}
     * @memberof logout1
     */
    readonly siteLogoutAuthRequest: SiteLogoutAuthRequest
}

/**
 * Request parameters for refreshAccess1 operation in AuthApi.
 * @export
 * @interface refreshAccess1Request
 */
export interface refreshAccess1Request {
    /**
     * 
     * @type {string}
     * @memberof refreshAccess1
     */
    readonly userAgent: string

    /**
     * 
     * @type {SiteRefreshAuthBodyRequest}
     * @memberof refreshAccess1
     */
    readonly siteRefreshAuthBodyRequest: SiteRefreshAuthBodyRequest
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Auth telegram
     * @param {authTelegram1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTelegram1(requestParameters: authTelegram1Request, options?: RawAxiosRequestConfig) {
        //         
        const actualV: authTelegram1VEnum = requestParameters.v || authTelegram1VEnum._1;
        return fp(this.configuration).authTelegram1(actualV, requestParameters.language, requestParameters.authDate, requestParameters.id, requestParameters.firstName, requestParameters.hash, requestParameters.app, requestParameters.lastName, requestParameters.username, requestParameters.photoUrl, requestParameters.languageCode, requestParameters.isPremium, requestParameters.addedToAttachmentMenu, requestParameters.refId, requestParameters.redirect, requestParameters.country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Internal request of auth google
     * @param {callbackGoogle1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public callbackGoogle1(requestParameters: callbackGoogle1Request, options?: RawAxiosRequestConfig) {
        return fp(this.configuration).callbackGoogle1(requestParameters.state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Internal request of auth old vk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public callbackVk1(options?: RawAxiosRequestConfig) {
        return fp(this.configuration).callbackVk1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Internal request of auth new vk
     * @param {callbackVkId1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public callbackVkId1(requestParameters: callbackVkId1Request, options?: RawAxiosRequestConfig) {
        return fp(this.configuration).callbackVkId1(requestParameters.state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get code for auth
     * @param {code1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public code1(requestParameters: code1Request, options?: RawAxiosRequestConfig) {
        //         
        const actualV: code1VEnum = requestParameters.v || code1VEnum._1;
        return fp(this.configuration).code1(actualV, requestParameters.language, requestParameters.app, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Connected social account
     * @param {connect1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public connect1(requestParameters: connect1Request, options?: RawAxiosRequestConfig) {
        //         
        const actualV: connect1VEnum = requestParameters.v || connect1VEnum._1;
        return fp(this.configuration).connect1(actualV, requestParameters.language, requestParameters.provider, requestParameters.app, requestParameters.redirect, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary CallBack for connect social
     * @param {connectResult1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public connectResult1(requestParameters: connectResult1Request, options?: RawAxiosRequestConfig) {
        //         
        const actualV: connectResult1VEnum = requestParameters.v || connectResult1VEnum._1;
        return fp(this.configuration).connectResult1(actualV, requestParameters.language, requestParameters.message, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Connect telegram in account
     * @param {connectTelegram1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public connectTelegram1(requestParameters: connectTelegram1Request, options?: RawAxiosRequestConfig) {
        //         
        const actualV: connectTelegram1VEnum = requestParameters.v || connectTelegram1VEnum._1;
        return fp(this.configuration).connectTelegram1(actualV, requestParameters.language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disconnected social account
     * @param {disconnect1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public disconnect1(requestParameters: disconnect1Request, options?: RawAxiosRequestConfig) {
        //         
        const actualV: disconnect1VEnum = requestParameters.v || disconnect1VEnum._1;
        return fp(this.configuration).disconnect1(actualV, requestParameters.language, requestParameters.socialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Code exchange
     * @param {exchange1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public exchange1(requestParameters: exchange1Request, options?: RawAxiosRequestConfig) {
        return fp(this.configuration).exchange1(requestParameters.siteAuthExchangeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get url for start oauth
     * @param {getAuthUrl1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAuthUrl1(requestParameters: getAuthUrl1Request, options?: RawAxiosRequestConfig) {
        //         
        const actualV: getAuthUrl1VEnum = requestParameters.v || getAuthUrl1VEnum._1;
        return fp(this.configuration).getAuthUrl1(actualV, requestParameters.language, requestParameters.provider, requestParameters.app, requestParameters.redirect, requestParameters.refId, requestParameters.country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get basic data for auth user
     * @param {getProfile1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getProfile1(requestParameters: getProfile1Request, options?: RawAxiosRequestConfig) {
        //         
        const actualV: getProfile1VEnum = requestParameters.v || getProfile1VEnum._1;
        return fp(this.configuration).getProfile1(actualV, requestParameters.language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Guest request of auth
     * @param {guest1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public guest1(requestParameters: guest1Request, options?: RawAxiosRequestConfig) {
        return fp(this.configuration).guest1(requestParameters.refId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout
     * @param {logout1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout1(requestParameters: logout1Request, options?: RawAxiosRequestConfig) {
        return fp(this.configuration).logout1(requestParameters.siteLogoutAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update access token
     * @param {refreshAccess1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshAccess1(requestParameters: refreshAccess1Request, options?: RawAxiosRequestConfig) {
        return fp(this.configuration).refreshAccess1(requestParameters.userAgent, requestParameters.siteRefreshAuthBodyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum authTelegram1VEnum {
    _1 = '1',
    _2 = '2',
    _3 = '3'
}
/**
  * @export
  * @enum {string}
  */
export enum authTelegram1LanguageEnum {
    ru = 'ru',
    en = 'en',
    cn = 'cn'
}
/**
  * @export
  * @enum {string}
  */
export enum authTelegram1AppEnum {
    site = 'site',
    admin = 'admin',
    mobile = 'mobile',
    desktop = 'desktop'
}
/**
  * @export
  * @enum {string}
  */
export enum code1VEnum {
    _1 = '1',
    _2 = '2',
    _3 = '3'
}
/**
  * @export
  * @enum {string}
  */
export enum code1LanguageEnum {
    ru = 'ru',
    en = 'en',
    cn = 'cn'
}
/**
  * @export
  * @enum {string}
  */
export enum code1AppEnum {
    site = 'site',
    admin = 'admin',
    mobile = 'mobile',
    desktop = 'desktop'
}
/**
  * @export
  * @enum {string}
  */
export enum connect1VEnum {
    _1 = '1',
    _2 = '2',
    _3 = '3'
}
/**
  * @export
  * @enum {string}
  */
export enum connect1LanguageEnum {
    ru = 'ru',
    en = 'en',
    cn = 'cn'
}
/**
  * @export
  * @enum {string}
  */
export enum connect1ProviderEnum {
    google = 'google',
    vk = 'vk',
    vk_id = 'vk-id',
    telegram = 'telegram'
}
/**
  * @export
  * @enum {string}
  */
export enum connect1AppEnum {
    site = 'site',
    admin = 'admin',
    mobile = 'mobile',
    desktop = 'desktop'
}
/**
  * @export
  * @enum {string}
  */
export enum connectResult1VEnum {
    _1 = '1',
    _2 = '2',
    _3 = '3'
}
/**
  * @export
  * @enum {string}
  */
export enum connectResult1LanguageEnum {
    ru = 'ru',
    en = 'en',
    cn = 'cn'
}
/**
  * @export
  * @enum {string}
  */
export enum connectTelegram1VEnum {
    _1 = '1',
    _2 = '2',
    _3 = '3'
}
/**
  * @export
  * @enum {string}
  */
export enum connectTelegram1LanguageEnum {
    ru = 'ru',
    en = 'en',
    cn = 'cn'
}
/**
  * @export
  * @enum {string}
  */
export enum disconnect1VEnum {
    _1 = '1',
    _2 = '2',
    _3 = '3'
}
/**
  * @export
  * @enum {string}
  */
export enum disconnect1LanguageEnum {
    ru = 'ru',
    en = 'en',
    cn = 'cn'
}
/**
  * @export
  * @enum {string}
  */
export enum getAuthUrl1VEnum {
    _1 = '1',
    _2 = '2',
    _3 = '3'
}
/**
  * @export
  * @enum {string}
  */
export enum getAuthUrl1LanguageEnum {
    ru = 'ru',
    en = 'en',
    cn = 'cn'
}
/**
  * @export
  * @enum {string}
  */
export enum getAuthUrl1ProviderEnum {
    google = 'google',
    vk = 'vk',
    vk_id = 'vk-id',
    telegram = 'telegram'
}
/**
  * @export
  * @enum {string}
  */
export enum getAuthUrl1AppEnum {
    site = 'site',
    admin = 'admin',
    mobile = 'mobile',
    desktop = 'desktop'
}
/**
  * @export
  * @enum {string}
  */
export enum getProfile1VEnum {
    _1 = '1',
    _2 = '2',
    _3 = '3'
}
/**
  * @export
  * @enum {string}
  */
export enum getProfile1LanguageEnum {
    ru = 'ru',
    en = 'en',
    cn = 'cn'
}
