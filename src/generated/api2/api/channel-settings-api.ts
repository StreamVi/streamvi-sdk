/* tslint:disable */
/* eslint-disable */
/**
 * StreamVi Backend
 * API
 *
 * The version of the OpenAPI document: 3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, keyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { ErrorResponse } from '../models';
// @ts-ignore
import type { ListOfPlaylistItemResponse } from '../models';
// @ts-ignore
import type { ListOfSitePlannedResponse } from '../models';
// @ts-ignore
import type { SiteChannelStatusResponse } from '../models';
// @ts-ignore
import type { SitePlannedResponse } from '../models';
// @ts-ignore
import type { SiteSetNameRequest } from '../models';
// @ts-ignore
import type { SiteSetPlannedRequest } from '../models';
// @ts-ignore
import type { SiteSetTranscoderRequest } from '../models';
// @ts-ignore
import type { SiteSetUrlRequest } from '../models';
// @ts-ignore
import type { SiteTelegramChatPostsItem } from '../models';
// @ts-ignore
import type { SiteTelegramChatPostsResponseDto } from '../models';
// @ts-ignore
import type { SiteTelegramSetSettingsRequestDto } from '../models';
// @ts-ignore
import type { SiteUpdateChatTelegramRequest } from '../models';
// @ts-ignore
import type { SiteUpdateOptionsOkRequest } from '../models';
// @ts-ignore
import type { SiteUpdateOptionsTrovoRequest } from '../models';
// @ts-ignore
import type { SiteUpdateOptionsTwitchRequest } from '../models';
// @ts-ignore
import type { SiteUpdateOptionsVkRequest } from '../models';
// @ts-ignore
import type { SiteUpdateOptionsVkVideoLiveRequest } from '../models';
// @ts-ignore
import type { SiteUpdateOptionsYoutubeRequest } from '../models';
// @ts-ignore
import type { SuccessResponse } from '../models';
// @ts-ignore
import type { TelegramInitConnectResponseDto } from '../models';
// @ts-ignore
import type { TelegramSettingsResponseDto } from '../models';
/**
 * ChannelSettingsApi - axios parameter creator
 * @export
 */
export const axiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get telegram settings
         * @param {getTelegramSetting1VEnum} v Version
         * @param {getTelegramSetting1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegramSetting1: async (v: getTelegramSetting1VEnum, language: getTelegramSetting1LanguageEnum, projectId: number, channelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('getTelegramSetting1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getTelegramSetting1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getTelegramSetting1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('getTelegramSetting1', 'channelId', channelId)
            const localVarPath = `/method/channel_settings/chat/telegram/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get code for connected chat
         * @param {initTelegramChatConnect1VEnum} v Version
         * @param {initTelegramChatConnect1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initTelegramChatConnect1: async (v: initTelegramChatConnect1VEnum, language: initTelegramChatConnect1LanguageEnum, projectId: number, channelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('initTelegramChatConnect1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('initTelegramChatConnect1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('initTelegramChatConnect1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('initTelegramChatConnect1', 'channelId', channelId)
            const localVarPath = `/method/channel_settings/chat/telegram/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disconnect telegram chat
         * @param {removeTelegramChat1VEnum} v Version
         * @param {removeTelegramChat1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTelegramChat1: async (v: removeTelegramChat1VEnum, language: removeTelegramChat1LanguageEnum, projectId: number, channelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('removeTelegramChat1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('removeTelegramChat1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('removeTelegramChat1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('removeTelegramChat1', 'channelId', channelId)
            const localVarPath = `/method/channel_settings/chat/telegram/disconnect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set telegram settings
         * @param {setTelegramSetting1VEnum} v Version
         * @param {setTelegramSetting1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {SiteTelegramSetSettingsRequestDto} siteTelegramSetSettingsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTelegramSetting1: async (v: setTelegramSetting1VEnum, language: setTelegramSetting1LanguageEnum, projectId: number, channelId: number, siteTelegramSetSettingsRequestDto: SiteTelegramSetSettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('setTelegramSetting1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('setTelegramSetting1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('setTelegramSetting1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('setTelegramSetting1', 'channelId', channelId)
            // verify required parameter 'siteTelegramSetSettingsRequestDto' is not null or undefined
            assertParamExists('setTelegramSetting1', 'siteTelegramSetSettingsRequestDto', siteTelegramSetSettingsRequestDto)
            const localVarPath = `/method/channel_settings/chat/telegram/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteTelegramSetSettingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get telegram post list
         * @param {telegramPosts1VEnum} v Version
         * @param {telegramPosts1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegramPosts1: async (v: telegramPosts1VEnum, language: telegramPosts1LanguageEnum, projectId: number, channelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('telegramPosts1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('telegramPosts1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('telegramPosts1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('telegramPosts1', 'channelId', channelId)
            const localVarPath = `/method/channel_settings/chat/telegram/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Optional settings for telegram
         * @param {SiteUpdateChatTelegramRequest} siteUpdateChatTelegramRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsTelegram1: async (siteUpdateChatTelegramRequest: SiteUpdateChatTelegramRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteUpdateChatTelegramRequest' is not null or undefined
            assertParamExists('updateOptionsTelegram1', 'siteUpdateChatTelegramRequest', siteUpdateChatTelegramRequest)
            const localVarPath = `/method/channel_settings/chat/setTelegram`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteUpdateChatTelegramRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get planned list
         * @param {getPlanned1VEnum} v Version
         * @param {getPlanned1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlanned1: async (v: getPlanned1VEnum, language: getPlanned1LanguageEnum, projectId: number, channelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('getPlanned1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getPlanned1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getPlanned1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('getPlanned1', 'channelId', channelId)
            const localVarPath = `/method/channel_settings/options/getPlanned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get playlists from the platform
         * @param {getPlayList1VEnum} v Version
         * @param {getPlayList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayList1: async (v: getPlayList1VEnum, language: getPlayList1LanguageEnum, projectId: number, channelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('getPlayList1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getPlayList1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getPlayList1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('getPlayList1', 'channelId', channelId)
            const localVarPath = `/method/channel_settings/options/getPlaylist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Optional settings for ok. Depends on the tariff.
         * @param {SiteUpdateOptionsOkRequest} siteUpdateOptionsOkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsOk1: async (siteUpdateOptionsOkRequest: SiteUpdateOptionsOkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteUpdateOptionsOkRequest' is not null or undefined
            assertParamExists('updateOptionsOk1', 'siteUpdateOptionsOkRequest', siteUpdateOptionsOkRequest)
            const localVarPath = `/method/channel_settings/options/setOk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteUpdateOptionsOkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Optional settings for trovo. Depends on the tariff.
         * @param {SiteUpdateOptionsTrovoRequest} siteUpdateOptionsTrovoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsTrovo1: async (siteUpdateOptionsTrovoRequest: SiteUpdateOptionsTrovoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteUpdateOptionsTrovoRequest' is not null or undefined
            assertParamExists('updateOptionsTrovo1', 'siteUpdateOptionsTrovoRequest', siteUpdateOptionsTrovoRequest)
            const localVarPath = `/method/channel_settings/options/setTrovo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteUpdateOptionsTrovoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Optional settings for twitch. Depends on the tariff.
         * @param {SiteUpdateOptionsTwitchRequest} siteUpdateOptionsTwitchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsTwitch1: async (siteUpdateOptionsTwitchRequest: SiteUpdateOptionsTwitchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteUpdateOptionsTwitchRequest' is not null or undefined
            assertParamExists('updateOptionsTwitch1', 'siteUpdateOptionsTwitchRequest', siteUpdateOptionsTwitchRequest)
            const localVarPath = `/method/channel_settings/options/setTwitch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteUpdateOptionsTwitchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Optional settings for vk. Depends on the tariff.
         * @param {SiteUpdateOptionsVkRequest} siteUpdateOptionsVkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsVk1: async (siteUpdateOptionsVkRequest: SiteUpdateOptionsVkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteUpdateOptionsVkRequest' is not null or undefined
            assertParamExists('updateOptionsVk1', 'siteUpdateOptionsVkRequest', siteUpdateOptionsVkRequest)
            const localVarPath = `/method/channel_settings/options/setVk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteUpdateOptionsVkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Optional settings for vk video live. Depends on the tariff.
         * @param {SiteUpdateOptionsVkVideoLiveRequest} siteUpdateOptionsVkVideoLiveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsVkVideoLive1: async (siteUpdateOptionsVkVideoLiveRequest: SiteUpdateOptionsVkVideoLiveRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteUpdateOptionsVkVideoLiveRequest' is not null or undefined
            assertParamExists('updateOptionsVkVideoLive1', 'siteUpdateOptionsVkVideoLiveRequest', siteUpdateOptionsVkVideoLiveRequest)
            const localVarPath = `/method/channel_settings/options/setVkVideoLive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteUpdateOptionsVkVideoLiveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Optional settings for youtube. Depends on the tariff.
         * @param {SiteUpdateOptionsYoutubeRequest} siteUpdateOptionsYoutubeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsYoutube1: async (siteUpdateOptionsYoutubeRequest: SiteUpdateOptionsYoutubeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteUpdateOptionsYoutubeRequest' is not null or undefined
            assertParamExists('updateOptionsYoutube1', 'siteUpdateOptionsYoutubeRequest', siteUpdateOptionsYoutubeRequest)
            const localVarPath = `/method/channel_settings/options/setYoutube`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteUpdateOptionsYoutubeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set planned id. Depends on the tariff.
         * @param {SiteSetPlannedRequest} siteSetPlannedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlanned1: async (siteSetPlannedRequest: SiteSetPlannedRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteSetPlannedRequest' is not null or undefined
            assertParamExists('updatePlanned1', 'siteSetPlannedRequest', siteSetPlannedRequest)
            const localVarPath = `/method/channel_settings/options/setPlanned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteSetPlannedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get status platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/method/channel_settings/getStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set name from custom channel. Global settings.
         * @param {SiteSetNameRequest} siteSetNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setName1: async (siteSetNameRequest: SiteSetNameRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteSetNameRequest' is not null or undefined
            assertParamExists('setName1', 'siteSetNameRequest', siteSetNameRequest)
            const localVarPath = `/method/channel_settings/setName`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteSetNameRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set rtmp url from channel. Global settings.
         * @param {SiteSetUrlRequest} siteSetUrlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRtmp1: async (siteSetUrlRequest: SiteSetUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteSetUrlRequest' is not null or undefined
            assertParamExists('updateRtmp1', 'siteSetUrlRequest', siteSetUrlRequest)
            const localVarPath = `/method/channel_settings/setRtmp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteSetUrlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get status platform
         * @param {updateToken1VEnum} v Version
         * @param {updateToken1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {updateToken1RoleEnum} role Token role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateToken1: async (v: updateToken1VEnum, language: updateToken1LanguageEnum, projectId: number, channelId: number, role: updateToken1RoleEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('updateToken1', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('updateToken1', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateToken1', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('updateToken1', 'channelId', channelId)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('updateToken1', 'role', role)
            const localVarPath = `/method/channel_settings/update-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set transcoder from channel. Personal settings.
         * @param {SiteSetTranscoderRequest} siteSetTranscoderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTranscoder1: async (siteSetTranscoderRequest: SiteSetTranscoderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteSetTranscoderRequest' is not null or undefined
            assertParamExists('updateTranscoder1', 'siteSetTranscoderRequest', siteSetTranscoderRequest)
            const localVarPath = `/method/channel_settings/setTranscoder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siteSetTranscoderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get telegram post by filter
         * @param {TelegramGetPostByFilterVEnum} v Version
         * @param {TelegramGetPostByFilterLanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {number} filterMode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegramGetPostByFilter: async (v: TelegramGetPostByFilterVEnum, language: TelegramGetPostByFilterLanguageEnum, projectId: number, channelId: number, filterMode: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v' is not null or undefined
            assertParamExists('telegramGetPostByFilter', 'v', v)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('telegramGetPostByFilter', 'language', language)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('telegramGetPostByFilter', 'projectId', projectId)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('telegramGetPostByFilter', 'channelId', channelId)
            // verify required parameter 'filterMode' is not null or undefined
            assertParamExists('telegramGetPostByFilter', 'filterMode', filterMode)
            const localVarPath = `/method/channel_settings/chat/telegram/posts/get-by-filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }

            if (filterMode !== undefined) {
                localVarQueryParameter['filter_mode'] = filterMode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelSettingsApi - functional programming interface
 * @export
 */
export const fp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = axiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get telegram settings
         * @param {getTelegramSetting1VEnum} v Version
         * @param {getTelegramSetting1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTelegramSetting1(v: getTelegramSetting1VEnum, language: getTelegramSetting1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TelegramSettingsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTelegramSetting1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.getTelegramSetting1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get code for connected chat
         * @param {initTelegramChatConnect1VEnum} v Version
         * @param {initTelegramChatConnect1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initTelegramChatConnect1(v: initTelegramChatConnect1VEnum, language: initTelegramChatConnect1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TelegramInitConnectResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initTelegramChatConnect1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.initTelegramChatConnect1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Disconnect telegram chat
         * @param {removeTelegramChat1VEnum} v Version
         * @param {removeTelegramChat1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTelegramChat1(v: removeTelegramChat1VEnum, language: removeTelegramChat1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTelegramChat1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.removeTelegramChat1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set telegram settings
         * @param {setTelegramSetting1VEnum} v Version
         * @param {setTelegramSetting1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {SiteTelegramSetSettingsRequestDto} siteTelegramSetSettingsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTelegramSetting1(v: setTelegramSetting1VEnum, language: setTelegramSetting1LanguageEnum, projectId: number, channelId: number, siteTelegramSetSettingsRequestDto: SiteTelegramSetSettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTelegramSetting1(v, language, projectId, channelId, siteTelegramSetSettingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.setTelegramSetting1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get telegram post list
         * @param {telegramPosts1VEnum} v Version
         * @param {telegramPosts1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async telegramPosts1(v: telegramPosts1VEnum, language: telegramPosts1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteTelegramChatPostsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.telegramPosts1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.telegramPosts1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Optional settings for telegram
         * @param {SiteUpdateChatTelegramRequest} siteUpdateChatTelegramRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOptionsTelegram1(siteUpdateChatTelegramRequest: SiteUpdateChatTelegramRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOptionsTelegram1(siteUpdateChatTelegramRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.updateOptionsTelegram1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get planned list
         * @param {getPlanned1VEnum} v Version
         * @param {getPlanned1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlanned1(v: getPlanned1VEnum, language: getPlanned1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOfSitePlannedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlanned1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.getPlanned1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get playlists from the platform
         * @param {getPlayList1VEnum} v Version
         * @param {getPlayList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayList1(v: getPlayList1VEnum, language: getPlayList1LanguageEnum, projectId: number, channelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOfPlaylistItemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayList1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.getPlayList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Optional settings for ok. Depends on the tariff.
         * @param {SiteUpdateOptionsOkRequest} siteUpdateOptionsOkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOptionsOk1(siteUpdateOptionsOkRequest: SiteUpdateOptionsOkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOptionsOk1(siteUpdateOptionsOkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.updateOptionsOk1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Optional settings for trovo. Depends on the tariff.
         * @param {SiteUpdateOptionsTrovoRequest} siteUpdateOptionsTrovoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOptionsTrovo1(siteUpdateOptionsTrovoRequest: SiteUpdateOptionsTrovoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOptionsTrovo1(siteUpdateOptionsTrovoRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.updateOptionsTrovo1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Optional settings for twitch. Depends on the tariff.
         * @param {SiteUpdateOptionsTwitchRequest} siteUpdateOptionsTwitchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOptionsTwitch1(siteUpdateOptionsTwitchRequest: SiteUpdateOptionsTwitchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOptionsTwitch1(siteUpdateOptionsTwitchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.updateOptionsTwitch1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Optional settings for vk. Depends on the tariff.
         * @param {SiteUpdateOptionsVkRequest} siteUpdateOptionsVkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOptionsVk1(siteUpdateOptionsVkRequest: SiteUpdateOptionsVkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOptionsVk1(siteUpdateOptionsVkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.updateOptionsVk1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Optional settings for vk video live. Depends on the tariff.
         * @param {SiteUpdateOptionsVkVideoLiveRequest} siteUpdateOptionsVkVideoLiveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOptionsVkVideoLive1(siteUpdateOptionsVkVideoLiveRequest: SiteUpdateOptionsVkVideoLiveRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOptionsVkVideoLive1(siteUpdateOptionsVkVideoLiveRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.updateOptionsVkVideoLive1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Optional settings for youtube. Depends on the tariff.
         * @param {SiteUpdateOptionsYoutubeRequest} siteUpdateOptionsYoutubeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOptionsYoutube1(siteUpdateOptionsYoutubeRequest: SiteUpdateOptionsYoutubeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOptionsYoutube1(siteUpdateOptionsYoutubeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.updateOptionsYoutube1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set planned id. Depends on the tariff.
         * @param {SiteSetPlannedRequest} siteSetPlannedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlanned1(siteSetPlannedRequest: SiteSetPlannedRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SitePlannedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlanned1(siteSetPlannedRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.updatePlanned1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get status platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteChannelStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.getStatus1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set name from custom channel. Global settings.
         * @param {SiteSetNameRequest} siteSetNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setName1(siteSetNameRequest: SiteSetNameRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setName1(siteSetNameRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.setName1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set rtmp url from channel. Global settings.
         * @param {SiteSetUrlRequest} siteSetUrlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRtmp1(siteSetUrlRequest: SiteSetUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRtmp1(siteSetUrlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.updateRtmp1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get status platform
         * @param {updateToken1VEnum} v Version
         * @param {updateToken1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {updateToken1RoleEnum} role Token role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateToken1(v: updateToken1VEnum, language: updateToken1LanguageEnum, projectId: number, channelId: number, role: updateToken1RoleEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateToken1(v, language, projectId, channelId, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.updateToken1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set transcoder from channel. Personal settings.
         * @param {SiteSetTranscoderRequest} siteSetTranscoderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTranscoder1(siteSetTranscoderRequest: SiteSetTranscoderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTranscoder1(siteSetTranscoderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.updateTranscoder1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get telegram post by filter
         * @param {TelegramGetPostByFilterVEnum} v Version
         * @param {TelegramGetPostByFilterLanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {number} filterMode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async telegramGetPostByFilter(v: TelegramGetPostByFilterVEnum, language: TelegramGetPostByFilterLanguageEnum, projectId: number, channelId: number, filterMode: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteTelegramChatPostsItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.telegramGetPostByFilter(v, language, projectId, channelId, filterMode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelSettingsApi.telegramGetPostByFilter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChannelSettingsApi - factory interface
 * @export
 */
export const factory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = fp(configuration)
    return {
        /**
         * 
         * @summary Get telegram settings
         * @param {getTelegramSetting1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegramSetting1(requestParameters: getTelegramSetting1Request, options?: RawAxiosRequestConfig): AxiosPromise<TelegramSettingsResponseDto> {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV: getTelegramSetting1VEnum = requestParameters.v || getTelegramSetting1VEnum._1;
            return localVarFp.getTelegramSetting1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get code for connected chat
         * @param {initTelegramChatConnect1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initTelegramChatConnect1(requestParameters: initTelegramChatConnect1Request, options?: RawAxiosRequestConfig): AxiosPromise<TelegramInitConnectResponseDto> {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV: initTelegramChatConnect1VEnum = requestParameters.v || initTelegramChatConnect1VEnum._1;
            return localVarFp.initTelegramChatConnect1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disconnect telegram chat
         * @param {removeTelegramChat1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTelegramChat1(requestParameters: removeTelegramChat1Request, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV: removeTelegramChat1VEnum = requestParameters.v || removeTelegramChat1VEnum._1;
            return localVarFp.removeTelegramChat1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set telegram settings
         * @param {setTelegramSetting1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTelegramSetting1(requestParameters: setTelegramSetting1Request, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV: setTelegramSetting1VEnum = requestParameters.v || setTelegramSetting1VEnum._1;
            return localVarFp.setTelegramSetting1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.siteTelegramSetSettingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get telegram post list
         * @param {telegramPosts1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegramPosts1(requestParameters: telegramPosts1Request, options?: RawAxiosRequestConfig): AxiosPromise<SiteTelegramChatPostsResponseDto> {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV: telegramPosts1VEnum = requestParameters.v || telegramPosts1VEnum._1;
            return localVarFp.telegramPosts1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Optional settings for telegram
         * @param {updateOptionsTelegram1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsTelegram1(requestParameters: updateOptionsTelegram1Request, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.updateOptionsTelegram1(requestParameters.siteUpdateChatTelegramRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get planned list
         * @param {getPlanned1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlanned1(requestParameters: getPlanned1Request, options?: RawAxiosRequestConfig): AxiosPromise<ListOfSitePlannedResponse> {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV: getPlanned1VEnum = requestParameters.v || getPlanned1VEnum._1;
            return localVarFp.getPlanned1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get playlists from the platform
         * @param {getPlayList1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayList1(requestParameters: getPlayList1Request, options?: RawAxiosRequestConfig): AxiosPromise<ListOfPlaylistItemResponse> {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV: getPlayList1VEnum = requestParameters.v || getPlayList1VEnum._1;
            return localVarFp.getPlayList1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Optional settings for ok. Depends on the tariff.
         * @param {updateOptionsOk1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsOk1(requestParameters: updateOptionsOk1Request, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.updateOptionsOk1(requestParameters.siteUpdateOptionsOkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Optional settings for trovo. Depends on the tariff.
         * @param {updateOptionsTrovo1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsTrovo1(requestParameters: updateOptionsTrovo1Request, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.updateOptionsTrovo1(requestParameters.siteUpdateOptionsTrovoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Optional settings for twitch. Depends on the tariff.
         * @param {updateOptionsTwitch1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsTwitch1(requestParameters: updateOptionsTwitch1Request, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.updateOptionsTwitch1(requestParameters.siteUpdateOptionsTwitchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Optional settings for vk. Depends on the tariff.
         * @param {updateOptionsVk1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsVk1(requestParameters: updateOptionsVk1Request, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.updateOptionsVk1(requestParameters.siteUpdateOptionsVkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Optional settings for vk video live. Depends on the tariff.
         * @param {updateOptionsVkVideoLive1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsVkVideoLive1(requestParameters: updateOptionsVkVideoLive1Request, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.updateOptionsVkVideoLive1(requestParameters.siteUpdateOptionsVkVideoLiveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Optional settings for youtube. Depends on the tariff.
         * @param {updateOptionsYoutube1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsYoutube1(requestParameters: updateOptionsYoutube1Request, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.updateOptionsYoutube1(requestParameters.siteUpdateOptionsYoutubeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set planned id. Depends on the tariff.
         * @param {updatePlanned1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlanned1(requestParameters: updatePlanned1Request, options?: RawAxiosRequestConfig): AxiosPromise<SitePlannedResponse> {
            return localVarFp.updatePlanned1(requestParameters.siteSetPlannedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get status platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus1(options?: RawAxiosRequestConfig): AxiosPromise<SiteChannelStatusResponse> {
            return localVarFp.getStatus1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set name from custom channel. Global settings.
         * @param {setName1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setName1(requestParameters: setName1Request, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.setName1(requestParameters.siteSetNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set rtmp url from channel. Global settings.
         * @param {updateRtmp1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRtmp1(requestParameters: updateRtmp1Request, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.updateRtmp1(requestParameters.siteSetUrlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get status platform
         * @param {updateToken1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateToken1(requestParameters: updateToken1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV: updateToken1VEnum = requestParameters.v || updateToken1VEnum._1;
            return localVarFp.updateToken1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set transcoder from channel. Personal settings.
         * @param {updateTranscoder1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTranscoder1(requestParameters: updateTranscoder1Request, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.updateTranscoder1(requestParameters.siteSetTranscoderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get telegram post by filter
         * @param {telegramGetPostByFilterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegramGetPostByFilter(requestParameters: telegramGetPostByFilterRequest, options?: RawAxiosRequestConfig): AxiosPromise<SiteTelegramChatPostsItem> {
            return localVarFp.telegramGetPostByFilter(requestParameters.v, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.filterMode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getTelegramSetting1 operation in ChannelSettingsApi.
 * @export
 * @interface getTelegramSetting1Request
 */
export interface getTelegramSetting1Request {
    /**
     * Version
     * @type {'1' | '2' | '3'}
     * @memberof getTelegramSetting1
     */
    readonly v?: getTelegramSetting1VEnum

    /**
     * Current language
     * @type {'ru' | 'en' | 'cn'}
     * @memberof getTelegramSetting1
     */
    readonly language: getTelegramSetting1LanguageEnum

    /**
     * Project id
     * @type {number}
     * @memberof getTelegramSetting1
     */
    readonly projectId: number

    /**
     * Channel id
     * @type {number}
     * @memberof getTelegramSetting1
     */
    readonly channelId: number
}

/**
 * Request parameters for initTelegramChatConnect1 operation in ChannelSettingsApi.
 * @export
 * @interface initTelegramChatConnect1Request
 */
export interface initTelegramChatConnect1Request {
    /**
     * Version
     * @type {'1' | '2' | '3'}
     * @memberof initTelegramChatConnect1
     */
    readonly v?: initTelegramChatConnect1VEnum

    /**
     * Current language
     * @type {'ru' | 'en' | 'cn'}
     * @memberof initTelegramChatConnect1
     */
    readonly language: initTelegramChatConnect1LanguageEnum

    /**
     * Project id
     * @type {number}
     * @memberof initTelegramChatConnect1
     */
    readonly projectId: number

    /**
     * Channel id
     * @type {number}
     * @memberof initTelegramChatConnect1
     */
    readonly channelId: number
}

/**
 * Request parameters for removeTelegramChat1 operation in ChannelSettingsApi.
 * @export
 * @interface removeTelegramChat1Request
 */
export interface removeTelegramChat1Request {
    /**
     * Version
     * @type {'1' | '2' | '3'}
     * @memberof removeTelegramChat1
     */
    readonly v?: removeTelegramChat1VEnum

    /**
     * Current language
     * @type {'ru' | 'en' | 'cn'}
     * @memberof removeTelegramChat1
     */
    readonly language: removeTelegramChat1LanguageEnum

    /**
     * Project id
     * @type {number}
     * @memberof removeTelegramChat1
     */
    readonly projectId: number

    /**
     * Channel id
     * @type {number}
     * @memberof removeTelegramChat1
     */
    readonly channelId: number
}

/**
 * Request parameters for setTelegramSetting1 operation in ChannelSettingsApi.
 * @export
 * @interface setTelegramSetting1Request
 */
export interface setTelegramSetting1Request {
    /**
     * Version
     * @type {'1' | '2' | '3'}
     * @memberof setTelegramSetting1
     */
    readonly v?: setTelegramSetting1VEnum

    /**
     * Current language
     * @type {'ru' | 'en' | 'cn'}
     * @memberof setTelegramSetting1
     */
    readonly language: setTelegramSetting1LanguageEnum

    /**
     * Project id
     * @type {number}
     * @memberof setTelegramSetting1
     */
    readonly projectId: number

    /**
     * Channel id
     * @type {number}
     * @memberof setTelegramSetting1
     */
    readonly channelId: number

    /**
     * 
     * @type {SiteTelegramSetSettingsRequestDto}
     * @memberof setTelegramSetting1
     */
    readonly siteTelegramSetSettingsRequestDto: SiteTelegramSetSettingsRequestDto
}

/**
 * Request parameters for telegramPosts1 operation in ChannelSettingsApi.
 * @export
 * @interface telegramPosts1Request
 */
export interface telegramPosts1Request {
    /**
     * Version
     * @type {'1' | '2' | '3'}
     * @memberof telegramPosts1
     */
    readonly v?: telegramPosts1VEnum

    /**
     * Current language
     * @type {'ru' | 'en' | 'cn'}
     * @memberof telegramPosts1
     */
    readonly language: telegramPosts1LanguageEnum

    /**
     * Project id
     * @type {number}
     * @memberof telegramPosts1
     */
    readonly projectId: number

    /**
     * Channel id
     * @type {number}
     * @memberof telegramPosts1
     */
    readonly channelId: number
}

/**
 * Request parameters for updateOptionsTelegram1 operation in ChannelSettingsApi.
 * @export
 * @interface updateOptionsTelegram1Request
 */
export interface updateOptionsTelegram1Request {
    /**
     * 
     * @type {SiteUpdateChatTelegramRequest}
     * @memberof updateOptionsTelegram1
     */
    readonly siteUpdateChatTelegramRequest: SiteUpdateChatTelegramRequest
}

/**
 * Request parameters for getPlanned1 operation in ChannelSettingsApi.
 * @export
 * @interface getPlanned1Request
 */
export interface getPlanned1Request {
    /**
     * Version
     * @type {'1' | '2' | '3'}
     * @memberof getPlanned1
     */
    readonly v?: getPlanned1VEnum

    /**
     * Current language
     * @type {'ru' | 'en' | 'cn'}
     * @memberof getPlanned1
     */
    readonly language: getPlanned1LanguageEnum

    /**
     * Project id
     * @type {number}
     * @memberof getPlanned1
     */
    readonly projectId: number

    /**
     * Channel id
     * @type {number}
     * @memberof getPlanned1
     */
    readonly channelId: number
}

/**
 * Request parameters for getPlayList1 operation in ChannelSettingsApi.
 * @export
 * @interface getPlayList1Request
 */
export interface getPlayList1Request {
    /**
     * Version
     * @type {'1' | '2' | '3'}
     * @memberof getPlayList1
     */
    readonly v?: getPlayList1VEnum

    /**
     * Current language
     * @type {'ru' | 'en' | 'cn'}
     * @memberof getPlayList1
     */
    readonly language: getPlayList1LanguageEnum

    /**
     * Project id
     * @type {number}
     * @memberof getPlayList1
     */
    readonly projectId: number

    /**
     * Channel id
     * @type {number}
     * @memberof getPlayList1
     */
    readonly channelId: number
}

/**
 * Request parameters for updateOptionsOk1 operation in ChannelSettingsApi.
 * @export
 * @interface updateOptionsOk1Request
 */
export interface updateOptionsOk1Request {
    /**
     * 
     * @type {SiteUpdateOptionsOkRequest}
     * @memberof updateOptionsOk1
     */
    readonly siteUpdateOptionsOkRequest: SiteUpdateOptionsOkRequest
}

/**
 * Request parameters for updateOptionsTrovo1 operation in ChannelSettingsApi.
 * @export
 * @interface updateOptionsTrovo1Request
 */
export interface updateOptionsTrovo1Request {
    /**
     * 
     * @type {SiteUpdateOptionsTrovoRequest}
     * @memberof updateOptionsTrovo1
     */
    readonly siteUpdateOptionsTrovoRequest: SiteUpdateOptionsTrovoRequest
}

/**
 * Request parameters for updateOptionsTwitch1 operation in ChannelSettingsApi.
 * @export
 * @interface updateOptionsTwitch1Request
 */
export interface updateOptionsTwitch1Request {
    /**
     * 
     * @type {SiteUpdateOptionsTwitchRequest}
     * @memberof updateOptionsTwitch1
     */
    readonly siteUpdateOptionsTwitchRequest: SiteUpdateOptionsTwitchRequest
}

/**
 * Request parameters for updateOptionsVk1 operation in ChannelSettingsApi.
 * @export
 * @interface updateOptionsVk1Request
 */
export interface updateOptionsVk1Request {
    /**
     * 
     * @type {SiteUpdateOptionsVkRequest}
     * @memberof updateOptionsVk1
     */
    readonly siteUpdateOptionsVkRequest: SiteUpdateOptionsVkRequest
}

/**
 * Request parameters for updateOptionsVkVideoLive1 operation in ChannelSettingsApi.
 * @export
 * @interface updateOptionsVkVideoLive1Request
 */
export interface updateOptionsVkVideoLive1Request {
    /**
     * 
     * @type {SiteUpdateOptionsVkVideoLiveRequest}
     * @memberof updateOptionsVkVideoLive1
     */
    readonly siteUpdateOptionsVkVideoLiveRequest: SiteUpdateOptionsVkVideoLiveRequest
}

/**
 * Request parameters for updateOptionsYoutube1 operation in ChannelSettingsApi.
 * @export
 * @interface updateOptionsYoutube1Request
 */
export interface updateOptionsYoutube1Request {
    /**
     * 
     * @type {SiteUpdateOptionsYoutubeRequest}
     * @memberof updateOptionsYoutube1
     */
    readonly siteUpdateOptionsYoutubeRequest: SiteUpdateOptionsYoutubeRequest
}

/**
 * Request parameters for updatePlanned1 operation in ChannelSettingsApi.
 * @export
 * @interface updatePlanned1Request
 */
export interface updatePlanned1Request {
    /**
     * 
     * @type {SiteSetPlannedRequest}
     * @memberof updatePlanned1
     */
    readonly siteSetPlannedRequest: SiteSetPlannedRequest
}

/**
 * Request parameters for setName1 operation in ChannelSettingsApi.
 * @export
 * @interface setName1Request
 */
export interface setName1Request {
    /**
     * 
     * @type {SiteSetNameRequest}
     * @memberof setName1
     */
    readonly siteSetNameRequest: SiteSetNameRequest
}

/**
 * Request parameters for updateRtmp1 operation in ChannelSettingsApi.
 * @export
 * @interface updateRtmp1Request
 */
export interface updateRtmp1Request {
    /**
     * 
     * @type {SiteSetUrlRequest}
     * @memberof updateRtmp1
     */
    readonly siteSetUrlRequest: SiteSetUrlRequest
}

/**
 * Request parameters for updateToken1 operation in ChannelSettingsApi.
 * @export
 * @interface updateToken1Request
 */
export interface updateToken1Request {
    /**
     * Version
     * @type {'1' | '2' | '3'}
     * @memberof updateToken1
     */
    readonly v?: updateToken1VEnum

    /**
     * Current language
     * @type {'ru' | 'en' | 'cn'}
     * @memberof updateToken1
     */
    readonly language: updateToken1LanguageEnum

    /**
     * Project id
     * @type {number}
     * @memberof updateToken1
     */
    readonly projectId: number

    /**
     * Channel id
     * @type {number}
     * @memberof updateToken1
     */
    readonly channelId: number

    /**
     * Token role
     * @type {'account' | 'group'}
     * @memberof updateToken1
     */
    readonly role: updateToken1RoleEnum
}

/**
 * Request parameters for updateTranscoder1 operation in ChannelSettingsApi.
 * @export
 * @interface updateTranscoder1Request
 */
export interface updateTranscoder1Request {
    /**
     * 
     * @type {SiteSetTranscoderRequest}
     * @memberof updateTranscoder1
     */
    readonly siteSetTranscoderRequest: SiteSetTranscoderRequest
}

/**
 * Request parameters for telegramGetPostByFilter operation in ChannelSettingsApi.
 * @export
 * @interface telegramGetPostByFilterRequest
 */
export interface telegramGetPostByFilterRequest {
    /**
     * Version
     * @type {'1' | '2' | '3'}
     * @memberof telegramGetPostByFilter
     */
    readonly v: TelegramGetPostByFilterVEnum

    /**
     * Current language
     * @type {'ru' | 'en' | 'cn'}
     * @memberof telegramGetPostByFilter
     */
    readonly language: TelegramGetPostByFilterLanguageEnum

    /**
     * Project id
     * @type {number}
     * @memberof telegramGetPostByFilter
     */
    readonly projectId: number

    /**
     * Channel id
     * @type {number}
     * @memberof telegramGetPostByFilter
     */
    readonly channelId: number

    /**
     * 
     * @type {number}
     * @memberof telegramGetPostByFilter
     */
    readonly filterMode: number
}

/**
 * ChannelSettingsApi - object-oriented interface
 * @export
 * @class ChannelSettingsApi
 * @extends {BaseAPI}
 */
export class ChannelSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get telegram settings
     * @param {getTelegramSetting1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public getTelegramSetting1(requestParameters: getTelegramSetting1Request, options?: RawAxiosRequestConfig) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV: getTelegramSetting1VEnum = requestParameters.v || getTelegramSetting1VEnum._1;
        return fp(this.configuration).getTelegramSetting1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get code for connected chat
     * @param {initTelegramChatConnect1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public initTelegramChatConnect1(requestParameters: initTelegramChatConnect1Request, options?: RawAxiosRequestConfig) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV: initTelegramChatConnect1VEnum = requestParameters.v || initTelegramChatConnect1VEnum._1;
        return fp(this.configuration).initTelegramChatConnect1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disconnect telegram chat
     * @param {removeTelegramChat1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public removeTelegramChat1(requestParameters: removeTelegramChat1Request, options?: RawAxiosRequestConfig) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV: removeTelegramChat1VEnum = requestParameters.v || removeTelegramChat1VEnum._1;
        return fp(this.configuration).removeTelegramChat1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set telegram settings
     * @param {setTelegramSetting1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public setTelegramSetting1(requestParameters: setTelegramSetting1Request, options?: RawAxiosRequestConfig) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV: setTelegramSetting1VEnum = requestParameters.v || setTelegramSetting1VEnum._1;
        return fp(this.configuration).setTelegramSetting1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.siteTelegramSetSettingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get telegram post list
     * @param {telegramPosts1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public telegramPosts1(requestParameters: telegramPosts1Request, options?: RawAxiosRequestConfig) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV: telegramPosts1VEnum = requestParameters.v || telegramPosts1VEnum._1;
        return fp(this.configuration).telegramPosts1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Optional settings for telegram
     * @param {updateOptionsTelegram1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public updateOptionsTelegram1(requestParameters: updateOptionsTelegram1Request, options?: RawAxiosRequestConfig) {
        return fp(this.configuration).updateOptionsTelegram1(requestParameters.siteUpdateChatTelegramRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get planned list
     * @param {getPlanned1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public getPlanned1(requestParameters: getPlanned1Request, options?: RawAxiosRequestConfig) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV: getPlanned1VEnum = requestParameters.v || getPlanned1VEnum._1;
        return fp(this.configuration).getPlanned1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get playlists from the platform
     * @param {getPlayList1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public getPlayList1(requestParameters: getPlayList1Request, options?: RawAxiosRequestConfig) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV: getPlayList1VEnum = requestParameters.v || getPlayList1VEnum._1;
        return fp(this.configuration).getPlayList1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Optional settings for ok. Depends on the tariff.
     * @param {updateOptionsOk1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public updateOptionsOk1(requestParameters: updateOptionsOk1Request, options?: RawAxiosRequestConfig) {
        return fp(this.configuration).updateOptionsOk1(requestParameters.siteUpdateOptionsOkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Optional settings for trovo. Depends on the tariff.
     * @param {updateOptionsTrovo1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public updateOptionsTrovo1(requestParameters: updateOptionsTrovo1Request, options?: RawAxiosRequestConfig) {
        return fp(this.configuration).updateOptionsTrovo1(requestParameters.siteUpdateOptionsTrovoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Optional settings for twitch. Depends on the tariff.
     * @param {updateOptionsTwitch1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public updateOptionsTwitch1(requestParameters: updateOptionsTwitch1Request, options?: RawAxiosRequestConfig) {
        return fp(this.configuration).updateOptionsTwitch1(requestParameters.siteUpdateOptionsTwitchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Optional settings for vk. Depends on the tariff.
     * @param {updateOptionsVk1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public updateOptionsVk1(requestParameters: updateOptionsVk1Request, options?: RawAxiosRequestConfig) {
        return fp(this.configuration).updateOptionsVk1(requestParameters.siteUpdateOptionsVkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Optional settings for vk video live. Depends on the tariff.
     * @param {updateOptionsVkVideoLive1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public updateOptionsVkVideoLive1(requestParameters: updateOptionsVkVideoLive1Request, options?: RawAxiosRequestConfig) {
        return fp(this.configuration).updateOptionsVkVideoLive1(requestParameters.siteUpdateOptionsVkVideoLiveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Optional settings for youtube. Depends on the tariff.
     * @param {updateOptionsYoutube1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public updateOptionsYoutube1(requestParameters: updateOptionsYoutube1Request, options?: RawAxiosRequestConfig) {
        return fp(this.configuration).updateOptionsYoutube1(requestParameters.siteUpdateOptionsYoutubeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set planned id. Depends on the tariff.
     * @param {updatePlanned1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public updatePlanned1(requestParameters: updatePlanned1Request, options?: RawAxiosRequestConfig) {
        return fp(this.configuration).updatePlanned1(requestParameters.siteSetPlannedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get status platform
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public getStatus1(options?: RawAxiosRequestConfig) {
        return fp(this.configuration).getStatus1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set name from custom channel. Global settings.
     * @param {setName1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public setName1(requestParameters: setName1Request, options?: RawAxiosRequestConfig) {
        return fp(this.configuration).setName1(requestParameters.siteSetNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set rtmp url from channel. Global settings.
     * @param {updateRtmp1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public updateRtmp1(requestParameters: updateRtmp1Request, options?: RawAxiosRequestConfig) {
        return fp(this.configuration).updateRtmp1(requestParameters.siteSetUrlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get status platform
     * @param {updateToken1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public updateToken1(requestParameters: updateToken1Request, options?: RawAxiosRequestConfig) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV: updateToken1VEnum = requestParameters.v || updateToken1VEnum._1;
        return fp(this.configuration).updateToken1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set transcoder from channel. Personal settings.
     * @param {updateTranscoder1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public updateTranscoder1(requestParameters: updateTranscoder1Request, options?: RawAxiosRequestConfig) {
        return fp(this.configuration).updateTranscoder1(requestParameters.siteSetTranscoderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get telegram post by filter
     * @param {telegramGetPostByFilterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    public telegramGetPostByFilter(requestParameters: telegramGetPostByFilterRequest, options?: RawAxiosRequestConfig) {
        return fp(this.configuration).telegramGetPostByFilter(requestParameters.v, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.filterMode, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum getTelegramSetting1VEnum {
    _1 = '1',
    _2 = '2',
    _3 = '3'
}
/**
  * @export
  * @enum {string}
  */
export enum getTelegramSetting1LanguageEnum {
    ru = 'ru',
    en = 'en',
    cn = 'cn'
}
/**
  * @export
  * @enum {string}
  */
export enum initTelegramChatConnect1VEnum {
    _1 = '1',
    _2 = '2',
    _3 = '3'
}
/**
  * @export
  * @enum {string}
  */
export enum initTelegramChatConnect1LanguageEnum {
    ru = 'ru',
    en = 'en',
    cn = 'cn'
}
/**
  * @export
  * @enum {string}
  */
export enum removeTelegramChat1VEnum {
    _1 = '1',
    _2 = '2',
    _3 = '3'
}
/**
  * @export
  * @enum {string}
  */
export enum removeTelegramChat1LanguageEnum {
    ru = 'ru',
    en = 'en',
    cn = 'cn'
}
/**
  * @export
  * @enum {string}
  */
export enum setTelegramSetting1VEnum {
    _1 = '1',
    _2 = '2',
    _3 = '3'
}
/**
  * @export
  * @enum {string}
  */
export enum setTelegramSetting1LanguageEnum {
    ru = 'ru',
    en = 'en',
    cn = 'cn'
}
/**
  * @export
  * @enum {string}
  */
export enum telegramPosts1VEnum {
    _1 = '1',
    _2 = '2',
    _3 = '3'
}
/**
  * @export
  * @enum {string}
  */
export enum telegramPosts1LanguageEnum {
    ru = 'ru',
    en = 'en',
    cn = 'cn'
}
/**
  * @export
  * @enum {string}
  */
export enum getPlanned1VEnum {
    _1 = '1',
    _2 = '2',
    _3 = '3'
}
/**
  * @export
  * @enum {string}
  */
export enum getPlanned1LanguageEnum {
    ru = 'ru',
    en = 'en',
    cn = 'cn'
}
/**
  * @export
  * @enum {string}
  */
export enum getPlayList1VEnum {
    _1 = '1',
    _2 = '2',
    _3 = '3'
}
/**
  * @export
  * @enum {string}
  */
export enum getPlayList1LanguageEnum {
    ru = 'ru',
    en = 'en',
    cn = 'cn'
}
/**
  * @export
  * @enum {string}
  */
export enum updateToken1VEnum {
    _1 = '1',
    _2 = '2',
    _3 = '3'
}
/**
  * @export
  * @enum {string}
  */
export enum updateToken1LanguageEnum {
    ru = 'ru',
    en = 'en',
    cn = 'cn'
}
/**
  * @export
  * @enum {string}
  */
export enum updateToken1RoleEnum {
    account = 'account',
    group = 'group'
}
/**
  * @export
  * @enum {string}
  */
export enum TelegramGetPostByFilterVEnum {
    _1 = '1',
    _2 = '2',
    _3 = '3'
}
/**
  * @export
  * @enum {string}
  */
export enum TelegramGetPostByFilterLanguageEnum {
    ru = 'ru',
    en = 'en',
    cn = 'cn'
}
