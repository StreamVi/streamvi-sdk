"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * StreamVi Backend
 * API
 *
 * The version of the OpenAPI document: 3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runAction1VEnum = exports.markOfRead1LanguageEnum = exports.markOfRead1VEnum = exports.getStatusMy1LanguageEnum = exports.getStatusMy1VEnum = exports.getListMy1StatusReadEnum = exports.getListMy1ChannelEnum = exports.getListMy1NameEnum = exports.getListMy1LanguageEnum = exports.getListMy1VEnum = exports.get1VEnum = exports.NotifyHistoryApi = exports.factory = exports.fp = exports.axiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * NotifyHistoryApi - axios parameter creator
 * @export
 */
const axiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get my NotifyHistory item by id
         * @param {get1VEnum} v Version
         * @param {string} id Id of page in mongodb
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1: async (v, id, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('get1', 'v', v);
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('get1', 'id', id);
            const localVarPath = `/method/notify_history/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (id !== undefined) {
                localVarQueryParameter['_id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get list of my notifications
         * @param {getListMy1VEnum} v Version
         * @param {getListMy1LanguageEnum} language Current language
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {number} [projectId] Project id
         * @param {getListMy1NameEnum} [name] Name
         * @param {getListMy1ChannelEnum} [channel] Channel
         * @param {string} [dateFrom] Date from
         * @param {string} [dateTo] Date to
         * @param {getListMy1StatusReadEnum} [statusRead] Status read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListMy1: async (v, language, limit, offset, projectId, name, channel, dateFrom, dateTo, statusRead, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('getListMy1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('getListMy1', 'language', language);
            const localVarPath = `/method/notify_history/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }
            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom instanceof Date) ?
                    dateFrom.toISOString() :
                    dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = (dateTo instanceof Date) ?
                    dateTo.toISOString() :
                    dateTo;
            }
            if (statusRead !== undefined) {
                localVarQueryParameter['status_read'] = statusRead;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get my status unread message for user
         * @param {getStatusMy1VEnum} v Version
         * @param {getStatusMy1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusMy1: async (v, language, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('getStatusMy1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('getStatusMy1', 'language', language);
            const localVarPath = `/method/notify_history/get_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Set notification in cabinet as read
         * @param {markOfRead1VEnum} v Version
         * @param {markOfRead1LanguageEnum} language Current language
         * @param {SiteMarkReadHistoryRequest} siteMarkReadHistoryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markOfRead1: async (v, language, siteMarkReadHistoryRequest, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('markOfRead1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('markOfRead1', 'language', language);
            // verify required parameter 'siteMarkReadHistoryRequest' is not null or undefined
            (0, common_1.assertParamExists)('markOfRead1', 'siteMarkReadHistoryRequest', siteMarkReadHistoryRequest);
            const localVarPath = `/method/notify_history/read`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(siteMarkReadHistoryRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Run action in my notify item
         * @param {runAction1VEnum} v Version
         * @param {string} notifyHistoryId Id of page in mongodb
         * @param {string} actionName Action name
         * @param {string} groupId Group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runAction1: async (v, notifyHistoryId, actionName, groupId, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('runAction1', 'v', v);
            // verify required parameter 'notifyHistoryId' is not null or undefined
            (0, common_1.assertParamExists)('runAction1', 'notifyHistoryId', notifyHistoryId);
            // verify required parameter 'actionName' is not null or undefined
            (0, common_1.assertParamExists)('runAction1', 'actionName', actionName);
            // verify required parameter 'groupId' is not null or undefined
            (0, common_1.assertParamExists)('runAction1', 'groupId', groupId);
            const localVarPath = `/method/notify_history/run_action`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (notifyHistoryId !== undefined) {
                localVarQueryParameter['notify_history_id'] = notifyHistoryId;
            }
            if (actionName !== undefined) {
                localVarQueryParameter['action_name'] = actionName;
            }
            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Set all notification in cabinet as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAllCabinetRead1: async (options = {}) => {
            const localVarPath = `/method/notify_history/set_all_cabinet_read`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.axiosParamCreator = axiosParamCreator;
/**
 * NotifyHistoryApi - functional programming interface
 * @export
 */
const fp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.axiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Get my NotifyHistory item by id
         * @param {get1VEnum} v Version
         * @param {string} id Id of page in mongodb
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get1(v, id, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.get1(v, id, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotifyHistoryApi.get1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get list of my notifications
         * @param {getListMy1VEnum} v Version
         * @param {getListMy1LanguageEnum} language Current language
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {number} [projectId] Project id
         * @param {getListMy1NameEnum} [name] Name
         * @param {getListMy1ChannelEnum} [channel] Channel
         * @param {string} [dateFrom] Date from
         * @param {string} [dateTo] Date to
         * @param {getListMy1StatusReadEnum} [statusRead] Status read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListMy1(v, language, limit, offset, projectId, name, channel, dateFrom, dateTo, statusRead, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListMy1(v, language, limit, offset, projectId, name, channel, dateFrom, dateTo, statusRead, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotifyHistoryApi.getListMy1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get my status unread message for user
         * @param {getStatusMy1VEnum} v Version
         * @param {getStatusMy1LanguageEnum} language Current language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusMy1(v, language, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusMy1(v, language, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotifyHistoryApi.getStatusMy1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Set notification in cabinet as read
         * @param {markOfRead1VEnum} v Version
         * @param {markOfRead1LanguageEnum} language Current language
         * @param {SiteMarkReadHistoryRequest} siteMarkReadHistoryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markOfRead1(v, language, siteMarkReadHistoryRequest, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.markOfRead1(v, language, siteMarkReadHistoryRequest, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotifyHistoryApi.markOfRead1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Run action in my notify item
         * @param {runAction1VEnum} v Version
         * @param {string} notifyHistoryId Id of page in mongodb
         * @param {string} actionName Action name
         * @param {string} groupId Group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runAction1(v, notifyHistoryId, actionName, groupId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.runAction1(v, notifyHistoryId, actionName, groupId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotifyHistoryApi.runAction1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Set all notification in cabinet as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAllCabinetRead1(options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAllCabinetRead1(options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotifyHistoryApi.setAllCabinetRead1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.fp = fp;
/**
 * NotifyHistoryApi - factory interface
 * @export
 */
const factory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.fp)(configuration);
    return {
        /**
         *
         * @summary Get my NotifyHistory item by id
         * @param {get1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || get1VEnum._1;
            return localVarFp.get1(actualV, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get list of my notifications
         * @param {getListMy1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListMy1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || getListMy1VEnum._1;
            return localVarFp.getListMy1(actualV, requestParameters.language, requestParameters.limit, requestParameters.offset, requestParameters.projectId, requestParameters.name, requestParameters.channel, requestParameters.dateFrom, requestParameters.dateTo, requestParameters.statusRead, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get my status unread message for user
         * @param {getStatusMy1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusMy1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || getStatusMy1VEnum._1;
            return localVarFp.getStatusMy1(actualV, requestParameters.language, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Set notification in cabinet as read
         * @param {markOfRead1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markOfRead1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || markOfRead1VEnum._1;
            return localVarFp.markOfRead1(actualV, requestParameters.language, requestParameters.siteMarkReadHistoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Run action in my notify item
         * @param {runAction1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runAction1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || runAction1VEnum._1;
            return localVarFp.runAction1(actualV, requestParameters.notifyHistoryId, requestParameters.actionName, requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Set all notification in cabinet as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAllCabinetRead1(options) {
            return localVarFp.setAllCabinetRead1(options).then((request) => request(axios, basePath));
        },
    };
};
exports.factory = factory;
/**
 * NotifyHistoryApi - object-oriented interface
 * @export
 * @class NotifyHistoryApi
 * @extends {BaseAPI}
 */
class NotifyHistoryApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get my NotifyHistory item by id
     * @param {get1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApi
     */
    get1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || get1VEnum._1;
        return (0, exports.fp)(this.configuration).get1(actualV, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get list of my notifications
     * @param {getListMy1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApi
     */
    getListMy1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || getListMy1VEnum._1;
        return (0, exports.fp)(this.configuration).getListMy1(actualV, requestParameters.language, requestParameters.limit, requestParameters.offset, requestParameters.projectId, requestParameters.name, requestParameters.channel, requestParameters.dateFrom, requestParameters.dateTo, requestParameters.statusRead, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get my status unread message for user
     * @param {getStatusMy1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApi
     */
    getStatusMy1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || getStatusMy1VEnum._1;
        return (0, exports.fp)(this.configuration).getStatusMy1(actualV, requestParameters.language, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Set notification in cabinet as read
     * @param {markOfRead1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApi
     */
    markOfRead1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || markOfRead1VEnum._1;
        return (0, exports.fp)(this.configuration).markOfRead1(actualV, requestParameters.language, requestParameters.siteMarkReadHistoryRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Run action in my notify item
     * @param {runAction1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApi
     */
    runAction1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || runAction1VEnum._1;
        return (0, exports.fp)(this.configuration).runAction1(actualV, requestParameters.notifyHistoryId, requestParameters.actionName, requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Set all notification in cabinet as read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApi
     */
    setAllCabinetRead1(options) {
        return (0, exports.fp)(this.configuration).setAllCabinetRead1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.NotifyHistoryApi = NotifyHistoryApi;
/**
  * @export
  * @enum {string}
  */
var get1VEnum;
(function (get1VEnum) {
    get1VEnum["_1"] = "1";
})(get1VEnum || (exports.get1VEnum = get1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var getListMy1VEnum;
(function (getListMy1VEnum) {
    getListMy1VEnum["_1"] = "1";
    getListMy1VEnum["_2"] = "2";
    getListMy1VEnum["_3"] = "3";
})(getListMy1VEnum || (exports.getListMy1VEnum = getListMy1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var getListMy1LanguageEnum;
(function (getListMy1LanguageEnum) {
    getListMy1LanguageEnum["ru"] = "ru";
    getListMy1LanguageEnum["en"] = "en";
    getListMy1LanguageEnum["cn"] = "cn";
})(getListMy1LanguageEnum || (exports.getListMy1LanguageEnum = getListMy1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var getListMy1NameEnum;
(function (getListMy1NameEnum) {
    getListMy1NameEnum["high_bitrate"] = "high_bitrate";
    getListMy1NameEnum["request_access_channel"] = "request_access_channel";
    getListMy1NameEnum["request_access_project"] = "request_access_project";
    getListMy1NameEnum["promocode_test"] = "promocode_test";
    getListMy1NameEnum["stream_test"] = "stream_test";
    getListMy1NameEnum["plan_restream_expires"] = "plan_restream_expires";
    getListMy1NameEnum["plan_restream_expired"] = "plan_restream_expired";
    getListMy1NameEnum["plan_restream_renewed"] = "plan_restream_renewed";
    getListMy1NameEnum["plan_transcoder_expires"] = "plan_transcoder_expires";
    getListMy1NameEnum["plan_transcoder_expired"] = "plan_transcoder_expired";
    getListMy1NameEnum["plan_transcoder_renewed"] = "plan_transcoder_renewed";
    getListMy1NameEnum["plan_storage_expires"] = "plan_storage_expires";
    getListMy1NameEnum["plan_storage_expired"] = "plan_storage_expired";
    getListMy1NameEnum["plan_storage_renewed"] = "plan_storage_renewed";
    getListMy1NameEnum["broadcast_unsupported_codec"] = "broadcast_unsupported_codec";
    getListMy1NameEnum["broadcast_unsupported_codec_screen"] = "broadcast_unsupported_codec_screen";
    getListMy1NameEnum["broadcast_bitrate_exceeded_screen"] = "broadcast_bitrate_exceeded_screen";
    getListMy1NameEnum["rtmp_connect_old_server_screen"] = "rtmp_connect_old_server_screen";
    getListMy1NameEnum["broadcast_not_audio"] = "broadcast_not_audio";
    getListMy1NameEnum["broadcast_bitrate_exceeded"] = "broadcast_bitrate_exceeded";
    getListMy1NameEnum["broadcast_started"] = "broadcast_started";
    getListMy1NameEnum["broadcast_stopped"] = "broadcast_stopped";
    getListMy1NameEnum["restream_check_twitch_bitrate_1"] = "restream_check_twitch_bitrate_1";
    getListMy1NameEnum["api_pause_start"] = "api_pause_start";
    getListMy1NameEnum["api_pause_end"] = "api_pause_end";
    getListMy1NameEnum["api_wait_edit"] = "api_wait_edit";
    getListMy1NameEnum["api_restream_start"] = "api_restream_start";
    getListMy1NameEnum["api_restream_stop"] = "api_restream_stop";
    getListMy1NameEnum["api_drop_broadcast"] = "api_drop_broadcast";
    getListMy1NameEnum["api_drop_broadcast_remove_company"] = "api_drop_broadcast_remove_company";
    getListMy1NameEnum["api_drop_broadcast_update_key"] = "api_drop_broadcast_update_key";
    getListMy1NameEnum["publisher_disconnected"] = "publisher_disconnected";
    getListMy1NameEnum["publisher_connected"] = "publisher_connected";
    getListMy1NameEnum["publisher_initializing"] = "publisher_initializing";
    getListMy1NameEnum["publisher_close"] = "publisher_close";
    getListMy1NameEnum["broadcast_connected_start"] = "broadcast_connected_start";
    getListMy1NameEnum["broadcast_connected_end"] = "broadcast_connected_end";
    getListMy1NameEnum["broadcast_connecting_stream"] = "broadcast_connecting_stream";
    getListMy1NameEnum["broadcast_started_new_stream"] = "broadcast_started_new_stream";
    getListMy1NameEnum["broadcast_connecting_lost"] = "broadcast_connecting_lost";
    getListMy1NameEnum["broadcast_video_lost_start"] = "broadcast_video_lost_start";
    getListMy1NameEnum["broadcast_video_lost_end"] = "broadcast_video_lost_end";
    getListMy1NameEnum["broadcast_video_pause_start"] = "broadcast_video_pause_start";
    getListMy1NameEnum["broadcast_video_pause_end"] = "broadcast_video_pause_end";
    getListMy1NameEnum["broadcast_init_restream"] = "broadcast_init_restream";
    getListMy1NameEnum["start_stream"] = "start_stream";
    getListMy1NameEnum["create_reader"] = "create_reader";
    getListMy1NameEnum["start_channel"] = "start_channel";
    getListMy1NameEnum["stop_channel"] = "stop_channel";
    getListMy1NameEnum["stop_stream_video_timeout"] = "stop_stream_video_timeout";
    getListMy1NameEnum["stop_stream_no_start_video"] = "stop_stream_no_start_video";
    getListMy1NameEnum["stop_stream"] = "stop_stream";
    getListMy1NameEnum["delete_reader"] = "delete_reader";
    getListMy1NameEnum["transcoder_start"] = "transcoder_start";
    getListMy1NameEnum["transcoder_stop"] = "transcoder_stop";
    getListMy1NameEnum["start_channel_failed"] = "start_channel_failed";
    getListMy1NameEnum["start_channel_success"] = "start_channel_success";
    getListMy1NameEnum["api_channel_initializing_start"] = "api_channel_initializing_start";
    getListMy1NameEnum["api_channel_initializing_failed"] = "api_channel_initializing_failed";
    getListMy1NameEnum["api_channel_initializing_success"] = "api_channel_initializing_success";
    getListMy1NameEnum["channel_api_update_settings_success"] = "channel_api_update_settings_success";
    getListMy1NameEnum["channel_api_update_settings_error"] = "channel_api_update_settings_error";
    getListMy1NameEnum["channel_api_update_playlist_success"] = "channel_api_update_playlist_success";
    getListMy1NameEnum["channel_api_update_playlist_error"] = "channel_api_update_playlist_error";
    getListMy1NameEnum["channel_api_update_chat_error"] = "channel_api_update_chat_error";
    getListMy1NameEnum["channel_api_stream_key_success"] = "channel_api_stream_key_success";
    getListMy1NameEnum["channel_api_stream_key_error"] = "channel_api_stream_key_error";
    getListMy1NameEnum["channel_api_auto_stop_disable_success"] = "channel_api_auto_stop_disable_success";
    getListMy1NameEnum["channel_api_auto_stop_disable_error"] = "channel_api_auto_stop_disable_error";
    getListMy1NameEnum["channel_api_unbinding_stream_key_error"] = "channel_api_unbinding_stream_key_error";
    getListMy1NameEnum["channel_api_create_broadcast_success"] = "channel_api_create_broadcast_success";
    getListMy1NameEnum["channel_api_create_broadcast_error"] = "channel_api_create_broadcast_error";
    getListMy1NameEnum["channel_api_set_planned_success"] = "channel_api_set_planned_success";
    getListMy1NameEnum["channel_api_set_planned_error"] = "channel_api_set_planned_error";
    getListMy1NameEnum["channel_api_set_thumbnail_success"] = "channel_api_set_thumbnail_success";
    getListMy1NameEnum["channel_api_set_thumbnail_error"] = "channel_api_set_thumbnail_error";
    getListMy1NameEnum["channel_token_error"] = "channel_token_error";
    getListMy1NameEnum["channel_api_group_failed"] = "channel_api_group_failed";
    getListMy1NameEnum["no_audio_reader"] = "no_audio_reader";
    getListMy1NameEnum["restream_check_twitch_bitrate_2"] = "restream_check_twitch_bitrate_2";
    getListMy1NameEnum["transcoder_support_error_screen"] = "transcoder_support_error_screen";
    getListMy1NameEnum["transcoder_tariff_end_screen"] = "transcoder_tariff_end_screen";
    getListMy1NameEnum["transcoder_count_flow_screen"] = "transcoder_count_flow_screen";
    getListMy1NameEnum["transcoder_resolution_screen"] = "transcoder_resolution_screen";
    getListMy1NameEnum["stream_key_banned"] = "stream_key_banned";
    getListMy1NameEnum["broadcast_change_codec"] = "broadcast_change_codec";
    getListMy1NameEnum["broadcast_change_region"] = "broadcast_change_region";
    getListMy1NameEnum["video_upload_error"] = "video_upload_error";
    getListMy1NameEnum["stop_channel_error"] = "stop_channel_error";
    getListMy1NameEnum["broadcast_user_action_stop"] = "broadcast_user_action_stop";
})(getListMy1NameEnum || (exports.getListMy1NameEnum = getListMy1NameEnum = {}));
/**
  * @export
  * @enum {string}
  */
var getListMy1ChannelEnum;
(function (getListMy1ChannelEnum) {
    getListMy1ChannelEnum["telegram"] = "telegram";
    getListMy1ChannelEnum["cabinet"] = "cabinet";
    getListMy1ChannelEnum["mobile"] = "mobile";
})(getListMy1ChannelEnum || (exports.getListMy1ChannelEnum = getListMy1ChannelEnum = {}));
/**
  * @export
  * @enum {string}
  */
var getListMy1StatusReadEnum;
(function (getListMy1StatusReadEnum) {
    getListMy1StatusReadEnum["unread"] = "unread";
    getListMy1StatusReadEnum["read"] = "read";
})(getListMy1StatusReadEnum || (exports.getListMy1StatusReadEnum = getListMy1StatusReadEnum = {}));
/**
  * @export
  * @enum {string}
  */
var getStatusMy1VEnum;
(function (getStatusMy1VEnum) {
    getStatusMy1VEnum["_1"] = "1";
    getStatusMy1VEnum["_2"] = "2";
    getStatusMy1VEnum["_3"] = "3";
})(getStatusMy1VEnum || (exports.getStatusMy1VEnum = getStatusMy1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var getStatusMy1LanguageEnum;
(function (getStatusMy1LanguageEnum) {
    getStatusMy1LanguageEnum["ru"] = "ru";
    getStatusMy1LanguageEnum["en"] = "en";
    getStatusMy1LanguageEnum["cn"] = "cn";
})(getStatusMy1LanguageEnum || (exports.getStatusMy1LanguageEnum = getStatusMy1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var markOfRead1VEnum;
(function (markOfRead1VEnum) {
    markOfRead1VEnum["_1"] = "1";
    markOfRead1VEnum["_2"] = "2";
    markOfRead1VEnum["_3"] = "3";
})(markOfRead1VEnum || (exports.markOfRead1VEnum = markOfRead1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var markOfRead1LanguageEnum;
(function (markOfRead1LanguageEnum) {
    markOfRead1LanguageEnum["ru"] = "ru";
    markOfRead1LanguageEnum["en"] = "en";
    markOfRead1LanguageEnum["cn"] = "cn";
})(markOfRead1LanguageEnum || (exports.markOfRead1LanguageEnum = markOfRead1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var runAction1VEnum;
(function (runAction1VEnum) {
    runAction1VEnum["_1"] = "1";
})(runAction1VEnum || (exports.runAction1VEnum = runAction1VEnum = {}));
