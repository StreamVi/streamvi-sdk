"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * StreamVi Backend
 * API
 *
 * The version of the OpenAPI document: 3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotifyHistoryRunActionV1VEnum = exports.NotifyHistoryMarkOfReadV1VEnum = exports.NotifyHistoryMarkOfReadV1LanguageEnum = exports.NotifyHistoryGetV1VEnum = exports.NotifyHistoryGetStatusMyV1VEnum = exports.NotifyHistoryGetStatusMyV1LanguageEnum = exports.NotifyHistoryGetListMyV1StatusReadEnum = exports.NotifyHistoryGetListMyV1ChannelEnum = exports.NotifyHistoryGetListMyV1NameEnum = exports.NotifyHistoryGetListMyV1VEnum = exports.NotifyHistoryGetListMyV1LanguageEnum = exports.NotifyHistoryApi = exports.NotifyHistoryApiFactory = exports.NotifyHistoryApiFp = exports.NotifyHistoryApiAxiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * NotifyHistoryApi - axios parameter creator
 * @export
 */
const NotifyHistoryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get list of my notifications
         * @param {NotifyHistoryGetListMyV1LanguageEnum} language Current language
         * @param {NotifyHistoryGetListMyV1VEnum} [v] Version (automatically defaults to 1 based on method version, can be overridden)
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {number} [projectId] Project id
         * @param {NotifyHistoryGetListMyV1NameEnum} [name] Name
         * @param {NotifyHistoryGetListMyV1ChannelEnum} [channel] Channel
         * @param {string} [dateFrom] Date from
         * @param {string} [dateTo] Date to
         * @param {NotifyHistoryGetListMyV1StatusReadEnum} [statusRead] Status read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyHistoryGetListMyV1: async (language, v, limit, offset, projectId, name, channel, dateFrom, dateTo, statusRead, options = {}) => {
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('notifyHistoryGetListMyV1', 'language', language);
            const localVarPath = `/method/notify_history/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }
            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom instanceof Date) ?
                    dateFrom.toISOString() :
                    dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = (dateTo instanceof Date) ?
                    dateTo.toISOString() :
                    dateTo;
            }
            if (statusRead !== undefined) {
                localVarQueryParameter['status_read'] = statusRead;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get my status unread message for user
         * @param {NotifyHistoryGetStatusMyV1LanguageEnum} language Current language
         * @param {NotifyHistoryGetStatusMyV1VEnum} [v] Version (automatically defaults to 1 based on method version, can be overridden)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyHistoryGetStatusMyV1: async (language, v, options = {}) => {
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('notifyHistoryGetStatusMyV1', 'language', language);
            const localVarPath = `/method/notify_history/get_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get my NotifyHistory item by id
         * @param {string} id Id of page in mongodb
         * @param {NotifyHistoryGetV1VEnum} [v] Version (automatically defaults to 1 based on method version, can be overridden)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyHistoryGetV1: async (id, v, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('notifyHistoryGetV1', 'id', id);
            const localVarPath = `/method/notify_history/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (id !== undefined) {
                localVarQueryParameter['_id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Set notification in cabinet as read
         * @param {NotifyHistoryMarkOfReadV1LanguageEnum} language Current language
         * @param {SiteMarkReadHistoryRequest} siteMarkReadHistoryRequest
         * @param {NotifyHistoryMarkOfReadV1VEnum} [v] Version (automatically defaults to 1 based on method version, can be overridden)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyHistoryMarkOfReadV1: async (language, siteMarkReadHistoryRequest, v, options = {}) => {
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('notifyHistoryMarkOfReadV1', 'language', language);
            // verify required parameter 'siteMarkReadHistoryRequest' is not null or undefined
            (0, common_1.assertParamExists)('notifyHistoryMarkOfReadV1', 'siteMarkReadHistoryRequest', siteMarkReadHistoryRequest);
            const localVarPath = `/method/notify_history/read`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(siteMarkReadHistoryRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Run action in my notify item
         * @param {string} notifyHistoryId Id of page in mongodb
         * @param {string} actionName Action name
         * @param {string} groupId Group id
         * @param {NotifyHistoryRunActionV1VEnum} [v] Version (automatically defaults to 1 based on method version, can be overridden)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyHistoryRunActionV1: async (notifyHistoryId, actionName, groupId, v, options = {}) => {
            // verify required parameter 'notifyHistoryId' is not null or undefined
            (0, common_1.assertParamExists)('notifyHistoryRunActionV1', 'notifyHistoryId', notifyHistoryId);
            // verify required parameter 'actionName' is not null or undefined
            (0, common_1.assertParamExists)('notifyHistoryRunActionV1', 'actionName', actionName);
            // verify required parameter 'groupId' is not null or undefined
            (0, common_1.assertParamExists)('notifyHistoryRunActionV1', 'groupId', groupId);
            const localVarPath = `/method/notify_history/run_action`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (notifyHistoryId !== undefined) {
                localVarQueryParameter['notify_history_id'] = notifyHistoryId;
            }
            if (actionName !== undefined) {
                localVarQueryParameter['action_name'] = actionName;
            }
            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Set all notification in cabinet as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyHistorySetAllCabinetReadV1: async (options = {}) => {
            const localVarPath = `/method/notify_history/set_all_cabinet_read`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.NotifyHistoryApiAxiosParamCreator = NotifyHistoryApiAxiosParamCreator;
/**
 * NotifyHistoryApi - functional programming interface
 * @export
 */
const NotifyHistoryApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.NotifyHistoryApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Get list of my notifications
         * @param {NotifyHistoryGetListMyV1LanguageEnum} language Current language
         * @param {NotifyHistoryGetListMyV1VEnum} [v] Version (automatically defaults to 1 based on method version, can be overridden)
         * @param {number} [limit] Number of results
         * @param {number} [offset] Page offset number
         * @param {number} [projectId] Project id
         * @param {NotifyHistoryGetListMyV1NameEnum} [name] Name
         * @param {NotifyHistoryGetListMyV1ChannelEnum} [channel] Channel
         * @param {string} [dateFrom] Date from
         * @param {string} [dateTo] Date to
         * @param {NotifyHistoryGetListMyV1StatusReadEnum} [statusRead] Status read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyHistoryGetListMyV1(language, v, limit, offset, projectId, name, channel, dateFrom, dateTo, statusRead, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyHistoryGetListMyV1(language, v, limit, offset, projectId, name, channel, dateFrom, dateTo, statusRead, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotifyHistoryApi.notifyHistoryGetListMyV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get my status unread message for user
         * @param {NotifyHistoryGetStatusMyV1LanguageEnum} language Current language
         * @param {NotifyHistoryGetStatusMyV1VEnum} [v] Version (automatically defaults to 1 based on method version, can be overridden)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyHistoryGetStatusMyV1(language, v, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyHistoryGetStatusMyV1(language, v, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotifyHistoryApi.notifyHistoryGetStatusMyV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get my NotifyHistory item by id
         * @param {string} id Id of page in mongodb
         * @param {NotifyHistoryGetV1VEnum} [v] Version (automatically defaults to 1 based on method version, can be overridden)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyHistoryGetV1(id, v, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyHistoryGetV1(id, v, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotifyHistoryApi.notifyHistoryGetV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Set notification in cabinet as read
         * @param {NotifyHistoryMarkOfReadV1LanguageEnum} language Current language
         * @param {SiteMarkReadHistoryRequest} siteMarkReadHistoryRequest
         * @param {NotifyHistoryMarkOfReadV1VEnum} [v] Version (automatically defaults to 1 based on method version, can be overridden)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyHistoryMarkOfReadV1(language, siteMarkReadHistoryRequest, v, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyHistoryMarkOfReadV1(language, siteMarkReadHistoryRequest, v, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotifyHistoryApi.notifyHistoryMarkOfReadV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Run action in my notify item
         * @param {string} notifyHistoryId Id of page in mongodb
         * @param {string} actionName Action name
         * @param {string} groupId Group id
         * @param {NotifyHistoryRunActionV1VEnum} [v] Version (automatically defaults to 1 based on method version, can be overridden)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyHistoryRunActionV1(notifyHistoryId, actionName, groupId, v, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyHistoryRunActionV1(notifyHistoryId, actionName, groupId, v, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotifyHistoryApi.notifyHistoryRunActionV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Set all notification in cabinet as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyHistorySetAllCabinetReadV1(options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyHistorySetAllCabinetReadV1(options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotifyHistoryApi.notifyHistorySetAllCabinetReadV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.NotifyHistoryApiFp = NotifyHistoryApiFp;
/**
 * NotifyHistoryApi - factory interface
 * @export
 */
const NotifyHistoryApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.NotifyHistoryApiFp)(configuration);
    return {
        /**
         *
         * @summary Get list of my notifications
         * @param {NotifyHistoryApiNotifyHistoryGetListMyV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyHistoryGetListMyV1(requestParameters, options) {
            return localVarFp.notifyHistoryGetListMyV1(requestParameters.language, requestParameters.v, requestParameters.limit, requestParameters.offset, requestParameters.projectId, requestParameters.name, requestParameters.channel, requestParameters.dateFrom, requestParameters.dateTo, requestParameters.statusRead, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get my status unread message for user
         * @param {NotifyHistoryApiNotifyHistoryGetStatusMyV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyHistoryGetStatusMyV1(requestParameters, options) {
            return localVarFp.notifyHistoryGetStatusMyV1(requestParameters.language, requestParameters.v, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get my NotifyHistory item by id
         * @param {NotifyHistoryApiNotifyHistoryGetV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyHistoryGetV1(requestParameters, options) {
            return localVarFp.notifyHistoryGetV1(requestParameters.id, requestParameters.v, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Set notification in cabinet as read
         * @param {NotifyHistoryApiNotifyHistoryMarkOfReadV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyHistoryMarkOfReadV1(requestParameters, options) {
            return localVarFp.notifyHistoryMarkOfReadV1(requestParameters.language, requestParameters.siteMarkReadHistoryRequest, requestParameters.v, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Run action in my notify item
         * @param {NotifyHistoryApiNotifyHistoryRunActionV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyHistoryRunActionV1(requestParameters, options) {
            return localVarFp.notifyHistoryRunActionV1(requestParameters.notifyHistoryId, requestParameters.actionName, requestParameters.groupId, requestParameters.v, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Set all notification in cabinet as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyHistorySetAllCabinetReadV1(options) {
            return localVarFp.notifyHistorySetAllCabinetReadV1(options).then((request) => request(axios, basePath));
        },
    };
};
exports.NotifyHistoryApiFactory = NotifyHistoryApiFactory;
/**
 * NotifyHistoryApi - object-oriented interface
 * @export
 * @class NotifyHistoryApi
 * @extends {BaseAPI}
 */
class NotifyHistoryApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get list of my notifications
     * @param {NotifyHistoryApiNotifyHistoryGetListMyV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApi
     */
    notifyHistoryGetListMyV1(requestParameters, options) {
        return (0, exports.NotifyHistoryApiFp)(this.configuration).notifyHistoryGetListMyV1(requestParameters.language, requestParameters.v, requestParameters.limit, requestParameters.offset, requestParameters.projectId, requestParameters.name, requestParameters.channel, requestParameters.dateFrom, requestParameters.dateTo, requestParameters.statusRead, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get my status unread message for user
     * @param {NotifyHistoryApiNotifyHistoryGetStatusMyV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApi
     */
    notifyHistoryGetStatusMyV1(requestParameters, options) {
        return (0, exports.NotifyHistoryApiFp)(this.configuration).notifyHistoryGetStatusMyV1(requestParameters.language, requestParameters.v, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get my NotifyHistory item by id
     * @param {NotifyHistoryApiNotifyHistoryGetV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApi
     */
    notifyHistoryGetV1(requestParameters, options) {
        return (0, exports.NotifyHistoryApiFp)(this.configuration).notifyHistoryGetV1(requestParameters.id, requestParameters.v, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Set notification in cabinet as read
     * @param {NotifyHistoryApiNotifyHistoryMarkOfReadV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApi
     */
    notifyHistoryMarkOfReadV1(requestParameters, options) {
        return (0, exports.NotifyHistoryApiFp)(this.configuration).notifyHistoryMarkOfReadV1(requestParameters.language, requestParameters.siteMarkReadHistoryRequest, requestParameters.v, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Run action in my notify item
     * @param {NotifyHistoryApiNotifyHistoryRunActionV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApi
     */
    notifyHistoryRunActionV1(requestParameters, options) {
        return (0, exports.NotifyHistoryApiFp)(this.configuration).notifyHistoryRunActionV1(requestParameters.notifyHistoryId, requestParameters.actionName, requestParameters.groupId, requestParameters.v, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Set all notification in cabinet as read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApi
     */
    notifyHistorySetAllCabinetReadV1(options) {
        return (0, exports.NotifyHistoryApiFp)(this.configuration).notifyHistorySetAllCabinetReadV1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.NotifyHistoryApi = NotifyHistoryApi;
/**
 * @export
 */
exports.NotifyHistoryGetListMyV1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
};
/**
 * @export
 */
exports.NotifyHistoryGetListMyV1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
};
/**
 * @export
 */
exports.NotifyHistoryGetListMyV1NameEnum = {
    HighBitrate: 'high_bitrate',
    RequestAccessChannel: 'request_access_channel',
    RequestAccessProject: 'request_access_project',
    PromocodeTest: 'promocode_test',
    StreamTest: 'stream_test',
    PlanRestreamExpires: 'plan_restream_expires',
    PlanRestreamExpired: 'plan_restream_expired',
    PlanRestreamRenewed: 'plan_restream_renewed',
    PlanTranscoderExpires: 'plan_transcoder_expires',
    PlanTranscoderExpired: 'plan_transcoder_expired',
    PlanTranscoderRenewed: 'plan_transcoder_renewed',
    PlanStorageExpires: 'plan_storage_expires',
    PlanStorageExpired: 'plan_storage_expired',
    PlanStorageRenewed: 'plan_storage_renewed',
    BroadcastUnsupportedCodec: 'broadcast_unsupported_codec',
    BroadcastUnsupportedCodecScreen: 'broadcast_unsupported_codec_screen',
    BroadcastBitrateExceededScreen: 'broadcast_bitrate_exceeded_screen',
    RtmpConnectOldServerScreen: 'rtmp_connect_old_server_screen',
    BroadcastNotAudio: 'broadcast_not_audio',
    BroadcastBitrateExceeded: 'broadcast_bitrate_exceeded',
    BroadcastStarted: 'broadcast_started',
    BroadcastStopped: 'broadcast_stopped',
    RestreamCheckTwitchBitrate1: 'restream_check_twitch_bitrate_1',
    ApiPauseStart: 'api_pause_start',
    ApiPauseEnd: 'api_pause_end',
    ApiWaitEdit: 'api_wait_edit',
    ApiRestreamStart: 'api_restream_start',
    ApiRestreamStop: 'api_restream_stop',
    ApiDropBroadcast: 'api_drop_broadcast',
    ApiDropBroadcastRemoveCompany: 'api_drop_broadcast_remove_company',
    ApiDropBroadcastUpdateKey: 'api_drop_broadcast_update_key',
    PublisherDisconnected: 'publisher_disconnected',
    PublisherConnected: 'publisher_connected',
    PublisherInitializing: 'publisher_initializing',
    PublisherClose: 'publisher_close',
    BroadcastConnectedStart: 'broadcast_connected_start',
    BroadcastConnectedEnd: 'broadcast_connected_end',
    BroadcastConnectingStream: 'broadcast_connecting_stream',
    BroadcastStartedNewStream: 'broadcast_started_new_stream',
    BroadcastConnectingLost: 'broadcast_connecting_lost',
    BroadcastVideoLostStart: 'broadcast_video_lost_start',
    BroadcastVideoLostEnd: 'broadcast_video_lost_end',
    BroadcastVideoPauseStart: 'broadcast_video_pause_start',
    BroadcastVideoPauseEnd: 'broadcast_video_pause_end',
    BroadcastInitRestream: 'broadcast_init_restream',
    StartStream: 'start_stream',
    CreateReader: 'create_reader',
    StartChannel: 'start_channel',
    StopChannel: 'stop_channel',
    StopStreamVideoTimeout: 'stop_stream_video_timeout',
    StopStreamNoStartVideo: 'stop_stream_no_start_video',
    StopStream: 'stop_stream',
    DeleteReader: 'delete_reader',
    TranscoderStart: 'transcoder_start',
    TranscoderStop: 'transcoder_stop',
    StartChannelFailed: 'start_channel_failed',
    StartChannelSuccess: 'start_channel_success',
    ApiChannelInitializingStart: 'api_channel_initializing_start',
    ApiChannelInitializingFailed: 'api_channel_initializing_failed',
    ApiChannelInitializingSuccess: 'api_channel_initializing_success',
    ChannelApiUpdateSettingsSuccess: 'channel_api_update_settings_success',
    ChannelApiUpdateSettingsError: 'channel_api_update_settings_error',
    ChannelApiUpdatePlaylistSuccess: 'channel_api_update_playlist_success',
    ChannelApiUpdatePlaylistError: 'channel_api_update_playlist_error',
    ChannelApiUpdateChatError: 'channel_api_update_chat_error',
    ChannelApiStreamKeySuccess: 'channel_api_stream_key_success',
    ChannelApiStreamKeyError: 'channel_api_stream_key_error',
    ChannelApiAutoStopDisableSuccess: 'channel_api_auto_stop_disable_success',
    ChannelApiAutoStopDisableError: 'channel_api_auto_stop_disable_error',
    ChannelApiUnbindingStreamKeyError: 'channel_api_unbinding_stream_key_error',
    ChannelApiCreateBroadcastSuccess: 'channel_api_create_broadcast_success',
    ChannelApiCreateBroadcastError: 'channel_api_create_broadcast_error',
    ChannelApiSetPlannedSuccess: 'channel_api_set_planned_success',
    ChannelApiSetPlannedError: 'channel_api_set_planned_error',
    ChannelApiSetThumbnailSuccess: 'channel_api_set_thumbnail_success',
    ChannelApiSetThumbnailError: 'channel_api_set_thumbnail_error',
    ChannelTokenError: 'channel_token_error',
    ChannelApiGroupFailed: 'channel_api_group_failed',
    NoAudioReader: 'no_audio_reader',
    RestreamCheckTwitchBitrate2: 'restream_check_twitch_bitrate_2',
    TranscoderSupportErrorScreen: 'transcoder_support_error_screen',
    TranscoderTariffEndScreen: 'transcoder_tariff_end_screen',
    TranscoderCountFlowScreen: 'transcoder_count_flow_screen',
    TranscoderResolutionScreen: 'transcoder_resolution_screen',
    StreamKeyBanned: 'stream_key_banned',
    BroadcastChangeCodec: 'broadcast_change_codec',
    BroadcastChangeRegion: 'broadcast_change_region',
    VideoUploadError: 'video_upload_error',
    StopChannelError: 'stop_channel_error',
    BroadcastUserActionStop: 'broadcast_user_action_stop'
};
/**
 * @export
 */
exports.NotifyHistoryGetListMyV1ChannelEnum = {
    Telegram: 'telegram',
    Cabinet: 'cabinet',
    Mobile: 'mobile'
};
/**
 * @export
 */
exports.NotifyHistoryGetListMyV1StatusReadEnum = {
    Unread: 'unread',
    Read: 'read'
};
/**
 * @export
 */
exports.NotifyHistoryGetStatusMyV1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
};
/**
 * @export
 */
exports.NotifyHistoryGetStatusMyV1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
};
/**
 * @export
 */
exports.NotifyHistoryGetV1VEnum = {
    _1: '1'
};
/**
 * @export
 */
exports.NotifyHistoryMarkOfReadV1LanguageEnum = {
    Ru: 'ru',
    En: 'en',
    Cn: 'cn'
};
/**
 * @export
 */
exports.NotifyHistoryMarkOfReadV1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
};
/**
 * @export
 */
exports.NotifyHistoryRunActionV1VEnum = {
    _1: '1'
};
