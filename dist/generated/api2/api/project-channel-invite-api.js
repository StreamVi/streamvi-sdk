"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * StreamVi Backend
 * API
 *
 * The version of the OpenAPI document: 3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.list1LanguageEnum = exports.list1VEnum = exports.getForSecret1LanguageEnum = exports.getForSecret1VEnum = exports.getForProject1LanguageEnum = exports.getForProject1VEnum = exports.get1LanguageEnum = exports.get1VEnum = exports.del1LanguageEnum = exports.del1VEnum = exports.declineForSecret1LanguageEnum = exports.declineForSecret1VEnum = exports.declineForProject1LanguageEnum = exports.declineForProject1VEnum = exports.addById1AccessTypeEnum = exports.addById1LanguageEnum = exports.addById1VEnum = exports.addByEmail1AccessTypeEnum = exports.addByEmail1LanguageEnum = exports.addByEmail1VEnum = exports.acceptForSecret1LanguageEnum = exports.acceptForSecret1VEnum = exports.acceptForProject1LanguageEnum = exports.acceptForProject1VEnum = exports.ProjectChannelInviteApi = exports.factory = exports.fp = exports.axiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * ProjectChannelInviteApi - axios parameter creator
 * @export
 */
const axiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Accept channel invitation for selected project
         * @param {acceptForProject1VEnum} v Version
         * @param {acceptForProject1LanguageEnum} language Current language
         * @param {number} projectId The project to which you want to add a channel
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptForProject1: async (v, language, projectId, channelId, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('acceptForProject1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('acceptForProject1', 'language', language);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('acceptForProject1', 'projectId', projectId);
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('acceptForProject1', 'channelId', channelId);
            const localVarPath = `/method/channel_invite/accept_for_project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Accept channel invitation using a secret link
         * @param {acceptForSecret1VEnum} v Version
         * @param {acceptForSecret1LanguageEnum} language Current language
         * @param {number} projectId The project to which you want to add a channel
         * @param {number} channelId Channel id
         * @param {string} secret Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptForSecret1: async (v, language, projectId, channelId, secret, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('acceptForSecret1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('acceptForSecret1', 'language', language);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('acceptForSecret1', 'projectId', projectId);
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('acceptForSecret1', 'channelId', channelId);
            // verify required parameter 'secret' is not null or undefined
            (0, common_1.assertParamExists)('acceptForSecret1', 'secret', secret);
            const localVarPath = `/method/channel_invite/accept_for_secret`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }
            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add channel invite item for another user by email
         * @param {addByEmail1VEnum} v Version
         * @param {addByEmail1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {string} email Email
         * @param {addByEmail1AccessTypeEnum} accessType Access type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addByEmail1: async (v, language, projectId, channelId, email, accessType, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('addByEmail1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('addByEmail1', 'language', language);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('addByEmail1', 'projectId', projectId);
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('addByEmail1', 'channelId', channelId);
            // verify required parameter 'email' is not null or undefined
            (0, common_1.assertParamExists)('addByEmail1', 'email', email);
            // verify required parameter 'accessType' is not null or undefined
            (0, common_1.assertParamExists)('addByEmail1', 'accessType', accessType);
            const localVarPath = `/method/channel_invite/add_by_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }
            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }
            if (accessType !== undefined) {
                localVarQueryParameter['access_type'] = accessType;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add channel invite item for another user by id
         * @param {addById1VEnum} v Version
         * @param {addById1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {addById1AccessTypeEnum} accessType Access type
         * @param {string} toProjectExternalId Project for get access by external id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addById1: async (v, language, projectId, channelId, accessType, toProjectExternalId, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('addById1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('addById1', 'language', language);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('addById1', 'projectId', projectId);
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('addById1', 'channelId', channelId);
            // verify required parameter 'accessType' is not null or undefined
            (0, common_1.assertParamExists)('addById1', 'accessType', accessType);
            // verify required parameter 'toProjectExternalId' is not null or undefined
            (0, common_1.assertParamExists)('addById1', 'toProjectExternalId', toProjectExternalId);
            const localVarPath = `/method/channel_invite/add_by_id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }
            if (accessType !== undefined) {
                localVarQueryParameter['access_type'] = accessType;
            }
            if (toProjectExternalId !== undefined) {
                localVarQueryParameter['to_project_external_id'] = toProjectExternalId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Decline channel invitation for selected project
         * @param {declineForProject1VEnum} v Version
         * @param {declineForProject1LanguageEnum} language Current language
         * @param {number} projectId Channel id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineForProject1: async (v, language, projectId, channelId, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('declineForProject1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('declineForProject1', 'language', language);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('declineForProject1', 'projectId', projectId);
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('declineForProject1', 'channelId', channelId);
            const localVarPath = `/method/channel_invite/decline_for_project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Decline channel invitation using a secret link
         * @param {declineForSecret1VEnum} v Version
         * @param {declineForSecret1LanguageEnum} language Current language
         * @param {number} projectId The project to which you want to add a channel
         * @param {number} channelId Channel id
         * @param {string} secret Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineForSecret1: async (v, language, projectId, channelId, secret, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('declineForSecret1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('declineForSecret1', 'language', language);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('declineForSecret1', 'projectId', projectId);
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('declineForSecret1', 'channelId', channelId);
            // verify required parameter 'secret' is not null or undefined
            (0, common_1.assertParamExists)('declineForSecret1', 'secret', secret);
            const localVarPath = `/method/channel_invite/decline_for_secret`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }
            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Del channel invite item for my channel for another user
         * @param {del1VEnum} v Version
         * @param {del1LanguageEnum} language Current language
         * @param {number} id Unique id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        del1: async (v, language, id, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('del1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('del1', 'language', language);
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('del1', 'id', id);
            const localVarPath = `/method/channel_invite/del`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get channel invite item for my channel for another user
         * @param {get1VEnum} v Version
         * @param {get1LanguageEnum} language Current language
         * @param {number} id Channel request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1: async (v, language, id, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('get1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('get1', 'language', language);
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('get1', 'id', id);
            const localVarPath = `/method/channel_invite/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get invitation for channel
         * @param {getForProject1VEnum} v Version
         * @param {getForProject1LanguageEnum} language Current language
         * @param {number} projectId Current project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForProject1: async (v, language, projectId, channelId, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('getForProject1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('getForProject1', 'language', language);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('getForProject1', 'projectId', projectId);
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('getForProject1', 'channelId', channelId);
            const localVarPath = `/method/channel_invite/get_for_project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get channel invitation using a secret link
         * @param {getForSecret1VEnum} v Version
         * @param {getForSecret1LanguageEnum} language Current language
         * @param {number} channelId Channel id
         * @param {string} secret Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSecret1: async (v, language, channelId, secret, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('getForSecret1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('getForSecret1', 'language', language);
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('getForSecret1', 'channelId', channelId);
            // verify required parameter 'secret' is not null or undefined
            (0, common_1.assertParamExists)('getForSecret1', 'secret', secret);
            const localVarPath = `/method/channel_invite/get_for_secret`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }
            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List of invites for channel in project
         * @param {list1VEnum} v Version
         * @param {list1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list1: async (v, language, projectId, channelId, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('list1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('list1', 'language', language);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('list1', 'projectId', projectId);
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('list1', 'channelId', channelId);
            const localVarPath = `/method/channel_invite/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.axiosParamCreator = axiosParamCreator;
/**
 * ProjectChannelInviteApi - functional programming interface
 * @export
 */
const fp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.axiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Accept channel invitation for selected project
         * @param {acceptForProject1VEnum} v Version
         * @param {acceptForProject1LanguageEnum} language Current language
         * @param {number} projectId The project to which you want to add a channel
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptForProject1(v, language, projectId, channelId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptForProject1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProjectChannelInviteApi.acceptForProject1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Accept channel invitation using a secret link
         * @param {acceptForSecret1VEnum} v Version
         * @param {acceptForSecret1LanguageEnum} language Current language
         * @param {number} projectId The project to which you want to add a channel
         * @param {number} channelId Channel id
         * @param {string} secret Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptForSecret1(v, language, projectId, channelId, secret, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptForSecret1(v, language, projectId, channelId, secret, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProjectChannelInviteApi.acceptForSecret1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Add channel invite item for another user by email
         * @param {addByEmail1VEnum} v Version
         * @param {addByEmail1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {string} email Email
         * @param {addByEmail1AccessTypeEnum} accessType Access type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addByEmail1(v, language, projectId, channelId, email, accessType, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.addByEmail1(v, language, projectId, channelId, email, accessType, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProjectChannelInviteApi.addByEmail1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Add channel invite item for another user by id
         * @param {addById1VEnum} v Version
         * @param {addById1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {addById1AccessTypeEnum} accessType Access type
         * @param {string} toProjectExternalId Project for get access by external id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addById1(v, language, projectId, channelId, accessType, toProjectExternalId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.addById1(v, language, projectId, channelId, accessType, toProjectExternalId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProjectChannelInviteApi.addById1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Decline channel invitation for selected project
         * @param {declineForProject1VEnum} v Version
         * @param {declineForProject1LanguageEnum} language Current language
         * @param {number} projectId Channel id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async declineForProject1(v, language, projectId, channelId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.declineForProject1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProjectChannelInviteApi.declineForProject1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Decline channel invitation using a secret link
         * @param {declineForSecret1VEnum} v Version
         * @param {declineForSecret1LanguageEnum} language Current language
         * @param {number} projectId The project to which you want to add a channel
         * @param {number} channelId Channel id
         * @param {string} secret Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async declineForSecret1(v, language, projectId, channelId, secret, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.declineForSecret1(v, language, projectId, channelId, secret, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProjectChannelInviteApi.declineForSecret1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Del channel invite item for my channel for another user
         * @param {del1VEnum} v Version
         * @param {del1LanguageEnum} language Current language
         * @param {number} id Unique id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async del1(v, language, id, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.del1(v, language, id, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProjectChannelInviteApi.del1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get channel invite item for my channel for another user
         * @param {get1VEnum} v Version
         * @param {get1LanguageEnum} language Current language
         * @param {number} id Channel request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get1(v, language, id, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.get1(v, language, id, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProjectChannelInviteApi.get1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get invitation for channel
         * @param {getForProject1VEnum} v Version
         * @param {getForProject1LanguageEnum} language Current language
         * @param {number} projectId Current project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForProject1(v, language, projectId, channelId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForProject1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProjectChannelInviteApi.getForProject1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get channel invitation using a secret link
         * @param {getForSecret1VEnum} v Version
         * @param {getForSecret1LanguageEnum} language Current language
         * @param {number} channelId Channel id
         * @param {string} secret Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForSecret1(v, language, channelId, secret, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForSecret1(v, language, channelId, secret, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProjectChannelInviteApi.getForSecret1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List of invites for channel in project
         * @param {list1VEnum} v Version
         * @param {list1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list1(v, language, projectId, channelId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.list1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProjectChannelInviteApi.list1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.fp = fp;
/**
 * ProjectChannelInviteApi - factory interface
 * @export
 */
const factory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.fp)(configuration);
    return {
        /**
         *
         * @summary Accept channel invitation for selected project
         * @param {acceptForProject1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptForProject1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || acceptForProject1VEnum._1;
            return localVarFp.acceptForProject1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Accept channel invitation using a secret link
         * @param {acceptForSecret1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptForSecret1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || acceptForSecret1VEnum._1;
            return localVarFp.acceptForSecret1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.secret, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add channel invite item for another user by email
         * @param {addByEmail1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addByEmail1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || addByEmail1VEnum._1;
            return localVarFp.addByEmail1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.email, requestParameters.accessType, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add channel invite item for another user by id
         * @param {addById1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addById1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || addById1VEnum._1;
            return localVarFp.addById1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.accessType, requestParameters.toProjectExternalId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Decline channel invitation for selected project
         * @param {declineForProject1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineForProject1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || declineForProject1VEnum._1;
            return localVarFp.declineForProject1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Decline channel invitation using a secret link
         * @param {declineForSecret1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineForSecret1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || declineForSecret1VEnum._1;
            return localVarFp.declineForSecret1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.secret, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Del channel invite item for my channel for another user
         * @param {del1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        del1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || del1VEnum._1;
            return localVarFp.del1(actualV, requestParameters.language, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get channel invite item for my channel for another user
         * @param {get1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || get1VEnum._1;
            return localVarFp.get1(actualV, requestParameters.language, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get invitation for channel
         * @param {getForProject1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForProject1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || getForProject1VEnum._1;
            return localVarFp.getForProject1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get channel invitation using a secret link
         * @param {getForSecret1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSecret1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || getForSecret1VEnum._1;
            return localVarFp.getForSecret1(actualV, requestParameters.language, requestParameters.channelId, requestParameters.secret, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List of invites for channel in project
         * @param {list1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || list1VEnum._1;
            return localVarFp.list1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.factory = factory;
/**
 * ProjectChannelInviteApi - object-oriented interface
 * @export
 * @class ProjectChannelInviteApi
 * @extends {BaseAPI}
 */
class ProjectChannelInviteApi extends base_1.BaseAPI {
    /**
     *
     * @summary Accept channel invitation for selected project
     * @param {acceptForProject1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    acceptForProject1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || acceptForProject1VEnum._1;
        return (0, exports.fp)(this.configuration).acceptForProject1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Accept channel invitation using a secret link
     * @param {acceptForSecret1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    acceptForSecret1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || acceptForSecret1VEnum._1;
        return (0, exports.fp)(this.configuration).acceptForSecret1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.secret, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add channel invite item for another user by email
     * @param {addByEmail1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    addByEmail1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || addByEmail1VEnum._1;
        return (0, exports.fp)(this.configuration).addByEmail1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.email, requestParameters.accessType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add channel invite item for another user by id
     * @param {addById1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    addById1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || addById1VEnum._1;
        return (0, exports.fp)(this.configuration).addById1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.accessType, requestParameters.toProjectExternalId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Decline channel invitation for selected project
     * @param {declineForProject1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    declineForProject1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || declineForProject1VEnum._1;
        return (0, exports.fp)(this.configuration).declineForProject1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Decline channel invitation using a secret link
     * @param {declineForSecret1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    declineForSecret1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || declineForSecret1VEnum._1;
        return (0, exports.fp)(this.configuration).declineForSecret1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.secret, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Del channel invite item for my channel for another user
     * @param {del1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    del1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || del1VEnum._1;
        return (0, exports.fp)(this.configuration).del1(actualV, requestParameters.language, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get channel invite item for my channel for another user
     * @param {get1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    get1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || get1VEnum._1;
        return (0, exports.fp)(this.configuration).get1(actualV, requestParameters.language, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get invitation for channel
     * @param {getForProject1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    getForProject1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || getForProject1VEnum._1;
        return (0, exports.fp)(this.configuration).getForProject1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get channel invitation using a secret link
     * @param {getForSecret1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    getForSecret1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || getForSecret1VEnum._1;
        return (0, exports.fp)(this.configuration).getForSecret1(actualV, requestParameters.language, requestParameters.channelId, requestParameters.secret, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List of invites for channel in project
     * @param {list1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectChannelInviteApi
     */
    list1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || list1VEnum._1;
        return (0, exports.fp)(this.configuration).list1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProjectChannelInviteApi = ProjectChannelInviteApi;
/**
  * @export
  * @enum {string}
  */
var acceptForProject1VEnum;
(function (acceptForProject1VEnum) {
    acceptForProject1VEnum["_1"] = "1";
    acceptForProject1VEnum["_2"] = "2";
    acceptForProject1VEnum["_3"] = "3";
})(acceptForProject1VEnum || (exports.acceptForProject1VEnum = acceptForProject1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var acceptForProject1LanguageEnum;
(function (acceptForProject1LanguageEnum) {
    acceptForProject1LanguageEnum["ru"] = "ru";
    acceptForProject1LanguageEnum["en"] = "en";
    acceptForProject1LanguageEnum["cn"] = "cn";
})(acceptForProject1LanguageEnum || (exports.acceptForProject1LanguageEnum = acceptForProject1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var acceptForSecret1VEnum;
(function (acceptForSecret1VEnum) {
    acceptForSecret1VEnum["_1"] = "1";
    acceptForSecret1VEnum["_2"] = "2";
    acceptForSecret1VEnum["_3"] = "3";
})(acceptForSecret1VEnum || (exports.acceptForSecret1VEnum = acceptForSecret1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var acceptForSecret1LanguageEnum;
(function (acceptForSecret1LanguageEnum) {
    acceptForSecret1LanguageEnum["ru"] = "ru";
    acceptForSecret1LanguageEnum["en"] = "en";
    acceptForSecret1LanguageEnum["cn"] = "cn";
})(acceptForSecret1LanguageEnum || (exports.acceptForSecret1LanguageEnum = acceptForSecret1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var addByEmail1VEnum;
(function (addByEmail1VEnum) {
    addByEmail1VEnum["_1"] = "1";
    addByEmail1VEnum["_2"] = "2";
    addByEmail1VEnum["_3"] = "3";
})(addByEmail1VEnum || (exports.addByEmail1VEnum = addByEmail1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var addByEmail1LanguageEnum;
(function (addByEmail1LanguageEnum) {
    addByEmail1LanguageEnum["ru"] = "ru";
    addByEmail1LanguageEnum["en"] = "en";
    addByEmail1LanguageEnum["cn"] = "cn";
})(addByEmail1LanguageEnum || (exports.addByEmail1LanguageEnum = addByEmail1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var addByEmail1AccessTypeEnum;
(function (addByEmail1AccessTypeEnum) {
    addByEmail1AccessTypeEnum[addByEmail1AccessTypeEnum["NUMBER_0"] = 0] = "NUMBER_0";
    addByEmail1AccessTypeEnum[addByEmail1AccessTypeEnum["NUMBER_1"] = 1] = "NUMBER_1";
    addByEmail1AccessTypeEnum[addByEmail1AccessTypeEnum["NUMBER_12"] = 1] = "NUMBER_12";
    addByEmail1AccessTypeEnum[addByEmail1AccessTypeEnum["NUMBER_2"] = 2] = "NUMBER_2";
})(addByEmail1AccessTypeEnum || (exports.addByEmail1AccessTypeEnum = addByEmail1AccessTypeEnum = {}));
/**
  * @export
  * @enum {string}
  */
var addById1VEnum;
(function (addById1VEnum) {
    addById1VEnum["_1"] = "1";
    addById1VEnum["_2"] = "2";
    addById1VEnum["_3"] = "3";
})(addById1VEnum || (exports.addById1VEnum = addById1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var addById1LanguageEnum;
(function (addById1LanguageEnum) {
    addById1LanguageEnum["ru"] = "ru";
    addById1LanguageEnum["en"] = "en";
    addById1LanguageEnum["cn"] = "cn";
})(addById1LanguageEnum || (exports.addById1LanguageEnum = addById1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var addById1AccessTypeEnum;
(function (addById1AccessTypeEnum) {
    addById1AccessTypeEnum[addById1AccessTypeEnum["NUMBER_0"] = 0] = "NUMBER_0";
    addById1AccessTypeEnum[addById1AccessTypeEnum["NUMBER_1"] = 1] = "NUMBER_1";
    addById1AccessTypeEnum[addById1AccessTypeEnum["NUMBER_12"] = 1] = "NUMBER_12";
    addById1AccessTypeEnum[addById1AccessTypeEnum["NUMBER_2"] = 2] = "NUMBER_2";
})(addById1AccessTypeEnum || (exports.addById1AccessTypeEnum = addById1AccessTypeEnum = {}));
/**
  * @export
  * @enum {string}
  */
var declineForProject1VEnum;
(function (declineForProject1VEnum) {
    declineForProject1VEnum["_1"] = "1";
    declineForProject1VEnum["_2"] = "2";
    declineForProject1VEnum["_3"] = "3";
})(declineForProject1VEnum || (exports.declineForProject1VEnum = declineForProject1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var declineForProject1LanguageEnum;
(function (declineForProject1LanguageEnum) {
    declineForProject1LanguageEnum["ru"] = "ru";
    declineForProject1LanguageEnum["en"] = "en";
    declineForProject1LanguageEnum["cn"] = "cn";
})(declineForProject1LanguageEnum || (exports.declineForProject1LanguageEnum = declineForProject1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var declineForSecret1VEnum;
(function (declineForSecret1VEnum) {
    declineForSecret1VEnum["_1"] = "1";
    declineForSecret1VEnum["_2"] = "2";
    declineForSecret1VEnum["_3"] = "3";
})(declineForSecret1VEnum || (exports.declineForSecret1VEnum = declineForSecret1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var declineForSecret1LanguageEnum;
(function (declineForSecret1LanguageEnum) {
    declineForSecret1LanguageEnum["ru"] = "ru";
    declineForSecret1LanguageEnum["en"] = "en";
    declineForSecret1LanguageEnum["cn"] = "cn";
})(declineForSecret1LanguageEnum || (exports.declineForSecret1LanguageEnum = declineForSecret1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var del1VEnum;
(function (del1VEnum) {
    del1VEnum["_1"] = "1";
    del1VEnum["_2"] = "2";
    del1VEnum["_3"] = "3";
})(del1VEnum || (exports.del1VEnum = del1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var del1LanguageEnum;
(function (del1LanguageEnum) {
    del1LanguageEnum["ru"] = "ru";
    del1LanguageEnum["en"] = "en";
    del1LanguageEnum["cn"] = "cn";
})(del1LanguageEnum || (exports.del1LanguageEnum = del1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var get1VEnum;
(function (get1VEnum) {
    get1VEnum["_1"] = "1";
    get1VEnum["_2"] = "2";
    get1VEnum["_3"] = "3";
})(get1VEnum || (exports.get1VEnum = get1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var get1LanguageEnum;
(function (get1LanguageEnum) {
    get1LanguageEnum["ru"] = "ru";
    get1LanguageEnum["en"] = "en";
    get1LanguageEnum["cn"] = "cn";
})(get1LanguageEnum || (exports.get1LanguageEnum = get1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var getForProject1VEnum;
(function (getForProject1VEnum) {
    getForProject1VEnum["_1"] = "1";
    getForProject1VEnum["_2"] = "2";
    getForProject1VEnum["_3"] = "3";
})(getForProject1VEnum || (exports.getForProject1VEnum = getForProject1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var getForProject1LanguageEnum;
(function (getForProject1LanguageEnum) {
    getForProject1LanguageEnum["ru"] = "ru";
    getForProject1LanguageEnum["en"] = "en";
    getForProject1LanguageEnum["cn"] = "cn";
})(getForProject1LanguageEnum || (exports.getForProject1LanguageEnum = getForProject1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var getForSecret1VEnum;
(function (getForSecret1VEnum) {
    getForSecret1VEnum["_1"] = "1";
    getForSecret1VEnum["_2"] = "2";
    getForSecret1VEnum["_3"] = "3";
})(getForSecret1VEnum || (exports.getForSecret1VEnum = getForSecret1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var getForSecret1LanguageEnum;
(function (getForSecret1LanguageEnum) {
    getForSecret1LanguageEnum["ru"] = "ru";
    getForSecret1LanguageEnum["en"] = "en";
    getForSecret1LanguageEnum["cn"] = "cn";
})(getForSecret1LanguageEnum || (exports.getForSecret1LanguageEnum = getForSecret1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var list1VEnum;
(function (list1VEnum) {
    list1VEnum["_1"] = "1";
    list1VEnum["_2"] = "2";
    list1VEnum["_3"] = "3";
})(list1VEnum || (exports.list1VEnum = list1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var list1LanguageEnum;
(function (list1LanguageEnum) {
    list1LanguageEnum["ru"] = "ru";
    list1LanguageEnum["en"] = "en";
    list1LanguageEnum["cn"] = "cn";
})(list1LanguageEnum || (exports.list1LanguageEnum = list1LanguageEnum = {}));
