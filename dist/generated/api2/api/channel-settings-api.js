"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * StreamVi Backend
 * API
 *
 * The version of the OpenAPI document: 3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelegramGetPostByFilterLanguageEnum = exports.TelegramGetPostByFilterVEnum = exports.updateToken1RoleEnum = exports.updateToken1LanguageEnum = exports.updateToken1VEnum = exports.getPlayList1LanguageEnum = exports.getPlayList1VEnum = exports.getPlanned1LanguageEnum = exports.getPlanned1VEnum = exports.telegramPosts1LanguageEnum = exports.telegramPosts1VEnum = exports.setTelegramSetting1LanguageEnum = exports.setTelegramSetting1VEnum = exports.removeTelegramChat1LanguageEnum = exports.removeTelegramChat1VEnum = exports.initTelegramChatConnect1LanguageEnum = exports.initTelegramChatConnect1VEnum = exports.getTelegramSetting1LanguageEnum = exports.getTelegramSetting1VEnum = exports.ChannelSettingsApi = exports.factory = exports.fp = exports.axiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * ChannelSettingsApi - axios parameter creator
 * @export
 */
const axiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get telegram settings
         * @param {getTelegramSetting1VEnum} v Version
         * @param {getTelegramSetting1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegramSetting1: async (v, language, projectId, channelId, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('getTelegramSetting1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('getTelegramSetting1', 'language', language);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('getTelegramSetting1', 'projectId', projectId);
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('getTelegramSetting1', 'channelId', channelId);
            const localVarPath = `/method/channel_settings/chat/telegram/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get code for connected chat
         * @param {initTelegramChatConnect1VEnum} v Version
         * @param {initTelegramChatConnect1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initTelegramChatConnect1: async (v, language, projectId, channelId, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('initTelegramChatConnect1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('initTelegramChatConnect1', 'language', language);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('initTelegramChatConnect1', 'projectId', projectId);
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('initTelegramChatConnect1', 'channelId', channelId);
            const localVarPath = `/method/channel_settings/chat/telegram/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Disconnect telegram chat
         * @param {removeTelegramChat1VEnum} v Version
         * @param {removeTelegramChat1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTelegramChat1: async (v, language, projectId, channelId, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('removeTelegramChat1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('removeTelegramChat1', 'language', language);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('removeTelegramChat1', 'projectId', projectId);
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('removeTelegramChat1', 'channelId', channelId);
            const localVarPath = `/method/channel_settings/chat/telegram/disconnect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Set telegram settings
         * @param {setTelegramSetting1VEnum} v Version
         * @param {setTelegramSetting1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {SiteTelegramSetSettingsRequestDto} siteTelegramSetSettingsRequestDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTelegramSetting1: async (v, language, projectId, channelId, siteTelegramSetSettingsRequestDto, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('setTelegramSetting1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('setTelegramSetting1', 'language', language);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('setTelegramSetting1', 'projectId', projectId);
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('setTelegramSetting1', 'channelId', channelId);
            // verify required parameter 'siteTelegramSetSettingsRequestDto' is not null or undefined
            (0, common_1.assertParamExists)('setTelegramSetting1', 'siteTelegramSetSettingsRequestDto', siteTelegramSetSettingsRequestDto);
            const localVarPath = `/method/channel_settings/chat/telegram/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(siteTelegramSetSettingsRequestDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get telegram post list
         * @param {telegramPosts1VEnum} v Version
         * @param {telegramPosts1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegramPosts1: async (v, language, projectId, channelId, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('telegramPosts1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('telegramPosts1', 'language', language);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('telegramPosts1', 'projectId', projectId);
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('telegramPosts1', 'channelId', channelId);
            const localVarPath = `/method/channel_settings/chat/telegram/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Optional settings for telegram
         * @param {SiteUpdateChatTelegramRequest} siteUpdateChatTelegramRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsTelegram1: async (siteUpdateChatTelegramRequest, options = {}) => {
            // verify required parameter 'siteUpdateChatTelegramRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateOptionsTelegram1', 'siteUpdateChatTelegramRequest', siteUpdateChatTelegramRequest);
            const localVarPath = `/method/channel_settings/chat/setTelegram`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(siteUpdateChatTelegramRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get planned list
         * @param {getPlanned1VEnum} v Version
         * @param {getPlanned1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlanned1: async (v, language, projectId, channelId, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('getPlanned1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('getPlanned1', 'language', language);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('getPlanned1', 'projectId', projectId);
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('getPlanned1', 'channelId', channelId);
            const localVarPath = `/method/channel_settings/options/getPlanned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get playlists from the platform
         * @param {getPlayList1VEnum} v Version
         * @param {getPlayList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayList1: async (v, language, projectId, channelId, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('getPlayList1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('getPlayList1', 'language', language);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('getPlayList1', 'projectId', projectId);
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('getPlayList1', 'channelId', channelId);
            const localVarPath = `/method/channel_settings/options/getPlaylist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Optional settings for ok. Depends on the tariff.
         * @param {SiteUpdateOptionsOkRequest} siteUpdateOptionsOkRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsOk1: async (siteUpdateOptionsOkRequest, options = {}) => {
            // verify required parameter 'siteUpdateOptionsOkRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateOptionsOk1', 'siteUpdateOptionsOkRequest', siteUpdateOptionsOkRequest);
            const localVarPath = `/method/channel_settings/options/setOk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(siteUpdateOptionsOkRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Optional settings for trovo. Depends on the tariff.
         * @param {SiteUpdateOptionsTrovoRequest} siteUpdateOptionsTrovoRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsTrovo1: async (siteUpdateOptionsTrovoRequest, options = {}) => {
            // verify required parameter 'siteUpdateOptionsTrovoRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateOptionsTrovo1', 'siteUpdateOptionsTrovoRequest', siteUpdateOptionsTrovoRequest);
            const localVarPath = `/method/channel_settings/options/setTrovo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(siteUpdateOptionsTrovoRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Optional settings for twitch. Depends on the tariff.
         * @param {SiteUpdateOptionsTwitchRequest} siteUpdateOptionsTwitchRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsTwitch1: async (siteUpdateOptionsTwitchRequest, options = {}) => {
            // verify required parameter 'siteUpdateOptionsTwitchRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateOptionsTwitch1', 'siteUpdateOptionsTwitchRequest', siteUpdateOptionsTwitchRequest);
            const localVarPath = `/method/channel_settings/options/setTwitch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(siteUpdateOptionsTwitchRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Optional settings for vk. Depends on the tariff.
         * @param {SiteUpdateOptionsVkRequest} siteUpdateOptionsVkRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsVk1: async (siteUpdateOptionsVkRequest, options = {}) => {
            // verify required parameter 'siteUpdateOptionsVkRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateOptionsVk1', 'siteUpdateOptionsVkRequest', siteUpdateOptionsVkRequest);
            const localVarPath = `/method/channel_settings/options/setVk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(siteUpdateOptionsVkRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Optional settings for vk video live. Depends on the tariff.
         * @param {SiteUpdateOptionsVkVideoLiveRequest} siteUpdateOptionsVkVideoLiveRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsVkVideoLive1: async (siteUpdateOptionsVkVideoLiveRequest, options = {}) => {
            // verify required parameter 'siteUpdateOptionsVkVideoLiveRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateOptionsVkVideoLive1', 'siteUpdateOptionsVkVideoLiveRequest', siteUpdateOptionsVkVideoLiveRequest);
            const localVarPath = `/method/channel_settings/options/setVkVideoLive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(siteUpdateOptionsVkVideoLiveRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Optional settings for youtube. Depends on the tariff.
         * @param {SiteUpdateOptionsYoutubeRequest} siteUpdateOptionsYoutubeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsYoutube1: async (siteUpdateOptionsYoutubeRequest, options = {}) => {
            // verify required parameter 'siteUpdateOptionsYoutubeRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateOptionsYoutube1', 'siteUpdateOptionsYoutubeRequest', siteUpdateOptionsYoutubeRequest);
            const localVarPath = `/method/channel_settings/options/setYoutube`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(siteUpdateOptionsYoutubeRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Set planned id. Depends on the tariff.
         * @param {SiteSetPlannedRequest} siteSetPlannedRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlanned1: async (siteSetPlannedRequest, options = {}) => {
            // verify required parameter 'siteSetPlannedRequest' is not null or undefined
            (0, common_1.assertParamExists)('updatePlanned1', 'siteSetPlannedRequest', siteSetPlannedRequest);
            const localVarPath = `/method/channel_settings/options/setPlanned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(siteSetPlannedRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get status platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus1: async (options = {}) => {
            const localVarPath = `/method/channel_settings/getStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Set name from custom channel. Global settings.
         * @param {SiteSetNameRequest} siteSetNameRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setName1: async (siteSetNameRequest, options = {}) => {
            // verify required parameter 'siteSetNameRequest' is not null or undefined
            (0, common_1.assertParamExists)('setName1', 'siteSetNameRequest', siteSetNameRequest);
            const localVarPath = `/method/channel_settings/setName`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(siteSetNameRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Set rtmp url from channel. Global settings.
         * @param {SiteSetUrlRequest} siteSetUrlRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRtmp1: async (siteSetUrlRequest, options = {}) => {
            // verify required parameter 'siteSetUrlRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateRtmp1', 'siteSetUrlRequest', siteSetUrlRequest);
            const localVarPath = `/method/channel_settings/setRtmp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(siteSetUrlRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get status platform
         * @param {updateToken1VEnum} v Version
         * @param {updateToken1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {updateToken1RoleEnum} role Token role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateToken1: async (v, language, projectId, channelId, role, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('updateToken1', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('updateToken1', 'language', language);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('updateToken1', 'projectId', projectId);
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('updateToken1', 'channelId', channelId);
            // verify required parameter 'role' is not null or undefined
            (0, common_1.assertParamExists)('updateToken1', 'role', role);
            const localVarPath = `/method/channel_settings/update-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }
            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Set transcoder from channel. Personal settings.
         * @param {SiteSetTranscoderRequest} siteSetTranscoderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTranscoder1: async (siteSetTranscoderRequest, options = {}) => {
            // verify required parameter 'siteSetTranscoderRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateTranscoder1', 'siteSetTranscoderRequest', siteSetTranscoderRequest);
            const localVarPath = `/method/channel_settings/setTranscoder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(siteSetTranscoderRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get telegram post by filter
         * @param {TelegramGetPostByFilterVEnum} v Version
         * @param {TelegramGetPostByFilterLanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {number} filterMode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegramGetPostByFilter: async (v, language, projectId, channelId, filterMode, options = {}) => {
            // verify required parameter 'v' is not null or undefined
            (0, common_1.assertParamExists)('telegramGetPostByFilter', 'v', v);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('telegramGetPostByFilter', 'language', language);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('telegramGetPostByFilter', 'projectId', projectId);
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('telegramGetPostByFilter', 'channelId', channelId);
            // verify required parameter 'filterMode' is not null or undefined
            (0, common_1.assertParamExists)('telegramGetPostByFilter', 'filterMode', filterMode);
            const localVarPath = `/method/channel_settings/chat/telegram/posts/get-by-filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (v !== undefined) {
                localVarQueryParameter['v'] = v;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }
            if (filterMode !== undefined) {
                localVarQueryParameter['filter_mode'] = filterMode;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.axiosParamCreator = axiosParamCreator;
/**
 * ChannelSettingsApi - functional programming interface
 * @export
 */
const fp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.axiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Get telegram settings
         * @param {getTelegramSetting1VEnum} v Version
         * @param {getTelegramSetting1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTelegramSetting1(v, language, projectId, channelId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTelegramSetting1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.getTelegramSetting1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get code for connected chat
         * @param {initTelegramChatConnect1VEnum} v Version
         * @param {initTelegramChatConnect1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initTelegramChatConnect1(v, language, projectId, channelId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.initTelegramChatConnect1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.initTelegramChatConnect1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Disconnect telegram chat
         * @param {removeTelegramChat1VEnum} v Version
         * @param {removeTelegramChat1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTelegramChat1(v, language, projectId, channelId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTelegramChat1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.removeTelegramChat1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Set telegram settings
         * @param {setTelegramSetting1VEnum} v Version
         * @param {setTelegramSetting1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {SiteTelegramSetSettingsRequestDto} siteTelegramSetSettingsRequestDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTelegramSetting1(v, language, projectId, channelId, siteTelegramSetSettingsRequestDto, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTelegramSetting1(v, language, projectId, channelId, siteTelegramSetSettingsRequestDto, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.setTelegramSetting1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get telegram post list
         * @param {telegramPosts1VEnum} v Version
         * @param {telegramPosts1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async telegramPosts1(v, language, projectId, channelId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.telegramPosts1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.telegramPosts1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Optional settings for telegram
         * @param {SiteUpdateChatTelegramRequest} siteUpdateChatTelegramRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOptionsTelegram1(siteUpdateChatTelegramRequest, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOptionsTelegram1(siteUpdateChatTelegramRequest, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.updateOptionsTelegram1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get planned list
         * @param {getPlanned1VEnum} v Version
         * @param {getPlanned1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlanned1(v, language, projectId, channelId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlanned1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.getPlanned1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get playlists from the platform
         * @param {getPlayList1VEnum} v Version
         * @param {getPlayList1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayList1(v, language, projectId, channelId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayList1(v, language, projectId, channelId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.getPlayList1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Optional settings for ok. Depends on the tariff.
         * @param {SiteUpdateOptionsOkRequest} siteUpdateOptionsOkRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOptionsOk1(siteUpdateOptionsOkRequest, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOptionsOk1(siteUpdateOptionsOkRequest, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.updateOptionsOk1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Optional settings for trovo. Depends on the tariff.
         * @param {SiteUpdateOptionsTrovoRequest} siteUpdateOptionsTrovoRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOptionsTrovo1(siteUpdateOptionsTrovoRequest, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOptionsTrovo1(siteUpdateOptionsTrovoRequest, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.updateOptionsTrovo1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Optional settings for twitch. Depends on the tariff.
         * @param {SiteUpdateOptionsTwitchRequest} siteUpdateOptionsTwitchRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOptionsTwitch1(siteUpdateOptionsTwitchRequest, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOptionsTwitch1(siteUpdateOptionsTwitchRequest, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.updateOptionsTwitch1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Optional settings for vk. Depends on the tariff.
         * @param {SiteUpdateOptionsVkRequest} siteUpdateOptionsVkRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOptionsVk1(siteUpdateOptionsVkRequest, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOptionsVk1(siteUpdateOptionsVkRequest, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.updateOptionsVk1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Optional settings for vk video live. Depends on the tariff.
         * @param {SiteUpdateOptionsVkVideoLiveRequest} siteUpdateOptionsVkVideoLiveRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOptionsVkVideoLive1(siteUpdateOptionsVkVideoLiveRequest, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOptionsVkVideoLive1(siteUpdateOptionsVkVideoLiveRequest, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.updateOptionsVkVideoLive1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Optional settings for youtube. Depends on the tariff.
         * @param {SiteUpdateOptionsYoutubeRequest} siteUpdateOptionsYoutubeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOptionsYoutube1(siteUpdateOptionsYoutubeRequest, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOptionsYoutube1(siteUpdateOptionsYoutubeRequest, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.updateOptionsYoutube1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Set planned id. Depends on the tariff.
         * @param {SiteSetPlannedRequest} siteSetPlannedRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlanned1(siteSetPlannedRequest, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlanned1(siteSetPlannedRequest, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.updatePlanned1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get status platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus1(options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus1(options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.getStatus1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Set name from custom channel. Global settings.
         * @param {SiteSetNameRequest} siteSetNameRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setName1(siteSetNameRequest, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.setName1(siteSetNameRequest, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.setName1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Set rtmp url from channel. Global settings.
         * @param {SiteSetUrlRequest} siteSetUrlRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRtmp1(siteSetUrlRequest, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRtmp1(siteSetUrlRequest, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.updateRtmp1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get status platform
         * @param {updateToken1VEnum} v Version
         * @param {updateToken1LanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {updateToken1RoleEnum} role Token role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateToken1(v, language, projectId, channelId, role, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateToken1(v, language, projectId, channelId, role, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.updateToken1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Set transcoder from channel. Personal settings.
         * @param {SiteSetTranscoderRequest} siteSetTranscoderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTranscoder1(siteSetTranscoderRequest, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTranscoder1(siteSetTranscoderRequest, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.updateTranscoder1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get telegram post by filter
         * @param {TelegramGetPostByFilterVEnum} v Version
         * @param {TelegramGetPostByFilterLanguageEnum} language Current language
         * @param {number} projectId Project id
         * @param {number} channelId Channel id
         * @param {number} filterMode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async telegramGetPostByFilter(v, language, projectId, channelId, filterMode, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.telegramGetPostByFilter(v, language, projectId, channelId, filterMode, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelSettingsApi.telegramGetPostByFilter']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.fp = fp;
/**
 * ChannelSettingsApi - factory interface
 * @export
 */
const factory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.fp)(configuration);
    return {
        /**
         *
         * @summary Get telegram settings
         * @param {getTelegramSetting1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegramSetting1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || getTelegramSetting1VEnum._1;
            return localVarFp.getTelegramSetting1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get code for connected chat
         * @param {initTelegramChatConnect1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initTelegramChatConnect1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || initTelegramChatConnect1VEnum._1;
            return localVarFp.initTelegramChatConnect1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Disconnect telegram chat
         * @param {removeTelegramChat1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTelegramChat1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || removeTelegramChat1VEnum._1;
            return localVarFp.removeTelegramChat1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Set telegram settings
         * @param {setTelegramSetting1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTelegramSetting1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || setTelegramSetting1VEnum._1;
            return localVarFp.setTelegramSetting1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.siteTelegramSetSettingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get telegram post list
         * @param {telegramPosts1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegramPosts1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || telegramPosts1VEnum._1;
            return localVarFp.telegramPosts1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Optional settings for telegram
         * @param {updateOptionsTelegram1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsTelegram1(requestParameters, options) {
            return localVarFp.updateOptionsTelegram1(requestParameters.siteUpdateChatTelegramRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get planned list
         * @param {getPlanned1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlanned1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || getPlanned1VEnum._1;
            return localVarFp.getPlanned1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get playlists from the platform
         * @param {getPlayList1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayList1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || getPlayList1VEnum._1;
            return localVarFp.getPlayList1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Optional settings for ok. Depends on the tariff.
         * @param {updateOptionsOk1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsOk1(requestParameters, options) {
            return localVarFp.updateOptionsOk1(requestParameters.siteUpdateOptionsOkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Optional settings for trovo. Depends on the tariff.
         * @param {updateOptionsTrovo1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsTrovo1(requestParameters, options) {
            return localVarFp.updateOptionsTrovo1(requestParameters.siteUpdateOptionsTrovoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Optional settings for twitch. Depends on the tariff.
         * @param {updateOptionsTwitch1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsTwitch1(requestParameters, options) {
            return localVarFp.updateOptionsTwitch1(requestParameters.siteUpdateOptionsTwitchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Optional settings for vk. Depends on the tariff.
         * @param {updateOptionsVk1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsVk1(requestParameters, options) {
            return localVarFp.updateOptionsVk1(requestParameters.siteUpdateOptionsVkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Optional settings for vk video live. Depends on the tariff.
         * @param {updateOptionsVkVideoLive1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsVkVideoLive1(requestParameters, options) {
            return localVarFp.updateOptionsVkVideoLive1(requestParameters.siteUpdateOptionsVkVideoLiveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Optional settings for youtube. Depends on the tariff.
         * @param {updateOptionsYoutube1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOptionsYoutube1(requestParameters, options) {
            return localVarFp.updateOptionsYoutube1(requestParameters.siteUpdateOptionsYoutubeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Set planned id. Depends on the tariff.
         * @param {updatePlanned1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlanned1(requestParameters, options) {
            return localVarFp.updatePlanned1(requestParameters.siteSetPlannedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get status platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus1(options) {
            return localVarFp.getStatus1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Set name from custom channel. Global settings.
         * @param {setName1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setName1(requestParameters, options) {
            return localVarFp.setName1(requestParameters.siteSetNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Set rtmp url from channel. Global settings.
         * @param {updateRtmp1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRtmp1(requestParameters, options) {
            return localVarFp.updateRtmp1(requestParameters.siteSetUrlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get status platform
         * @param {updateToken1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateToken1(requestParameters, options) {
            // Автоматически устанавливаем версию из названия метода если не передана
            const actualV = requestParameters.v || updateToken1VEnum._1;
            return localVarFp.updateToken1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.role, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Set transcoder from channel. Personal settings.
         * @param {updateTranscoder1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTranscoder1(requestParameters, options) {
            return localVarFp.updateTranscoder1(requestParameters.siteSetTranscoderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get telegram post by filter
         * @param {telegramGetPostByFilterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegramGetPostByFilter(requestParameters, options) {
            return localVarFp.telegramGetPostByFilter(requestParameters.v, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.filterMode, options).then((request) => request(axios, basePath));
        },
    };
};
exports.factory = factory;
/**
 * ChannelSettingsApi - object-oriented interface
 * @export
 * @class ChannelSettingsApi
 * @extends {BaseAPI}
 */
class ChannelSettingsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get telegram settings
     * @param {getTelegramSetting1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    getTelegramSetting1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || getTelegramSetting1VEnum._1;
        return (0, exports.fp)(this.configuration).getTelegramSetting1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get code for connected chat
     * @param {initTelegramChatConnect1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    initTelegramChatConnect1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || initTelegramChatConnect1VEnum._1;
        return (0, exports.fp)(this.configuration).initTelegramChatConnect1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Disconnect telegram chat
     * @param {removeTelegramChat1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    removeTelegramChat1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || removeTelegramChat1VEnum._1;
        return (0, exports.fp)(this.configuration).removeTelegramChat1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Set telegram settings
     * @param {setTelegramSetting1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    setTelegramSetting1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || setTelegramSetting1VEnum._1;
        return (0, exports.fp)(this.configuration).setTelegramSetting1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.siteTelegramSetSettingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get telegram post list
     * @param {telegramPosts1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    telegramPosts1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || telegramPosts1VEnum._1;
        return (0, exports.fp)(this.configuration).telegramPosts1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Optional settings for telegram
     * @param {updateOptionsTelegram1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    updateOptionsTelegram1(requestParameters, options) {
        return (0, exports.fp)(this.configuration).updateOptionsTelegram1(requestParameters.siteUpdateChatTelegramRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get planned list
     * @param {getPlanned1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    getPlanned1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || getPlanned1VEnum._1;
        return (0, exports.fp)(this.configuration).getPlanned1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get playlists from the platform
     * @param {getPlayList1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    getPlayList1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || getPlayList1VEnum._1;
        return (0, exports.fp)(this.configuration).getPlayList1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Optional settings for ok. Depends on the tariff.
     * @param {updateOptionsOk1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    updateOptionsOk1(requestParameters, options) {
        return (0, exports.fp)(this.configuration).updateOptionsOk1(requestParameters.siteUpdateOptionsOkRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Optional settings for trovo. Depends on the tariff.
     * @param {updateOptionsTrovo1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    updateOptionsTrovo1(requestParameters, options) {
        return (0, exports.fp)(this.configuration).updateOptionsTrovo1(requestParameters.siteUpdateOptionsTrovoRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Optional settings for twitch. Depends on the tariff.
     * @param {updateOptionsTwitch1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    updateOptionsTwitch1(requestParameters, options) {
        return (0, exports.fp)(this.configuration).updateOptionsTwitch1(requestParameters.siteUpdateOptionsTwitchRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Optional settings for vk. Depends on the tariff.
     * @param {updateOptionsVk1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    updateOptionsVk1(requestParameters, options) {
        return (0, exports.fp)(this.configuration).updateOptionsVk1(requestParameters.siteUpdateOptionsVkRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Optional settings for vk video live. Depends on the tariff.
     * @param {updateOptionsVkVideoLive1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    updateOptionsVkVideoLive1(requestParameters, options) {
        return (0, exports.fp)(this.configuration).updateOptionsVkVideoLive1(requestParameters.siteUpdateOptionsVkVideoLiveRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Optional settings for youtube. Depends on the tariff.
     * @param {updateOptionsYoutube1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    updateOptionsYoutube1(requestParameters, options) {
        return (0, exports.fp)(this.configuration).updateOptionsYoutube1(requestParameters.siteUpdateOptionsYoutubeRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Set planned id. Depends on the tariff.
     * @param {updatePlanned1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    updatePlanned1(requestParameters, options) {
        return (0, exports.fp)(this.configuration).updatePlanned1(requestParameters.siteSetPlannedRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get status platform
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    getStatus1(options) {
        return (0, exports.fp)(this.configuration).getStatus1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Set name from custom channel. Global settings.
     * @param {setName1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    setName1(requestParameters, options) {
        return (0, exports.fp)(this.configuration).setName1(requestParameters.siteSetNameRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Set rtmp url from channel. Global settings.
     * @param {updateRtmp1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    updateRtmp1(requestParameters, options) {
        return (0, exports.fp)(this.configuration).updateRtmp1(requestParameters.siteSetUrlRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get status platform
     * @param {updateToken1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    updateToken1(requestParameters, options) {
        // Автоматически устанавливаем версию из названия метода если не передана
        const actualV = requestParameters.v || updateToken1VEnum._1;
        return (0, exports.fp)(this.configuration).updateToken1(actualV, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.role, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Set transcoder from channel. Personal settings.
     * @param {updateTranscoder1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    updateTranscoder1(requestParameters, options) {
        return (0, exports.fp)(this.configuration).updateTranscoder1(requestParameters.siteSetTranscoderRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get telegram post by filter
     * @param {telegramGetPostByFilterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelSettingsApi
     */
    telegramGetPostByFilter(requestParameters, options) {
        return (0, exports.fp)(this.configuration).telegramGetPostByFilter(requestParameters.v, requestParameters.language, requestParameters.projectId, requestParameters.channelId, requestParameters.filterMode, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ChannelSettingsApi = ChannelSettingsApi;
/**
  * @export
  * @enum {string}
  */
var getTelegramSetting1VEnum;
(function (getTelegramSetting1VEnum) {
    getTelegramSetting1VEnum["_1"] = "1";
    getTelegramSetting1VEnum["_2"] = "2";
    getTelegramSetting1VEnum["_3"] = "3";
})(getTelegramSetting1VEnum || (exports.getTelegramSetting1VEnum = getTelegramSetting1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var getTelegramSetting1LanguageEnum;
(function (getTelegramSetting1LanguageEnum) {
    getTelegramSetting1LanguageEnum["ru"] = "ru";
    getTelegramSetting1LanguageEnum["en"] = "en";
    getTelegramSetting1LanguageEnum["cn"] = "cn";
})(getTelegramSetting1LanguageEnum || (exports.getTelegramSetting1LanguageEnum = getTelegramSetting1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var initTelegramChatConnect1VEnum;
(function (initTelegramChatConnect1VEnum) {
    initTelegramChatConnect1VEnum["_1"] = "1";
    initTelegramChatConnect1VEnum["_2"] = "2";
    initTelegramChatConnect1VEnum["_3"] = "3";
})(initTelegramChatConnect1VEnum || (exports.initTelegramChatConnect1VEnum = initTelegramChatConnect1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var initTelegramChatConnect1LanguageEnum;
(function (initTelegramChatConnect1LanguageEnum) {
    initTelegramChatConnect1LanguageEnum["ru"] = "ru";
    initTelegramChatConnect1LanguageEnum["en"] = "en";
    initTelegramChatConnect1LanguageEnum["cn"] = "cn";
})(initTelegramChatConnect1LanguageEnum || (exports.initTelegramChatConnect1LanguageEnum = initTelegramChatConnect1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var removeTelegramChat1VEnum;
(function (removeTelegramChat1VEnum) {
    removeTelegramChat1VEnum["_1"] = "1";
    removeTelegramChat1VEnum["_2"] = "2";
    removeTelegramChat1VEnum["_3"] = "3";
})(removeTelegramChat1VEnum || (exports.removeTelegramChat1VEnum = removeTelegramChat1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var removeTelegramChat1LanguageEnum;
(function (removeTelegramChat1LanguageEnum) {
    removeTelegramChat1LanguageEnum["ru"] = "ru";
    removeTelegramChat1LanguageEnum["en"] = "en";
    removeTelegramChat1LanguageEnum["cn"] = "cn";
})(removeTelegramChat1LanguageEnum || (exports.removeTelegramChat1LanguageEnum = removeTelegramChat1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var setTelegramSetting1VEnum;
(function (setTelegramSetting1VEnum) {
    setTelegramSetting1VEnum["_1"] = "1";
    setTelegramSetting1VEnum["_2"] = "2";
    setTelegramSetting1VEnum["_3"] = "3";
})(setTelegramSetting1VEnum || (exports.setTelegramSetting1VEnum = setTelegramSetting1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var setTelegramSetting1LanguageEnum;
(function (setTelegramSetting1LanguageEnum) {
    setTelegramSetting1LanguageEnum["ru"] = "ru";
    setTelegramSetting1LanguageEnum["en"] = "en";
    setTelegramSetting1LanguageEnum["cn"] = "cn";
})(setTelegramSetting1LanguageEnum || (exports.setTelegramSetting1LanguageEnum = setTelegramSetting1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var telegramPosts1VEnum;
(function (telegramPosts1VEnum) {
    telegramPosts1VEnum["_1"] = "1";
    telegramPosts1VEnum["_2"] = "2";
    telegramPosts1VEnum["_3"] = "3";
})(telegramPosts1VEnum || (exports.telegramPosts1VEnum = telegramPosts1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var telegramPosts1LanguageEnum;
(function (telegramPosts1LanguageEnum) {
    telegramPosts1LanguageEnum["ru"] = "ru";
    telegramPosts1LanguageEnum["en"] = "en";
    telegramPosts1LanguageEnum["cn"] = "cn";
})(telegramPosts1LanguageEnum || (exports.telegramPosts1LanguageEnum = telegramPosts1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var getPlanned1VEnum;
(function (getPlanned1VEnum) {
    getPlanned1VEnum["_1"] = "1";
    getPlanned1VEnum["_2"] = "2";
    getPlanned1VEnum["_3"] = "3";
})(getPlanned1VEnum || (exports.getPlanned1VEnum = getPlanned1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var getPlanned1LanguageEnum;
(function (getPlanned1LanguageEnum) {
    getPlanned1LanguageEnum["ru"] = "ru";
    getPlanned1LanguageEnum["en"] = "en";
    getPlanned1LanguageEnum["cn"] = "cn";
})(getPlanned1LanguageEnum || (exports.getPlanned1LanguageEnum = getPlanned1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var getPlayList1VEnum;
(function (getPlayList1VEnum) {
    getPlayList1VEnum["_1"] = "1";
    getPlayList1VEnum["_2"] = "2";
    getPlayList1VEnum["_3"] = "3";
})(getPlayList1VEnum || (exports.getPlayList1VEnum = getPlayList1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var getPlayList1LanguageEnum;
(function (getPlayList1LanguageEnum) {
    getPlayList1LanguageEnum["ru"] = "ru";
    getPlayList1LanguageEnum["en"] = "en";
    getPlayList1LanguageEnum["cn"] = "cn";
})(getPlayList1LanguageEnum || (exports.getPlayList1LanguageEnum = getPlayList1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var updateToken1VEnum;
(function (updateToken1VEnum) {
    updateToken1VEnum["_1"] = "1";
    updateToken1VEnum["_2"] = "2";
    updateToken1VEnum["_3"] = "3";
})(updateToken1VEnum || (exports.updateToken1VEnum = updateToken1VEnum = {}));
/**
  * @export
  * @enum {string}
  */
var updateToken1LanguageEnum;
(function (updateToken1LanguageEnum) {
    updateToken1LanguageEnum["ru"] = "ru";
    updateToken1LanguageEnum["en"] = "en";
    updateToken1LanguageEnum["cn"] = "cn";
})(updateToken1LanguageEnum || (exports.updateToken1LanguageEnum = updateToken1LanguageEnum = {}));
/**
  * @export
  * @enum {string}
  */
var updateToken1RoleEnum;
(function (updateToken1RoleEnum) {
    updateToken1RoleEnum["account"] = "account";
    updateToken1RoleEnum["group"] = "group";
})(updateToken1RoleEnum || (exports.updateToken1RoleEnum = updateToken1RoleEnum = {}));
/**
  * @export
  * @enum {string}
  */
var TelegramGetPostByFilterVEnum;
(function (TelegramGetPostByFilterVEnum) {
    TelegramGetPostByFilterVEnum["_1"] = "1";
    TelegramGetPostByFilterVEnum["_2"] = "2";
    TelegramGetPostByFilterVEnum["_3"] = "3";
})(TelegramGetPostByFilterVEnum || (exports.TelegramGetPostByFilterVEnum = TelegramGetPostByFilterVEnum = {}));
/**
  * @export
  * @enum {string}
  */
var TelegramGetPostByFilterLanguageEnum;
(function (TelegramGetPostByFilterLanguageEnum) {
    TelegramGetPostByFilterLanguageEnum["ru"] = "ru";
    TelegramGetPostByFilterLanguageEnum["en"] = "en";
    TelegramGetPostByFilterLanguageEnum["cn"] = "cn";
})(TelegramGetPostByFilterLanguageEnum || (exports.TelegramGetPostByFilterLanguageEnum = TelegramGetPostByFilterLanguageEnum = {}));
